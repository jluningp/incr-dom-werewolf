// Generated by js_of_ocaml 3.7.0
(function(joo_global_object)
   {(function()
       {var
         DefaultLocale=
          {days:
           ["Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"],
           shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],
           months:
           ["January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"],
           shortMonths:
           ["Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"],
           AM:"AM",
           PM:"PM",
           am:"am",
           pm:"pm",
           formats:
           {D:"%m/%d/%y",
            F:"%Y-%m-%d",
            R:"%H:%M",
            T:"%H:%M:%S",
            X:"%T",
            c:"%a %b %d %X %Y",
            r:"%I:%M:%S %p",
            v:"%e-%b-%Y",
            x:"%D"}},
         defaultStrftime=new Strftime(DefaultLocale,0,false),
         isCommonJS=typeof module !== "undefined",
         namespace;
        if(isCommonJS)
         {namespace = module.exports = adaptedStrftime;
          namespace.strftime = deprecatedStrftime;
          if(joo_global_object)joo_global_object.strftime = adaptedStrftime}
        else
         {namespace
          =
          joo_global_object
          ||
          function(){return this || (1,eval)("this")}();
          namespace.strftime = adaptedStrftime}
        var
         _require=isCommonJS?"require('strftime')":"strftime",
         _deprecationWarnings={};
        function deprecationWarning(name,instead)
         {if(! _deprecationWarnings[name])
           {if
             (typeof console
              !==
              "undefined"
              &&
              typeof console.warn
              ==
              "function")
             console.warn
              ("[WARNING] "
               +
               name
               +
               " is deprecated and will be removed in version 1.0. Instead, use `"
               +
               instead
               +
               "`.");
            _deprecationWarnings[name] = true}}
        namespace.strftimeTZ = deprecatedStrftimeTZ;
        namespace.strftimeUTC = deprecatedStrftimeUTC;
        namespace.localizedStrftime = deprecatedStrftimeLocalized;
        function adaptForwards(fn)
         {fn.localize = defaultStrftime.localize.bind(defaultStrftime);
          fn.timezone = defaultStrftime.timezone.bind(defaultStrftime);
          fn.utc = defaultStrftime.utc.bind(defaultStrftime)}
        adaptForwards(adaptedStrftime);
        function adaptedStrftime(fmt,d,locale)
         {if(d && d.days){locale = d;d = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + "(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        adaptForwards(deprecatedStrftime);
        function deprecatedStrftime(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftime(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftime(format, [date])`",
             _require + "(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeTZ(fmt,d,locale,timezone)
         {if
           ((typeof locale == "number" || typeof locale == "string")
            &&
            timezone
            ==
            null)
           {timezone = locale;locale = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, locale, tz)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).timezone(tz); s(format, [date])` or `var s = "
             +
             _require
             +
             ".localize(locale); s.timezone(tz)(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, tz)`",
             "var s = "
             +
             _require
             +
             ".timezone(tz); s(format, [date])` or `"
             +
             _require
             +
             ".timezone(tz)(format, [date])");
          var
           strftime=
            (locale?defaultStrftime.localize(locale):defaultStrftime).timezone
             (timezone);
          return strftime(fmt,d)}
        var utcStrftime=defaultStrftime.utc();
        function deprecatedStrftimeUTC(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, date, locale)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).utc(); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, [date])`",
             "var s = " + _require + ".utc(); s(format, [date])");
          var strftime=locale?utcStrftime.localize(locale):utcStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeLocalized(locale)
         {deprecationWarning
           ("`" + _require + ".localizedStrftime(locale)`",
            _require + ".localize(locale)");
          return defaultStrftime.localize(locale)}
        if(typeof Date.now !== "function")
         Date.now = function(){return + new Date()};
        function Strftime(locale,customTimezoneOffset,useUtcTimezone)
         {var
           _locale=locale || DefaultLocale,
           _customTimezoneOffset=customTimezoneOffset || 0,
           _useUtcBasedDate=useUtcTimezone || false,
           _cachedDateTimestamp=0,
           _cachedDate;
          function _strftime(format,date)
           {var timestamp;
            if(! date)
             {var currentTimestamp=Date.now();
              if(currentTimestamp > _cachedDateTimestamp)
               {_cachedDateTimestamp = currentTimestamp;
                _cachedDate = new Date(_cachedDateTimestamp);
                timestamp = _cachedDateTimestamp;
                if(_useUtcBasedDate)
                 _cachedDate
                 =
                 new
                  Date
                  (_cachedDateTimestamp
                   +
                   getTimestampToUtcOffsetFor(_cachedDate)
                   +
                   _customTimezoneOffset)}
              date = _cachedDate}
            else
             {timestamp = date.getTime();
              if(_useUtcBasedDate)
               date
               =
               new
                Date
                (date.getTime()
                 +
                 getTimestampToUtcOffsetFor(date)
                 +
                 _customTimezoneOffset)}
            return _processFormat(format,date,_locale,timestamp)}
          function _processFormat(format,date,locale,timestamp)
           {var
             resultString="",
             padding=null,
             isInScope=false,
             length=format.length,
             extendedTZ=false;
            for(var i=0;i < length;i++)
             {var currentCharCode=format.charCodeAt(i);
              if(isInScope === true)
               {if(currentCharCode === 45)
                 {padding = "";continue}
                else
                 if(currentCharCode === 95)
                  {padding = " ";continue}
                 else
                  if(currentCharCode === 48)
                   {padding = "0";continue}
                  else
                   if(currentCharCode === 58)
                    {if(extendedTZ)
                      if
                       (typeof console
                        !==
                        "undefined"
                        &&
                        typeof console.warn
                        ==
                        "function")
                       console.warn
                        ("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
                     extendedTZ = true;
                     continue}
                switch(currentCharCode)
                 {case 65:resultString += locale.days[date.getDay()];break;
                  case 66:
                   resultString += locale.months[date.getMonth()];break;
                  case 67:
                   resultString
                   +=
                   padTill2(Math.floor(date.getFullYear() / 100),padding);
                   break;
                  case 68:
                   resultString
                   +=
                   _processFormat(locale.formats.D,date,locale,timestamp);
                   break;
                  case 70:
                   resultString
                   +=
                   _processFormat(locale.formats.F,date,locale,timestamp);
                   break;
                  case 72:
                   resultString += padTill2(date.getHours(),padding);break;
                  case 73:
                   resultString += padTill2(hours12(date.getHours()),padding);
                   break;
                  case 76:
                   resultString += padTill3(Math.floor(timestamp % 1000));
                   break;
                  case 77:
                   resultString += padTill2(date.getMinutes(),padding);break;
                  case 80:
                   resultString += date.getHours() < 12?locale.am:locale.pm;
                   break;
                  case 82:
                   resultString
                   +=
                   _processFormat(locale.formats.R,date,locale,timestamp);
                   break;
                  case 83:
                   resultString += padTill2(date.getSeconds(),padding);break;
                  case 84:
                   resultString
                   +=
                   _processFormat(locale.formats.T,date,locale,timestamp);
                   break;
                  case 85:
                   resultString += padTill2(weekNumber(date,"sunday"),padding);
                   break;
                  case 87:
                   resultString += padTill2(weekNumber(date,"monday"),padding);
                   break;
                  case 88:
                   resultString
                   +=
                   _processFormat(locale.formats.X,date,locale,timestamp);
                   break;
                  case 89:resultString += date.getFullYear();break;
                  case 90:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += "GMT";
                   else
                    {var tzString=date.toString().match(/\(([\w\s]+)\)/);
                     resultString += tzString && tzString[1] || ""}
                   break;
                  case 97:
                   resultString += locale.shortDays[date.getDay()];break;
                  case 98:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 99:
                   resultString
                   +=
                   _processFormat(locale.formats.c,date,locale,timestamp);
                   break;
                  case 100:
                   resultString += padTill2(date.getDate(),padding);break;
                  case 101:
                   resultString
                   +=
                   padTill2(date.getDate(),padding == null?" ":padding);
                   break;
                  case 104:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 106:
                   var
                    y=new Date(date.getFullYear(),0,1),
                    day=
                     Math.ceil
                      ((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
                   resultString += padTill3(day);
                   break;
                  case 107:
                   resultString
                   +=
                   padTill2(date.getHours(),padding == null?" ":padding);
                   break;
                  case 108:
                   resultString
                   +=
                   padTill2
                    (hours12(date.getHours()),padding == null?" ":padding);
                   break;
                  case 109:
                   resultString += padTill2(date.getMonth() + 1,padding);break;
                  case 110:resultString += "\n";break;
                  case 111:
                   resultString
                   +=
                   String(date.getDate())
                   +
                   ordinal(date.getDate());
                   break;
                  case 112:
                   resultString += date.getHours() < 12?locale.AM:locale.PM;
                   break;
                  case 114:
                   resultString
                   +=
                   _processFormat(locale.formats.r,date,locale,timestamp);
                   break;
                  case 115:resultString += Math.floor(timestamp / 1000);break;
                  case 116:resultString += "\t";break;
                  case 117:
                   var day=date.getDay();resultString += day === 0?7:day;break;
                  case 118:
                   resultString
                   +=
                   _processFormat(locale.formats.v,date,locale,timestamp);
                   break;
                  case 119:resultString += date.getDay();break;
                  case 120:
                   resultString
                   +=
                   _processFormat(locale.formats.x,date,locale,timestamp);
                   break;
                  case 121:
                   resultString += ("" + date.getFullYear()).slice(2);break;
                  case 122:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += extendedTZ?"+00:00":"+0000";
                   else
                    {var off;
                     if(_customTimezoneOffset !== 0)
                      off = _customTimezoneOffset / (60 * 1000);
                     else
                      off = - date.getTimezoneOffset();
                     var
                      sign=off < 0?"-":"+",
                      sep=extendedTZ?":":"",
                      hours=Math.floor(Math.abs(off / 60)),
                      mins=Math.abs(off % 60);
                     resultString
                     +=
                     sign
                     +
                     padTill2(hours)
                     +
                     sep
                     +
                     padTill2(mins)}
                   break;
                  default:resultString += format[i];break}
                padding = null;
                isInScope = false;
                continue}
              if(currentCharCode === 37){isInScope = true;continue}
              resultString += format[i]}
            return resultString}
          var strftime=_strftime;
          strftime.localize
          =
          function(locale)
           {return new
                    Strftime
                    (locale || _locale,_customTimezoneOffset,_useUtcBasedDate)};
          strftime.timezone
          =
          function(timezone)
           {var
             customTimezoneOffset=_customTimezoneOffset,
             useUtcBasedDate=_useUtcBasedDate,
             timezoneType=typeof timezone;
            if(timezoneType === "number" || timezoneType === "string")
             {useUtcBasedDate = true;
              if(timezoneType === "string")
               {var
                 sign=timezone[0] === "-"?- 1:1,
                 hours=parseInt(timezone.slice(1,3),10),
                 minutes=parseInt(timezone.slice(3,5),10);
                customTimezoneOffset
                =
                sign
                *
                (60 * hours + minutes)
                *
                60
                *
                1000}
              else
               if(timezoneType === "number")
                customTimezoneOffset = timezone * 60 * 1000}
            return new Strftime(_locale,customTimezoneOffset,useUtcBasedDate)};
          strftime.utc
          =
          function(){return new Strftime(_locale,_customTimezoneOffset,true)};
          return strftime}
        function padTill2(numberToPad,paddingChar)
         {if(paddingChar === "" || numberToPad > 9)return numberToPad;
          if(paddingChar == null)paddingChar = "0";
          return paddingChar + numberToPad}
        function padTill3(numberToPad)
         {if(numberToPad > 99)return numberToPad;
          if(numberToPad > 9)return "0" + numberToPad;
          return "00" + numberToPad}
        function hours12(hour)
         {if(hour === 0)return 12;else if(hour > 12)return hour - 12;
          return hour}
        function weekNumber(date,firstWeekday)
         {firstWeekday = firstWeekday || "sunday";
          var weekday=date.getDay();
          if(firstWeekday === "monday")
           if(weekday === 0)weekday = 6;else weekday--;
          var
           firstDayOfYearUtc=Date.UTC(date.getFullYear(),0,1),
           dateUtc=Date.UTC(date.getFullYear(),date.getMonth(),date.getDate()),
           yday=Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
           weekNum=(yday + 7 - weekday) / 7;
          return Math.floor(weekNum)}
        function ordinal(number)
         {var i=number % 10,ii=number % 100;
          if(ii >= 11 && ii <= 13 || i === 0 || i >= 4)return "th";
          switch(i){case 1:return "st";case 2:return "nd";case 3:return "rd"}}
        function getTimestampToUtcOffsetFor(date)
         {return (date.getTimezoneOffset() || 0) * 60000}}
      ())}
  (function(){return this}()));
(function(joo_global_object)
   {(function(f)
       {if(typeof exports === "object" && typeof module !== "undefined")
         module.exports = f();
        else
         if(typeof define === "function" && define.amd)
          define([],f);
         else
          {var g;
           if(typeof window !== "undefined")
            g = window;
           else
            if(typeof global !== "undefined")
             g = global;
            else
             if(typeof self !== "undefined")g = self;else g = this;
           g.VirtualDom = f()}}
      (function()
        {var define,module,exports;
         return function e(t,n,r)
                   {function s(o,u)
                     {if(! n[o])
                       {if(! t[o])
                         {var a=typeof require == "function" && require;
                          if(! u && a)return a(o,! 0);
                          if(i)return i(o,! 0);
                          var f=new Error("Cannot find module '" + o + "'");
                          throw f.code = "MODULE_NOT_FOUND",f}
                        var l=n[o] = {exports:{}};
                        t[o][0].call
                         (l.exports,
                          function(e){var n=t[o][1][e];return s(n?n:e)},
                          l,
                          l.exports,
                          e,
                          t,
                          n,
                          r)}
                      return n[o].exports}
                    var i=typeof require == "function" && require;
                    for(var o=0;o < r.length;o++)s(r[o]);
                    return s}
                  ({1:
                    [function(require,module,exports)
                      {var createElement=require("./vdom/create-element.js");
                       module.exports = createElement},
                     {"./vdom/create-element.js":24}],
                    2:
                    [function(require,module,exports)
                      {var diff=require("./vtree/diff.js");module.exports = diff},
                     {"./vtree/diff.js":47}],
                    3:
                    [function(require,module,exports)
                      {module.exports
                       =
                       function(undef)
                         {var
                           nativeSplit=String.prototype.split,
                           compliantExecNpcg=/()??/.exec("")[1] === undef,
                           self;
                          self
                          =
                          function(str,separator,limit)
                           {if
                             (Object.prototype.toString.call(separator)
                              !==
                              "[object RegExp]")
                             return nativeSplit.call(str,separator,limit);
                            var
                             output=[],
                             flags=
                              (separator.ignoreCase?"i":"")
                              +
                              (separator.multiline?"m":"")
                              +
                              (separator.extended?"x":"")
                              +
                              (separator.sticky?"y":""),
                             lastLastIndex=0,
                             separator=new RegExp(separator.source,flags + "g"),
                             separator2,
                             match,
                             lastIndex,
                             lastLength;
                            str += "";
                            if(! compliantExecNpcg)
                             separator2
                             =
                             new RegExp("^" + separator.source + "$(?!\\s)",flags);
                            limit = limit === undef?- 1 >>> 0:limit >>> 0;
                            while(match = separator.exec(str))
                             {lastIndex = match.index + match[0].length;
                              if(lastIndex > lastLastIndex)
                               {output.push(str.slice(lastLastIndex,match.index));
                                if(! compliantExecNpcg && match.length > 1)
                                 match[0].replace
                                  (separator2,
                                   function()
                                    {for(var i=1;i < arguments.length - 2;i++)
                                      if(arguments[i] === undef)match[i] = undef});
                                if(match.length > 1 && match.index < str.length)
                                 Array.prototype.push.apply(output,match.slice(1));
                                lastLength = match[0].length;
                                lastLastIndex = lastIndex;
                                if(output.length >= limit)break}
                              if(separator.lastIndex === match.index)separator.lastIndex++}
                            if(lastLastIndex === str.length)
                             {if(lastLength || ! separator.test(""))output.push("")}
                            else
                             output.push(str.slice(lastLastIndex));
                            return output.length > limit?output.slice(0,limit):output};
                          return self}
                        ()},
                     {}],
                    4:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        OneVersionConstraint=require("individual/one-version"),
                        MY_VERSION="7";
                       OneVersionConstraint("ev-store",MY_VERSION);
                       var hashKey="__EV_STORE_KEY@" + MY_VERSION;
                       module.exports = EvStore;
                       function EvStore(elem)
                        {var hash=elem[hashKey];
                         if(! hash)hash = elem[hashKey] = {};
                         return hash}},
                     {"individual/one-version":6}],
                    5:
                    [function(require,module,exports)
                      {(function(global)
                          {"use strict";
                           var
                            root=
                             typeof window !== "undefined"
                              ?window
                              :typeof global !== "undefined"?global:{};
                           module.exports = Individual;
                           function Individual(key,value)
                            {if(key in root)return root[key];
                             root[key] = value;
                             return value}}.call
                         (this,
                          typeof global !== "undefined"
                           ?global
                           :typeof self !== "undefined"
                             ?self
                             :typeof window !== "undefined"?window:{}))},
                     {}],
                    6:
                    [function(require,module,exports)
                      {"use strict";
                       var Individual=require("./index.js");
                       module.exports = OneVersion;
                       function OneVersion(moduleName,version,defaultValue)
                        {var
                          key="__INDIVIDUAL_ONE_VERSION_" + moduleName,
                          enforceKey=key + "_ENFORCE_SINGLETON",
                          versionValue=Individual(enforceKey,version);
                         if(versionValue !== version)
                          throw new
                                 Error
                                 ("Can only have one copy of "
                                  +
                                  moduleName
                                  +
                                  ".\n"
                                  +
                                  "You already have version "
                                  +
                                  versionValue
                                  +
                                  " installed.\n"
                                  +
                                  "This means you cannot install version "
                                  +
                                  version);
                         return Individual(key,defaultValue)}},
                     {"./index.js":5}],
                    7:
                    [function(require,module,exports)
                      {(function(global)
                          {var
                            topLevel=
                             typeof global !== "undefined"
                              ?global
                              :typeof window !== "undefined"?window:{},
                            minDoc=require("min-document");
                           if(typeof document !== "undefined")
                            module.exports = document;
                           else
                            {var doccy=topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
                             if(! doccy)
                              doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
                             module.exports = doccy}}.call
                         (this,
                          typeof global !== "undefined"
                           ?global
                           :typeof self !== "undefined"
                             ?self
                             :typeof window !== "undefined"?window:{}))},
                     {"min-document":17}],
                    8:
                    [function(require,module,exports)
                      {var
                        domWalk=require("dom-walk"),
                        Comment=require("./dom-comment.js"),
                        DOMText=require("./dom-text.js"),
                        DOMElement=require("./dom-element.js"),
                        DocumentFragment=require("./dom-fragment.js"),
                        Event=require("./event.js"),
                        dispatchEvent=require("./event/dispatch-event.js"),
                        addEventListener=require("./event/add-event-listener.js"),
                        removeEventListener=
                         require("./event/remove-event-listener.js");
                       module.exports = Document;
                       function Document()
                        {if(! (this instanceof Document))return new Document();
                         this.head = this.createElement("head");
                         this.body = this.createElement("body");
                         this.documentElement = this.createElement("html");
                         this.documentElement.appendChild(this.head);
                         this.documentElement.appendChild(this.body);
                         this.childNodes = [this.documentElement];
                         this.nodeType = 9}
                       var proto=Document.prototype;
                       proto.createTextNode
                       =
                       function(value){return new DOMText(value,this)};
                       proto.createElementNS
                       =
                       function(namespace,tagName)
                        {var ns=namespace === null?null:String(namespace);
                         return new DOMElement(tagName,this,ns)};
                       proto.createElement
                       =
                       function(tagName){return new DOMElement(tagName,this)};
                       proto.createDocumentFragment
                       =
                       function(){return new DocumentFragment(this)};
                       proto.createEvent
                       =
                       function(family){return new Event(family)};
                       proto.createComment
                       =
                       function(data){return new Comment(data,this)};
                       proto.getElementById
                       =
                       function(id)
                        {id = String(id);
                         var
                          result=
                           domWalk
                            (this.childNodes,
                             function(node){if(String(node.id) === id)return node});
                         return result || null};
                       proto.getElementsByClassName
                       =
                       DOMElement.prototype.getElementsByClassName;
                       proto.getElementsByTagName
                       =
                       DOMElement.prototype.getElementsByTagName;
                       proto.contains = DOMElement.prototype.contains;
                       proto.removeEventListener = removeEventListener;
                       proto.addEventListener = addEventListener;
                       proto.dispatchEvent = dispatchEvent},
                     {"./dom-comment.js":9,
                      "./dom-element.js":10,
                      "./dom-fragment.js":11,
                      "./dom-text.js":12,
                      "./event.js":13,
                      "./event/add-event-listener.js":14,
                      "./event/dispatch-event.js":15,
                      "./event/remove-event-listener.js":16,
                      "dom-walk":18}],
                    9:
                    [function(require,module,exports)
                      {module.exports = Comment;
                       function Comment(data,owner)
                        {if(! (this instanceof Comment))
                          return new Comment(data,owner);
                         this.data = data;
                         this.nodeValue = data;
                         this.length = data.length;
                         this.ownerDocument = owner || null}
                       Comment.prototype.nodeType = 8;
                       Comment.prototype.nodeName = "#comment";
                       Comment.prototype.toString
                       =
                       function(){return "[object Comment]"}},
                     {}],
                    10:
                    [function(require,module,exports)
                      {var
                        domWalk=require("dom-walk"),
                        dispatchEvent=require("./event/dispatch-event.js"),
                        addEventListener=require("./event/add-event-listener.js"),
                        removeEventListener=
                         require("./event/remove-event-listener.js"),
                        serializeNode=require("./serialize.js"),
                        htmlns="http://www.w3.org/1999/xhtml";
                       module.exports = DOMElement;
                       function DOMElement(tagName,owner,namespace)
                        {if(! (this instanceof DOMElement))
                          return new DOMElement(tagName);
                         var ns=namespace === undefined?htmlns:namespace || null;
                         this.tagName
                         =
                         ns === htmlns?String(tagName).toUpperCase():tagName;
                         this.nodeName = this.tagName;
                         this.className = "";
                         this.dataset = {};
                         this.childNodes = [];
                         this.parentNode = null;
                         this.style = {};
                         this.ownerDocument = owner || null;
                         this.namespaceURI = ns;
                         this._attributes = {};
                         if(this.tagName === "INPUT")this.type = "text"}
                       DOMElement.prototype.type = "DOMElement";
                       DOMElement.prototype.nodeType = 1;
                       DOMElement.prototype.appendChild
                       =
                       function(child)
                        {if(child.parentNode)child.parentNode.removeChild(child);
                         this.childNodes.push(child);
                         child.parentNode = this;
                         return child};
                       DOMElement.prototype.replaceChild
                       =
                       function(elem,needle)
                        {if(elem.parentNode)elem.parentNode.removeChild(elem);
                         var index=this.childNodes.indexOf(needle);
                         needle.parentNode = null;
                         this.childNodes[index] = elem;
                         elem.parentNode = this;
                         return needle};
                       DOMElement.prototype.removeChild
                       =
                       function(elem)
                        {var index=this.childNodes.indexOf(elem);
                         this.childNodes.splice(index,1);
                         elem.parentNode = null;
                         return elem};
                       DOMElement.prototype.insertBefore
                       =
                       function(elem,needle)
                        {if(elem.parentNode)elem.parentNode.removeChild(elem);
                         var
                          index=
                           needle === null || needle === undefined
                            ?- 1
                            :this.childNodes.indexOf(needle);
                         if(index > - 1)
                          this.childNodes.splice(index,0,elem);
                         else
                          this.childNodes.push(elem);
                         elem.parentNode = this;
                         return elem};
                       DOMElement.prototype.setAttributeNS
                       =
                       function(namespace,name,value)
                        {var
                          prefix=null,
                          localName=name,
                          colonPosition=name.indexOf(":");
                         if(colonPosition > - 1)
                          {prefix = name.substr(0,colonPosition);
                           localName = name.substr(colonPosition + 1)}
                         var
                          attributes=
                           this._attributes[namespace]
                           ||
                           (this._attributes[namespace] = {});
                         attributes[localName] = {value:value,prefix:prefix}};
                       DOMElement.prototype.getAttributeNS
                       =
                       function(namespace,name)
                        {var
                          attributes=this._attributes[namespace],
                          value=
                           attributes
                           &&
                           attributes[name]
                           &&
                           attributes[name].value;
                         if(typeof value !== "string")return null;
                         return value};
                       DOMElement.prototype.removeAttributeNS
                       =
                       function(namespace,name)
                        {var attributes=this._attributes[namespace];
                         if(attributes)delete attributes[name]};
                       DOMElement.prototype.hasAttributeNS
                       =
                       function(namespace,name)
                        {var attributes=this._attributes[namespace];
                         return ! ! attributes && name in attributes};
                       DOMElement.prototype.setAttribute
                       =
                       function(name,value)
                        {return this.setAttributeNS(null,name,value)};
                       DOMElement.prototype.getAttribute
                       =
                       function(name){return this.getAttributeNS(null,name)};
                       DOMElement.prototype.removeAttribute
                       =
                       function(name){return this.removeAttributeNS(null,name)};
                       DOMElement.prototype.hasAttribute
                       =
                       function(name){return this.hasAttributeNS(null,name)};
                       DOMElement.prototype.removeEventListener
                       =
                       removeEventListener;
                       DOMElement.prototype.addEventListener = addEventListener;
                       DOMElement.prototype.dispatchEvent = dispatchEvent;
                       DOMElement.prototype.focus = function(){return void 0};
                       DOMElement.prototype.toString
                       =
                       function(){return serializeNode(this)};
                       DOMElement.prototype.getElementsByClassName
                       =
                       function(classNames)
                        {var classes=classNames.split(" "),elems=[];
                         domWalk
                          (this,
                           function(node)
                            {if(node.nodeType === 1)
                              {var
                                nodeClassName=node.className || "",
                                nodeClasses=nodeClassName.split(" ");
                               if
                                (classes.every
                                  (function(item){return nodeClasses.indexOf(item) !== - 1}))
                                elems.push(node)}});
                         return elems};
                       DOMElement.prototype.getElementsByTagName
                       =
                       function(tagName)
                        {tagName = tagName.toLowerCase();
                         var elems=[];
                         domWalk
                          (this.childNodes,
                           function(node)
                            {if
                              (node.nodeType
                               ===
                               1
                               &&
                               (tagName === "*" || node.tagName.toLowerCase() === tagName))
                              elems.push(node)});
                         return elems};
                       DOMElement.prototype.contains
                       =
                       function(element)
                        {return domWalk
                                 (this,function(node){return element === node})
                                ||
                                false}},
                     {"./event/add-event-listener.js":14,
                      "./event/dispatch-event.js":15,
                      "./event/remove-event-listener.js":16,
                      "./serialize.js":19,
                      "dom-walk":18}],
                    11:
                    [function(require,module,exports)
                      {var DOMElement=require("./dom-element.js");
                       module.exports = DocumentFragment;
                       function DocumentFragment(owner)
                        {if(! (this instanceof DocumentFragment))
                          return new DocumentFragment();
                         this.childNodes = [];
                         this.parentNode = null;
                         this.ownerDocument = owner || null}
                       DocumentFragment.prototype.type = "DocumentFragment";
                       DocumentFragment.prototype.nodeType = 11;
                       DocumentFragment.prototype.nodeName = "#document-fragment";
                       DocumentFragment.prototype.appendChild
                       =
                       DOMElement.prototype.appendChild;
                       DocumentFragment.prototype.replaceChild
                       =
                       DOMElement.prototype.replaceChild;
                       DocumentFragment.prototype.removeChild
                       =
                       DOMElement.prototype.removeChild;
                       DocumentFragment.prototype.toString
                       =
                       function()
                        {return this.childNodes.map
                                  (function(node){return String(node)}).join
                                 ("")}},
                     {"./dom-element.js":10}],
                    12:
                    [function(require,module,exports)
                      {module.exports = DOMText;
                       function DOMText(value,owner)
                        {if(! (this instanceof DOMText))return new DOMText(value);
                         this.data = value || "";
                         this.length = this.data.length;
                         this.ownerDocument = owner || null}
                       DOMText.prototype.type = "DOMTextNode";
                       DOMText.prototype.nodeType = 3;
                       DOMText.prototype.nodeName = "#text";
                       DOMText.prototype.toString = function(){return this.data};
                       DOMText.prototype.replaceData
                       =
                       function(index,length,value)
                        {var
                          current=this.data,
                          left=current.substring(0,index),
                          right=current.substring(index + length,current.length);
                         this.data = left + value + right;
                         this.length = this.data.length}},
                     {}],
                    13:
                    [function(require,module,exports)
                      {module.exports = Event;
                       function Event(family){}
                       Event.prototype.initEvent
                       =
                       function(type,bubbles,cancelable)
                        {this.type = type;
                         this.bubbles = bubbles;
                         this.cancelable = cancelable};
                       Event.prototype.preventDefault = function(){}},
                     {}],
                    14:
                    [function(require,module,exports)
                      {module.exports = addEventListener;
                       function addEventListener(type,listener)
                        {var elem=this;
                         if(! elem.listeners)elem.listeners = {};
                         if(! elem.listeners[type])elem.listeners[type] = [];
                         if(elem.listeners[type].indexOf(listener) === - 1)
                          elem.listeners[type].push(listener)}},
                     {}],
                    15:
                    [function(require,module,exports)
                      {module.exports = dispatchEvent;
                       function dispatchEvent(ev)
                        {var elem=this,type=ev.type;
                         if(! ev.target)ev.target = elem;
                         if(! elem.listeners)elem.listeners = {};
                         var listeners=elem.listeners[type];
                         if(listeners)
                          return listeners.forEach
                                  (function(listener)
                                    {ev.currentTarget = elem;
                                     if(typeof listener === "function")
                                      listener(ev);
                                     else
                                      listener.handleEvent(ev)});
                         if(elem.parentNode)elem.parentNode.dispatchEvent(ev)}},
                     {}],
                    16:
                    [function(require,module,exports)
                      {module.exports = removeEventListener;
                       function removeEventListener(type,listener)
                        {var elem=this;
                         if(! elem.listeners)return;
                         if(! elem.listeners[type])return;
                         var list=elem.listeners[type],index=list.indexOf(listener);
                         if(index !== - 1)list.splice(index,1)}},
                     {}],
                    17:
                    [function(require,module,exports)
                      {var Document=require("./document.js");
                       module.exports = new Document()},
                     {"./document.js":8}],
                    18:
                    [function(require,module,exports)
                      {var slice=Array.prototype.slice;
                       module.exports = iterativelyWalk;
                       function iterativelyWalk(nodes,cb)
                        {if(! ("length" in nodes))nodes = [nodes];
                         nodes = slice.call(nodes);
                         while(nodes.length)
                          {var node=nodes.shift(),ret=cb(node);
                           if(ret)return ret;
                           if(node.childNodes && node.childNodes.length)
                            nodes = slice.call(node.childNodes).concat(nodes)}}},
                     {}],
                    19:
                    [function(require,module,exports)
                      {module.exports = serializeNode;
                       var
                        voidElements=
                         /area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr/i;
                       function serializeNode(node)
                        {switch(node.nodeType)
                          {case 3:return escapeText(node.data);
                           case 8:return "<!--" + node.data + "-->";
                           default:return serializeElement(node)}}
                       function serializeElement(elem)
                        {var strings=[],tagname=elem.tagName;
                         if(elem.namespaceURI === "http://www.w3.org/1999/xhtml")
                          tagname = tagname.toLowerCase();
                         strings.push
                          ("<" + tagname + properties(elem) + datasetify(elem));
                         if(voidElements.test(tagname))
                          strings.push(" />");
                         else
                          {strings.push(">");
                           if(elem.childNodes.length)
                            strings.push.apply
                             (strings,elem.childNodes.map(serializeNode));
                           else
                            if(elem.textContent || elem.innerText)
                             strings.push(escapeText(elem.textContent || elem.innerText));
                            else
                             if(elem.innerHTML)strings.push(elem.innerHTML);
                           strings.push("<\/" + tagname + ">")}
                         return strings.join("")}
                       function isProperty(elem,key)
                        {var type=typeof elem[key];
                         if(key === "style" && Object.keys(elem.style).length > 0)
                          return true;
                         return elem.hasOwnProperty(key)
                                &&
                                (type
                                 ===
                                 "string"
                                 ||
                                 type
                                 ===
                                 "boolean"
                                 ||
                                 type
                                 ===
                                 "number")
                                &&
                                key
                                !==
                                "nodeName"
                                &&
                                key
                                !==
                                "className"
                                &&
                                key
                                !==
                                "tagName"
                                &&
                                key
                                !==
                                "textContent"
                                &&
                                key
                                !==
                                "innerText"
                                &&
                                key
                                !==
                                "namespaceURI"
                                &&
                                key
                                !==
                                "innerHTML"}
                       function stylify(styles)
                        {if(typeof styles === "string")return styles;
                         var attr="";
                         Object.keys(styles).forEach
                          (function(key)
                            {var value=styles[key];
                             key
                             =
                             key.replace
                              (/[A-Z]/g,function(c){return "-" + c.toLowerCase()});
                             attr += key + ":" + value + ";"});
                         return attr}
                       function datasetify(elem)
                        {var ds=elem.dataset,props=[];
                         for(var key in ds)
                          props.push({name:"data-" + key,value:ds[key]});
                         return props.length?stringify(props):""}
                       function stringify(list)
                        {var attributes=[];
                         list.forEach
                          (function(tuple)
                            {var name=tuple.name,value=tuple.value;
                             if(name === "style")value = stylify(value);
                             attributes.push
                              (name + "=" + '"' + escapeAttributeValue(value) + '"')});
                         return attributes.length?" " + attributes.join(" "):""}
                       function properties(elem)
                        {var props=[];
                         for(var key in elem)
                          if(isProperty(elem,key))
                           props.push({name:key,value:elem[key]});
                         for(var ns in elem._attributes)
                          for(var attribute in elem._attributes[ns])
                           {var
                             prop=elem._attributes[ns][attribute],
                             name=(prop.prefix?prop.prefix + ":":"") + attribute;
                            props.push({name:name,value:prop.value})}
                         if(elem.className)
                          props.push({name:"class",value:elem.className});
                         return props.length?stringify(props):""}
                       function escapeText(s)
                        {var str="";
                         if(typeof s === "string")
                          str = s;
                         else
                          if(s)str = s.toString();
                         return str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace
                                 (/>/g,"&gt;")}
                       function escapeAttributeValue(str)
                        {return escapeText(str).replace(/"/g,"&quot;")}},
                     {}],
                    20:
                    [function(require,module,exports)
                      {"use strict";
                       module.exports
                       =
                       function(x){return typeof x === "object" && x !== null}},
                     {}],
                    21:
                    [function(require,module,exports)
                      {var
                        nativeIsArray=Array.isArray,
                        toString=Object.prototype.toString;
                       module.exports = nativeIsArray || isArray;
                       function isArray(obj)
                        {return toString.call(obj) === "[object Array]"}},
                     {}],
                    22:
                    [function(require,module,exports)
                      {var patch=require("./vdom/patch.js");
                       module.exports = patch},
                     {"./vdom/patch.js":27}],
                    23:
                    [function(require,module,exports)
                      {var
                        isObject=require("is-object"),
                        isHook=require("../vnode/is-vhook.js");
                       module.exports = applyProperties;
                       function applyProperties(node,props,previous)
                        {for(var propName in props)
                          {var propValue=props[propName];
                           if(propValue === undefined)
                            removeProperty(node,propName,propValue,previous);
                           else
                            if(isHook(propValue))
                             {removeProperty(node,propName,propValue,previous);
                              if(propValue.hook)
                               propValue.hook
                                (node,propName,previous?previous[propName]:undefined)}
                            else
                             if(isObject(propValue))
                              patchObject(node,props,previous,propName,propValue);
                             else
                              node[propName] = propValue}}
                       function removeProperty(node,propName,propValue,previous)
                        {if(previous)
                          {var previousValue=previous[propName];
                           if(! isHook(previousValue))
                            if(propName === "attributes")
                             for(var attrName in previousValue)
                              node.removeAttribute(attrName);
                            else
                             if(propName === "style")
                              for(var i in previousValue)node.style[i] = "";
                             else
                              if(typeof previousValue === "string")
                               node[propName] = "";
                              else
                               node[propName] = null;
                           else
                            if(previousValue.unhook)
                             previousValue.unhook(node,propName,propValue)}}
                       function patchObject(node,props,previous,propName,propValue)
                        {var previousValue=previous?previous[propName]:undefined;
                         if(propName === "attributes")
                          {for(var attrName in propValue)
                            {var attrValue=propValue[attrName];
                             if(attrValue === undefined)
                              node.removeAttribute(attrName);
                             else
                              node.setAttribute(attrName,attrValue)}
                           return}
                         if
                          (previousValue
                           &&
                           isObject(previousValue)
                           &&
                           getPrototype(previousValue)
                           !==
                           getPrototype(propValue))
                          {node[propName] = propValue;return}
                         if(! isObject(node[propName]))node[propName] = {};
                         var replacer=propName === "style"?"":undefined;
                         for(var k in propValue)
                          {var value=propValue[k];
                           node[propName][k] = value === undefined?replacer:value}}
                       function getPrototype(value)
                        {if(Object.getPrototypeOf)
                          return Object.getPrototypeOf(value);
                         else
                          if(value.__proto__)
                           return value.__proto__;
                          else
                           if(value.constructor)return value.constructor.prototype}},
                     {"../vnode/is-vhook.js":38,"is-object":20}],
                    24:
                    [function(require,module,exports)
                      {var
                        document=require("global/document"),
                        applyProperties=require("./apply-properties"),
                        isVNode=require("../vnode/is-vnode.js"),
                        isVText=require("../vnode/is-vtext.js"),
                        isWidget=require("../vnode/is-widget.js"),
                        handleThunk=require("../vnode/handle-thunk.js");
                       module.exports = createElement;
                       function createElement(vnode,opts)
                        {var
                          doc=opts?opts.document || document:document,
                          warn=opts?opts.warn:null;
                         vnode = handleThunk(vnode).a;
                         if(isWidget(vnode))
                          return vnode.init();
                         else
                          if(isVText(vnode))
                           return doc.createTextNode(vnode.text);
                          else
                           if(! isVNode(vnode))
                            {if(warn)warn("Item is not a valid virtual dom node",vnode);
                             return null}
                         var
                          node=
                           vnode.namespace === null
                            ?doc.createElement(vnode.tagName)
                            :doc.createElementNS(vnode.namespace,vnode.tagName),
                          props=vnode.properties;
                         applyProperties(node,props);
                         var children=vnode.children;
                         for(var i=0;i < children.length;i++)
                          {var childNode=createElement(children[i],opts);
                           if(childNode)node.appendChild(childNode)}
                         return node}},
                     {"../vnode/handle-thunk.js":36,
                      "../vnode/is-vnode.js":39,
                      "../vnode/is-vtext.js":40,
                      "../vnode/is-widget.js":41,
                      "./apply-properties":23,
                      "global/document":7}],
                    25:
                    [function(require,module,exports)
                      {var noChild={};
                       module.exports = domIndex;
                       function domIndex(rootNode,tree,indices,nodes)
                        {if(! indices || indices.length === 0)
                          return {};
                         else
                          {indices.sort(ascending);
                           return recurse(rootNode,tree,indices,nodes,0)}}
                       function recurse(rootNode,tree,indices,nodes,rootIndex)
                        {nodes = nodes || {};
                         if(rootNode)
                          {if(indexInRange(indices,rootIndex,rootIndex))
                            nodes[rootIndex] = rootNode;
                           var vChildren=tree.children;
                           if(vChildren)
                            {var childNodes=rootNode.childNodes;
                             for(var i=0;i < tree.children.length;i++)
                              {rootIndex += 1;
                               var
                                vChild=vChildren[i] || noChild,
                                nextIndex=rootIndex + (vChild.count || 0);
                               if(indexInRange(indices,rootIndex,nextIndex))
                                recurse(childNodes[i],vChild,indices,nodes,rootIndex);
                               rootIndex = nextIndex}}}
                         return nodes}
                       function indexInRange(indices,left,right)
                        {if(indices.length === 0)return false;
                         var
                          minIndex=0,
                          maxIndex=indices.length - 1,
                          currentIndex,
                          currentItem;
                         while(minIndex <= maxIndex)
                          {currentIndex = (maxIndex + minIndex) / 2 >> 0;
                           currentItem = indices[currentIndex];
                           if(minIndex === maxIndex)
                            return currentItem >= left && currentItem <= right;
                           else
                            if(currentItem < left)
                             minIndex = currentIndex + 1;
                            else
                             if(currentItem > right)
                              maxIndex = currentIndex - 1;
                             else
                              return true}
                         return false}
                       function ascending(a,b){return a > b?1:- 1}},
                     {}],
                    26:
                    [function(require,module,exports)
                      {var
                        applyProperties=require("./apply-properties"),
                        isWidget=require("../vnode/is-widget.js"),
                        VPatch=require("../vnode/vpatch.js"),
                        updateWidget=require("./update-widget");
                       module.exports = applyPatch;
                       function applyPatch(vpatch,domNode,renderOptions)
                        {var type=vpatch.type,vNode=vpatch.vNode,patch=vpatch.patch;
                         switch(type)
                          {case VPatch.REMOVE:return removeNode(domNode,vNode);
                           case VPatch.INSERT:
                            return insertNode(domNode,patch,renderOptions);
                           case VPatch.VTEXT:
                            return stringPatch(domNode,vNode,patch,renderOptions);
                           case VPatch.WIDGET:
                            return widgetPatch(domNode,vNode,patch,renderOptions);
                           case VPatch.VNODE:
                            return vNodePatch(domNode,vNode,patch,renderOptions);
                           case VPatch.ORDER:
                            reorderChildren(domNode,patch);return domNode;
                           case VPatch.PROPS:
                            applyProperties(domNode,patch,vNode.properties);
                            return domNode;
                           case VPatch.THUNK:
                            return replaceRoot
                                    (domNode,renderOptions.patch(domNode,patch,renderOptions));
                           default:return domNode}}
                       function removeNode(domNode,vNode)
                        {var parentNode=domNode.parentNode;
                         if(parentNode)parentNode.removeChild(domNode);
                         destroyWidget(domNode,vNode);
                         return null}
                       function insertNode(parentNode,vNode,renderOptions)
                        {var newNode=renderOptions.render(vNode,renderOptions);
                         if(parentNode)parentNode.appendChild(newNode);
                         return parentNode}
                       function stringPatch(domNode,leftVNode,vText,renderOptions)
                        {var newNode;
                         if(domNode.nodeType === 3)
                          {domNode.replaceData(0,domNode.length,vText.text);
                           newNode = domNode}
                         else
                          {var parentNode=domNode.parentNode;
                           newNode = renderOptions.render(vText,renderOptions);
                           if(parentNode && newNode !== domNode)
                            parentNode.replaceChild(newNode,domNode)}
                         return newNode}
                       function widgetPatch(domNode,leftVNode,widget,renderOptions)
                        {var updating=updateWidget(leftVNode,widget),newNode;
                         if(updating)
                          newNode = widget.update(leftVNode,domNode) || domNode;
                         else
                          newNode = renderOptions.render(widget,renderOptions);
                         var parentNode=domNode.parentNode;
                         if(parentNode && newNode !== domNode)
                          parentNode.replaceChild(newNode,domNode);
                         if(! updating)destroyWidget(domNode,leftVNode);
                         return newNode}
                       function vNodePatch(domNode,leftVNode,vNode,renderOptions)
                        {var
                          parentNode=domNode.parentNode,
                          newNode=renderOptions.render(vNode,renderOptions);
                         if(parentNode && newNode !== domNode)
                          parentNode.replaceChild(newNode,domNode);
                         return newNode}
                       function destroyWidget(domNode,w)
                        {if(typeof w.destroy === "function" && isWidget(w))
                          w.destroy(domNode)}
                       function reorderChildren(domNode,moves)
                        {var
                          childNodes=domNode.childNodes,
                          keyMap={},
                          node,
                          remove,
                          insert;
                         for(var i=0;i < moves.removes.length;i++)
                          {remove = moves.removes[i];
                           node = childNodes[remove.from];
                           if(remove.key)keyMap[remove.key] = node;
                           domNode.removeChild(node)}
                         var length=childNodes.length;
                         for(var j=0;j < moves.inserts.length;j++)
                          {insert = moves.inserts[j];
                           node = keyMap[insert.key];
                           domNode.insertBefore
                            (node,insert.to >= length++?null:childNodes[insert.to])}}
                       function replaceRoot(oldRoot,newRoot)
                        {if
                          (oldRoot
                           &&
                           newRoot
                           &&
                           oldRoot
                           !==
                           newRoot
                           &&
                           oldRoot.parentNode)
                          oldRoot.parentNode.replaceChild(newRoot,oldRoot);
                         return newRoot}},
                     {"../vnode/is-widget.js":41,
                      "../vnode/vpatch.js":44,
                      "./apply-properties":23,
                      "./update-widget":28}],
                    27:
                    [function(require,module,exports)
                      {var
                        document=require("global/document"),
                        isArray=require("x-is-array"),
                        render=require("./create-element"),
                        domIndex=require("./dom-index"),
                        patchOp=require("./patch-op");
                       module.exports = patch;
                       function patch(rootNode,patches,renderOptions)
                        {renderOptions = renderOptions || {};
                         renderOptions.patch
                         =
                         renderOptions.patch && renderOptions.patch !== patch
                          ?renderOptions.patch
                          :patchRecursive;
                         renderOptions.render = renderOptions.render || render;
                         return renderOptions.patch(rootNode,patches,renderOptions)}
                       function patchRecursive(rootNode,patches,renderOptions)
                        {var indices=patchIndices(patches);
                         if(indices.length === 0)return rootNode;
                         var
                          index=domIndex(rootNode,patches.a,indices),
                          ownerDocument=rootNode.ownerDocument;
                         if(! renderOptions.document && ownerDocument !== document)
                          renderOptions.document = ownerDocument;
                         for(var i=0;i < indices.length;i++)
                          {var nodeIndex=indices[i];
                           rootNode
                           =
                           applyPatch
                            (rootNode,index[nodeIndex],patches[nodeIndex],renderOptions)}
                         return rootNode}
                       function applyPatch
                        (rootNode,domNode,patchList,renderOptions)
                        {if(! domNode)return rootNode;
                         var newNode;
                         if(isArray(patchList))
                          for(var i=0;i < patchList.length;i++)
                           {newNode = patchOp(patchList[i],domNode,renderOptions);
                            if(domNode === rootNode)rootNode = newNode}
                         else
                          {newNode = patchOp(patchList,domNode,renderOptions);
                           if(domNode === rootNode)rootNode = newNode}
                         return rootNode}
                       function patchIndices(patches)
                        {var indices=[];
                         for(var key in patches)
                          if(key !== "a")indices.push(Number(key));
                         return indices}},
                     {"./create-element":24,
                      "./dom-index":25,
                      "./patch-op":26,
                      "global/document":7,
                      "x-is-array":21}],
                    28:
                    [function(require,module,exports)
                      {var isWidget=require("../vnode/is-widget.js");
                       module.exports = updateWidget;
                       function updateWidget(a,b)
                        {if(isWidget(a) && isWidget(b))
                          return "name" in a && "name" in b
                                  ?a.id === b.id
                                  :a.init === b.init;
                         return false}},
                     {"../vnode/is-widget.js":41}],
                    29:
                    [function(require,module,exports)
                      {"use strict";
                       module.exports = AttributeHook;
                       function AttributeHook(namespace,value)
                        {if(! (this instanceof AttributeHook))
                          return new AttributeHook(namespace,value);
                         this.namespace = namespace;
                         this.value = value}
                       AttributeHook.prototype.hook
                       =
                       function(node,prop,prev)
                        {if
                          (prev
                           &&
                           prev.type
                           ===
                           "AttributeHook"
                           &&
                           prev.value
                           ===
                           this.value
                           &&
                           prev.namespace
                           ===
                           this.namespace)
                          return;
                         node.setAttributeNS(this.namespace,prop,this.value)};
                       AttributeHook.prototype.unhook
                       =
                       function(node,prop,next)
                        {if
                          (next
                           &&
                           next.type
                           ===
                           "AttributeHook"
                           &&
                           next.namespace
                           ===
                           this.namespace)
                          return;
                         var
                          colonPosition=prop.indexOf(":"),
                          localName=
                           colonPosition > - 1?prop.substr(colonPosition + 1):prop;
                         node.removeAttributeNS(this.namespace,localName)};
                       AttributeHook.prototype.type = "AttributeHook"},
                     {}],
                    30:
                    [function(require,module,exports)
                      {"use strict";
                       var EvStore=require("ev-store");
                       module.exports = EvHook;
                       function EvHook(value)
                        {if(! (this instanceof EvHook))return new EvHook(value);
                         this.value = value}
                       EvHook.prototype.hook
                       =
                       function(node,propertyName)
                        {var es=EvStore(node),propName=propertyName.substr(3);
                         es[propName] = this.value};
                       EvHook.prototype.unhook
                       =
                       function(node,propertyName)
                        {var es=EvStore(node),propName=propertyName.substr(3);
                         es[propName] = undefined}},
                     {"ev-store":4}],
                    31:
                    [function(require,module,exports)
                      {"use strict";
                       module.exports = SoftSetHook;
                       function SoftSetHook(value)
                        {if(! (this instanceof SoftSetHook))
                          return new SoftSetHook(value);
                         this.value = value}
                       SoftSetHook.prototype.hook
                       =
                       function(node,propertyName)
                        {if(node[propertyName] !== this.value)
                          node[propertyName] = this.value}},
                     {}],
                    32:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        isArray=require("x-is-array"),
                        VNode=require("../vnode/vnode.js"),
                        VText=require("../vnode/vtext.js"),
                        isVNode=require("../vnode/is-vnode"),
                        isVText=require("../vnode/is-vtext"),
                        isWidget=require("../vnode/is-widget"),
                        isHook=require("../vnode/is-vhook"),
                        isVThunk=require("../vnode/is-thunk"),
                        parseTag=require("./parse-tag.js"),
                        softSetHook=require("./hooks/soft-set-hook.js"),
                        evHook=require("./hooks/ev-hook.js");
                       module.exports = h;
                       function h(tagName,properties,children)
                        {var childNodes=[],tag,props,key,namespace;
                         if(! children && isChildren(properties))
                          {children = properties;props = {}}
                         props = props || properties || {};
                         tag = parseTag(tagName,props);
                         if(props.hasOwnProperty("key"))
                          {key = props.key;props.key = undefined}
                         if(props.hasOwnProperty("namespace"))
                          {namespace = props.namespace;props.namespace = undefined}
                         if
                          (tag
                           ===
                           "INPUT"
                           &&
                           !
                           namespace
                           &&
                           props.hasOwnProperty("value")
                           &&
                           props.value
                           !==
                           undefined
                           &&
                           !
                           isHook(props.value))
                          props.value = softSetHook(props.value);
                         transformProperties(props);
                         if(children !== undefined && children !== null)
                          addChild(children,childNodes,tag,props);
                         return new VNode(tag,props,childNodes,key,namespace)}
                       function addChild(c,childNodes,tag,props)
                        {if(typeof c === "string")
                          childNodes.push(new VText(c));
                         else
                          if(typeof c === "number")
                           childNodes.push(new VText(String(c)));
                          else
                           if(isChild(c))
                            childNodes.push(c);
                           else
                            if(isArray(c))
                             for(var i=0;i < c.length;i++)
                              addChild(c[i],childNodes,tag,props);
                            else
                             if(c === null || c === undefined)
                              return;
                             else
                              throw UnexpectedVirtualElement
                                     ({foreignObject:c,
                                       parentVnode:{tagName:tag,properties:props}})}
                       function transformProperties(props)
                        {for(var propName in props)
                          if(props.hasOwnProperty(propName))
                           {var value=props[propName];
                            if(isHook(value))continue;
                            if(propName.substr(0,3) === "ev-")
                             props[propName] = evHook(value)}}
                       function isChild(x)
                        {return isVNode(x)
                                ||
                                isVText(x)
                                ||
                                isWidget(x)
                                ||
                                isVThunk(x)}
                       function isChildren(x)
                        {return typeof x === "string" || isArray(x) || isChild(x)}
                       function UnexpectedVirtualElement(data)
                        {var err=new Error();
                         err.type = "virtual-hyperscript.unexpected.virtual-element";
                         err.message
                         =
                         "Unexpected virtual child passed to h().\n"
                         +
                         "Expected a VNode / Vthunk / VWidget / string but:\n"
                         +
                         "got:\n"
                         +
                         errorString(data.foreignObject)
                         +
                         ".\n"
                         +
                         "The parent vnode is:\n"
                         +
                         errorString(data.parentVnode);
                         "\n"
                         +
                         "Suggested fix: change your `h(..., [ ... ])` callsite.";
                         err.foreignObject = data.foreignObject;
                         err.parentVnode = data.parentVnode;
                         return err}
                       function errorString(obj)
                        {try
                          {return JSON.stringify(obj,null,"    ")}
                         catch(e){return String(obj)}}},
                     {"../vnode/is-thunk":37,
                      "../vnode/is-vhook":38,
                      "../vnode/is-vnode":39,
                      "../vnode/is-vtext":40,
                      "../vnode/is-widget":41,
                      "../vnode/vnode.js":43,
                      "../vnode/vtext.js":45,
                      "./hooks/ev-hook.js":30,
                      "./hooks/soft-set-hook.js":31,
                      "./parse-tag.js":33,
                      "x-is-array":21}],
                    33:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        split=require("browser-split"),
                        classIdSplit=/([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/,
                        notClassId=/^\.|#/;
                       module.exports = parseTag;
                       function parseTag(tag,props)
                        {if(! tag)return "DIV";
                         var
                          noId=! props.hasOwnProperty("id"),
                          tagParts=split(tag,classIdSplit),
                          tagName=null;
                         if(notClassId.test(tagParts[1]))tagName = "DIV";
                         var classes,part,type,i;
                         for(i = 0;i < tagParts.length;i++)
                          {part = tagParts[i];
                           if(! part)continue;
                           type = part.charAt(0);
                           if(! tagName)
                            tagName = part;
                           else
                            if(type === ".")
                             {classes = classes || [];
                              classes.push(part.substring(1,part.length))}
                            else
                             if(type === "#" && noId)
                              props.id = part.substring(1,part.length)}
                         if(classes)
                          {if(props.className)classes.push(props.className);
                           props.className = classes.join(" ")}
                         return props.namespace?tagName:tagName.toUpperCase()}},
                     {"browser-split":3}],
                    34:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        DEFAULT_NAMESPACE=null,
                        EV_NAMESPACE="http://www.w3.org/2001/xml-events",
                        XLINK_NAMESPACE="http://www.w3.org/1999/xlink",
                        XML_NAMESPACE="http://www.w3.org/XML/1998/namespace",
                        SVG_PROPERTIES=
                         {"about":DEFAULT_NAMESPACE,
                          "accent-height":DEFAULT_NAMESPACE,
                          "accumulate":DEFAULT_NAMESPACE,
                          "additive":DEFAULT_NAMESPACE,
                          "alignment-baseline":DEFAULT_NAMESPACE,
                          "alphabetic":DEFAULT_NAMESPACE,
                          "amplitude":DEFAULT_NAMESPACE,
                          "arabic-form":DEFAULT_NAMESPACE,
                          "ascent":DEFAULT_NAMESPACE,
                          "attributeName":DEFAULT_NAMESPACE,
                          "attributeType":DEFAULT_NAMESPACE,
                          "azimuth":DEFAULT_NAMESPACE,
                          "bandwidth":DEFAULT_NAMESPACE,
                          "baseFrequency":DEFAULT_NAMESPACE,
                          "baseProfile":DEFAULT_NAMESPACE,
                          "baseline-shift":DEFAULT_NAMESPACE,
                          "bbox":DEFAULT_NAMESPACE,
                          "begin":DEFAULT_NAMESPACE,
                          "bias":DEFAULT_NAMESPACE,
                          "by":DEFAULT_NAMESPACE,
                          "calcMode":DEFAULT_NAMESPACE,
                          "cap-height":DEFAULT_NAMESPACE,
                          "class":DEFAULT_NAMESPACE,
                          "clip":DEFAULT_NAMESPACE,
                          "clip-path":DEFAULT_NAMESPACE,
                          "clip-rule":DEFAULT_NAMESPACE,
                          "clipPathUnits":DEFAULT_NAMESPACE,
                          "color":DEFAULT_NAMESPACE,
                          "color-interpolation":DEFAULT_NAMESPACE,
                          "color-interpolation-filters":DEFAULT_NAMESPACE,
                          "color-profile":DEFAULT_NAMESPACE,
                          "color-rendering":DEFAULT_NAMESPACE,
                          "content":DEFAULT_NAMESPACE,
                          "contentScriptType":DEFAULT_NAMESPACE,
                          "contentStyleType":DEFAULT_NAMESPACE,
                          "cursor":DEFAULT_NAMESPACE,
                          "cx":DEFAULT_NAMESPACE,
                          "cy":DEFAULT_NAMESPACE,
                          "d":DEFAULT_NAMESPACE,
                          "datatype":DEFAULT_NAMESPACE,
                          "defaultAction":DEFAULT_NAMESPACE,
                          "descent":DEFAULT_NAMESPACE,
                          "diffuseConstant":DEFAULT_NAMESPACE,
                          "direction":DEFAULT_NAMESPACE,
                          "display":DEFAULT_NAMESPACE,
                          "divisor":DEFAULT_NAMESPACE,
                          "dominant-baseline":DEFAULT_NAMESPACE,
                          "dur":DEFAULT_NAMESPACE,
                          "dx":DEFAULT_NAMESPACE,
                          "dy":DEFAULT_NAMESPACE,
                          "edgeMode":DEFAULT_NAMESPACE,
                          "editable":DEFAULT_NAMESPACE,
                          "elevation":DEFAULT_NAMESPACE,
                          "enable-background":DEFAULT_NAMESPACE,
                          "end":DEFAULT_NAMESPACE,
                          "ev:event":EV_NAMESPACE,
                          "event":DEFAULT_NAMESPACE,
                          "exponent":DEFAULT_NAMESPACE,
                          "externalResourcesRequired":DEFAULT_NAMESPACE,
                          "fill":DEFAULT_NAMESPACE,
                          "fill-opacity":DEFAULT_NAMESPACE,
                          "fill-rule":DEFAULT_NAMESPACE,
                          "filter":DEFAULT_NAMESPACE,
                          "filterRes":DEFAULT_NAMESPACE,
                          "filterUnits":DEFAULT_NAMESPACE,
                          "flood-color":DEFAULT_NAMESPACE,
                          "flood-opacity":DEFAULT_NAMESPACE,
                          "focusHighlight":DEFAULT_NAMESPACE,
                          "focusable":DEFAULT_NAMESPACE,
                          "font-family":DEFAULT_NAMESPACE,
                          "font-size":DEFAULT_NAMESPACE,
                          "font-size-adjust":DEFAULT_NAMESPACE,
                          "font-stretch":DEFAULT_NAMESPACE,
                          "font-style":DEFAULT_NAMESPACE,
                          "font-variant":DEFAULT_NAMESPACE,
                          "font-weight":DEFAULT_NAMESPACE,
                          "format":DEFAULT_NAMESPACE,
                          "from":DEFAULT_NAMESPACE,
                          "fx":DEFAULT_NAMESPACE,
                          "fy":DEFAULT_NAMESPACE,
                          "g1":DEFAULT_NAMESPACE,
                          "g2":DEFAULT_NAMESPACE,
                          "glyph-name":DEFAULT_NAMESPACE,
                          "glyph-orientation-horizontal":DEFAULT_NAMESPACE,
                          "glyph-orientation-vertical":DEFAULT_NAMESPACE,
                          "glyphRef":DEFAULT_NAMESPACE,
                          "gradientTransform":DEFAULT_NAMESPACE,
                          "gradientUnits":DEFAULT_NAMESPACE,
                          "handler":DEFAULT_NAMESPACE,
                          "hanging":DEFAULT_NAMESPACE,
                          "height":DEFAULT_NAMESPACE,
                          "horiz-adv-x":DEFAULT_NAMESPACE,
                          "horiz-origin-x":DEFAULT_NAMESPACE,
                          "horiz-origin-y":DEFAULT_NAMESPACE,
                          "id":DEFAULT_NAMESPACE,
                          "ideographic":DEFAULT_NAMESPACE,
                          "image-rendering":DEFAULT_NAMESPACE,
                          "in":DEFAULT_NAMESPACE,
                          "in2":DEFAULT_NAMESPACE,
                          "initialVisibility":DEFAULT_NAMESPACE,
                          "intercept":DEFAULT_NAMESPACE,
                          "k":DEFAULT_NAMESPACE,
                          "k1":DEFAULT_NAMESPACE,
                          "k2":DEFAULT_NAMESPACE,
                          "k3":DEFAULT_NAMESPACE,
                          "k4":DEFAULT_NAMESPACE,
                          "kernelMatrix":DEFAULT_NAMESPACE,
                          "kernelUnitLength":DEFAULT_NAMESPACE,
                          "kerning":DEFAULT_NAMESPACE,
                          "keyPoints":DEFAULT_NAMESPACE,
                          "keySplines":DEFAULT_NAMESPACE,
                          "keyTimes":DEFAULT_NAMESPACE,
                          "lang":DEFAULT_NAMESPACE,
                          "lengthAdjust":DEFAULT_NAMESPACE,
                          "letter-spacing":DEFAULT_NAMESPACE,
                          "lighting-color":DEFAULT_NAMESPACE,
                          "limitingConeAngle":DEFAULT_NAMESPACE,
                          "local":DEFAULT_NAMESPACE,
                          "marker-end":DEFAULT_NAMESPACE,
                          "marker-mid":DEFAULT_NAMESPACE,
                          "marker-start":DEFAULT_NAMESPACE,
                          "markerHeight":DEFAULT_NAMESPACE,
                          "markerUnits":DEFAULT_NAMESPACE,
                          "markerWidth":DEFAULT_NAMESPACE,
                          "mask":DEFAULT_NAMESPACE,
                          "maskContentUnits":DEFAULT_NAMESPACE,
                          "maskUnits":DEFAULT_NAMESPACE,
                          "mathematical":DEFAULT_NAMESPACE,
                          "max":DEFAULT_NAMESPACE,
                          "media":DEFAULT_NAMESPACE,
                          "mediaCharacterEncoding":DEFAULT_NAMESPACE,
                          "mediaContentEncodings":DEFAULT_NAMESPACE,
                          "mediaSize":DEFAULT_NAMESPACE,
                          "mediaTime":DEFAULT_NAMESPACE,
                          "method":DEFAULT_NAMESPACE,
                          "min":DEFAULT_NAMESPACE,
                          "mode":DEFAULT_NAMESPACE,
                          "name":DEFAULT_NAMESPACE,
                          "nav-down":DEFAULT_NAMESPACE,
                          "nav-down-left":DEFAULT_NAMESPACE,
                          "nav-down-right":DEFAULT_NAMESPACE,
                          "nav-left":DEFAULT_NAMESPACE,
                          "nav-next":DEFAULT_NAMESPACE,
                          "nav-prev":DEFAULT_NAMESPACE,
                          "nav-right":DEFAULT_NAMESPACE,
                          "nav-up":DEFAULT_NAMESPACE,
                          "nav-up-left":DEFAULT_NAMESPACE,
                          "nav-up-right":DEFAULT_NAMESPACE,
                          "numOctaves":DEFAULT_NAMESPACE,
                          "observer":DEFAULT_NAMESPACE,
                          "offset":DEFAULT_NAMESPACE,
                          "opacity":DEFAULT_NAMESPACE,
                          "operator":DEFAULT_NAMESPACE,
                          "order":DEFAULT_NAMESPACE,
                          "orient":DEFAULT_NAMESPACE,
                          "orientation":DEFAULT_NAMESPACE,
                          "origin":DEFAULT_NAMESPACE,
                          "overflow":DEFAULT_NAMESPACE,
                          "overlay":DEFAULT_NAMESPACE,
                          "overline-position":DEFAULT_NAMESPACE,
                          "overline-thickness":DEFAULT_NAMESPACE,
                          "panose-1":DEFAULT_NAMESPACE,
                          "path":DEFAULT_NAMESPACE,
                          "pathLength":DEFAULT_NAMESPACE,
                          "patternContentUnits":DEFAULT_NAMESPACE,
                          "patternTransform":DEFAULT_NAMESPACE,
                          "patternUnits":DEFAULT_NAMESPACE,
                          "phase":DEFAULT_NAMESPACE,
                          "playbackOrder":DEFAULT_NAMESPACE,
                          "pointer-events":DEFAULT_NAMESPACE,
                          "points":DEFAULT_NAMESPACE,
                          "pointsAtX":DEFAULT_NAMESPACE,
                          "pointsAtY":DEFAULT_NAMESPACE,
                          "pointsAtZ":DEFAULT_NAMESPACE,
                          "preserveAlpha":DEFAULT_NAMESPACE,
                          "preserveAspectRatio":DEFAULT_NAMESPACE,
                          "primitiveUnits":DEFAULT_NAMESPACE,
                          "propagate":DEFAULT_NAMESPACE,
                          "property":DEFAULT_NAMESPACE,
                          "r":DEFAULT_NAMESPACE,
                          "radius":DEFAULT_NAMESPACE,
                          "refX":DEFAULT_NAMESPACE,
                          "refY":DEFAULT_NAMESPACE,
                          "rel":DEFAULT_NAMESPACE,
                          "rendering-intent":DEFAULT_NAMESPACE,
                          "repeatCount":DEFAULT_NAMESPACE,
                          "repeatDur":DEFAULT_NAMESPACE,
                          "requiredExtensions":DEFAULT_NAMESPACE,
                          "requiredFeatures":DEFAULT_NAMESPACE,
                          "requiredFonts":DEFAULT_NAMESPACE,
                          "requiredFormats":DEFAULT_NAMESPACE,
                          "resource":DEFAULT_NAMESPACE,
                          "restart":DEFAULT_NAMESPACE,
                          "result":DEFAULT_NAMESPACE,
                          "rev":DEFAULT_NAMESPACE,
                          "role":DEFAULT_NAMESPACE,
                          "rotate":DEFAULT_NAMESPACE,
                          "rx":DEFAULT_NAMESPACE,
                          "ry":DEFAULT_NAMESPACE,
                          "scale":DEFAULT_NAMESPACE,
                          "seed":DEFAULT_NAMESPACE,
                          "shape-rendering":DEFAULT_NAMESPACE,
                          "slope":DEFAULT_NAMESPACE,
                          "snapshotTime":DEFAULT_NAMESPACE,
                          "spacing":DEFAULT_NAMESPACE,
                          "specularConstant":DEFAULT_NAMESPACE,
                          "specularExponent":DEFAULT_NAMESPACE,
                          "spreadMethod":DEFAULT_NAMESPACE,
                          "startOffset":DEFAULT_NAMESPACE,
                          "stdDeviation":DEFAULT_NAMESPACE,
                          "stemh":DEFAULT_NAMESPACE,
                          "stemv":DEFAULT_NAMESPACE,
                          "stitchTiles":DEFAULT_NAMESPACE,
                          "stop-color":DEFAULT_NAMESPACE,
                          "stop-opacity":DEFAULT_NAMESPACE,
                          "strikethrough-position":DEFAULT_NAMESPACE,
                          "strikethrough-thickness":DEFAULT_NAMESPACE,
                          "string":DEFAULT_NAMESPACE,
                          "stroke":DEFAULT_NAMESPACE,
                          "stroke-dasharray":DEFAULT_NAMESPACE,
                          "stroke-dashoffset":DEFAULT_NAMESPACE,
                          "stroke-linecap":DEFAULT_NAMESPACE,
                          "stroke-linejoin":DEFAULT_NAMESPACE,
                          "stroke-miterlimit":DEFAULT_NAMESPACE,
                          "stroke-opacity":DEFAULT_NAMESPACE,
                          "stroke-width":DEFAULT_NAMESPACE,
                          "surfaceScale":DEFAULT_NAMESPACE,
                          "syncBehavior":DEFAULT_NAMESPACE,
                          "syncBehaviorDefault":DEFAULT_NAMESPACE,
                          "syncMaster":DEFAULT_NAMESPACE,
                          "syncTolerance":DEFAULT_NAMESPACE,
                          "syncToleranceDefault":DEFAULT_NAMESPACE,
                          "systemLanguage":DEFAULT_NAMESPACE,
                          "tableValues":DEFAULT_NAMESPACE,
                          "target":DEFAULT_NAMESPACE,
                          "targetX":DEFAULT_NAMESPACE,
                          "targetY":DEFAULT_NAMESPACE,
                          "text-anchor":DEFAULT_NAMESPACE,
                          "text-decoration":DEFAULT_NAMESPACE,
                          "text-rendering":DEFAULT_NAMESPACE,
                          "textLength":DEFAULT_NAMESPACE,
                          "timelineBegin":DEFAULT_NAMESPACE,
                          "title":DEFAULT_NAMESPACE,
                          "to":DEFAULT_NAMESPACE,
                          "transform":DEFAULT_NAMESPACE,
                          "transformBehavior":DEFAULT_NAMESPACE,
                          "type":DEFAULT_NAMESPACE,
                          "typeof":DEFAULT_NAMESPACE,
                          "u1":DEFAULT_NAMESPACE,
                          "u2":DEFAULT_NAMESPACE,
                          "underline-position":DEFAULT_NAMESPACE,
                          "underline-thickness":DEFAULT_NAMESPACE,
                          "unicode":DEFAULT_NAMESPACE,
                          "unicode-bidi":DEFAULT_NAMESPACE,
                          "unicode-range":DEFAULT_NAMESPACE,
                          "units-per-em":DEFAULT_NAMESPACE,
                          "v-alphabetic":DEFAULT_NAMESPACE,
                          "v-hanging":DEFAULT_NAMESPACE,
                          "v-ideographic":DEFAULT_NAMESPACE,
                          "v-mathematical":DEFAULT_NAMESPACE,
                          "values":DEFAULT_NAMESPACE,
                          "version":DEFAULT_NAMESPACE,
                          "vert-adv-y":DEFAULT_NAMESPACE,
                          "vert-origin-x":DEFAULT_NAMESPACE,
                          "vert-origin-y":DEFAULT_NAMESPACE,
                          "viewBox":DEFAULT_NAMESPACE,
                          "viewTarget":DEFAULT_NAMESPACE,
                          "visibility":DEFAULT_NAMESPACE,
                          "width":DEFAULT_NAMESPACE,
                          "widths":DEFAULT_NAMESPACE,
                          "word-spacing":DEFAULT_NAMESPACE,
                          "writing-mode":DEFAULT_NAMESPACE,
                          "x":DEFAULT_NAMESPACE,
                          "x-height":DEFAULT_NAMESPACE,
                          "x1":DEFAULT_NAMESPACE,
                          "x2":DEFAULT_NAMESPACE,
                          "xChannelSelector":DEFAULT_NAMESPACE,
                          "xlink:actuate":XLINK_NAMESPACE,
                          "xlink:arcrole":XLINK_NAMESPACE,
                          "xlink:href":XLINK_NAMESPACE,
                          "xlink:role":XLINK_NAMESPACE,
                          "xlink:show":XLINK_NAMESPACE,
                          "xlink:title":XLINK_NAMESPACE,
                          "xlink:type":XLINK_NAMESPACE,
                          "xml:base":XML_NAMESPACE,
                          "xml:id":XML_NAMESPACE,
                          "xml:lang":XML_NAMESPACE,
                          "xml:space":XML_NAMESPACE,
                          "y":DEFAULT_NAMESPACE,
                          "y1":DEFAULT_NAMESPACE,
                          "y2":DEFAULT_NAMESPACE,
                          "yChannelSelector":DEFAULT_NAMESPACE,
                          "z":DEFAULT_NAMESPACE,
                          "zoomAndPan":DEFAULT_NAMESPACE};
                       module.exports = SVGAttributeNamespace;
                       function SVGAttributeNamespace(value)
                        {if(SVG_PROPERTIES.hasOwnProperty(value))
                          return SVG_PROPERTIES[value]}},
                     {}],
                    35:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        isArray=require("x-is-array"),
                        h=require("./index.js"),
                        SVGAttributeNamespace=require("./svg-attribute-namespace"),
                        attributeHook=require("./hooks/attribute-hook"),
                        SVG_NAMESPACE="http://www.w3.org/2000/svg";
                       module.exports = svg;
                       function svg(tagName,properties,children)
                        {if(! children && isChildren(properties))
                          {children = properties;properties = {}}
                         properties = properties || {};
                         properties.namespace = SVG_NAMESPACE;
                         var
                          attributes=
                           properties.attributes || (properties.attributes = {});
                         for(var key in properties)
                          {if(! properties.hasOwnProperty(key))continue;
                           var namespace=SVGAttributeNamespace(key);
                           if(namespace === undefined)continue;
                           var value=properties[key];
                           if
                            (typeof value
                             !==
                             "string"
                             &&
                             typeof value
                             !==
                             "number"
                             &&
                             typeof value
                             !==
                             "boolean")
                            continue;
                           if(namespace !== null)
                            {properties[key] = attributeHook(namespace,value);continue}
                           attributes[key] = value;
                           properties[key] = undefined}
                         return h(tagName,properties,children)}
                       function isChildren(x)
                        {return typeof x === "string" || isArray(x)}},
                     {"./hooks/attribute-hook":29,
                      "./index.js":32,
                      "./svg-attribute-namespace":34,
                      "x-is-array":21}],
                    36:
                    [function(require,module,exports)
                      {var
                        isVNode=require("./is-vnode"),
                        isVText=require("./is-vtext"),
                        isWidget=require("./is-widget"),
                        isThunk=require("./is-thunk");
                       module.exports = handleThunk;
                       function handleThunk(a,b)
                        {var renderedA=a,renderedB=b;
                         if(isThunk(b))renderedB = renderThunk(b,a);
                         if(isThunk(a))renderedA = renderThunk(a,null);
                         return {a:renderedA,b:renderedB}}
                       function renderThunk(thunk,previous)
                        {var renderedThunk=thunk.vnode;
                         if(! renderedThunk)
                          renderedThunk = thunk.vnode = thunk.render(previous);
                         if
                          (!
                           (isVNode(renderedThunk)
                            ||
                            isVText(renderedThunk)
                            ||
                            isWidget(renderedThunk)))
                          throw new Error("thunk did not return a valid node");
                         return renderedThunk}},
                     {"./is-thunk":37,
                      "./is-vnode":39,
                      "./is-vtext":40,
                      "./is-widget":41}],
                    37:
                    [function(require,module,exports)
                      {module.exports = isThunk;
                       function isThunk(t){return t && t.type === "Thunk"}},
                     {}],
                    38:
                    [function(require,module,exports)
                      {module.exports = isHook;
                       function isHook(hook)
                        {return hook
                                &&
                                (typeof hook.hook
                                 ===
                                 "function"
                                 &&
                                 !
                                 hook.hasOwnProperty("hook")
                                 ||
                                 typeof hook.unhook
                                 ===
                                 "function"
                                 &&
                                 !
                                 hook.hasOwnProperty("unhook"))}},
                     {}],
                    39:
                    [function(require,module,exports)
                      {var version=require("./version");
                       module.exports = isVirtualNode;
                       function isVirtualNode(x)
                        {return x
                                &&
                                x.type
                                ===
                                "VirtualNode"
                                &&
                                x.version
                                ===
                                version}},
                     {"./version":42}],
                    40:
                    [function(require,module,exports)
                      {var version=require("./version");
                       module.exports = isVirtualText;
                       function isVirtualText(x)
                        {return x
                                &&
                                x.type
                                ===
                                "VirtualText"
                                &&
                                x.version
                                ===
                                version}},
                     {"./version":42}],
                    41:
                    [function(require,module,exports)
                      {module.exports = isWidget;
                       function isWidget(w){return w && w.type === "Widget"}},
                     {}],
                    42:
                    [function(require,module,exports){module.exports = "2"},{}],
                    43:
                    [function(require,module,exports)
                      {var
                        version=require("./version"),
                        isVNode=require("./is-vnode"),
                        isWidget=require("./is-widget"),
                        isThunk=require("./is-thunk"),
                        isVHook=require("./is-vhook");
                       module.exports = VirtualNode;
                       var noProperties={},noChildren=[];
                       function VirtualNode
                        (tagName,properties,children,key,namespace)
                        {this.tagName = tagName;
                         this.properties = properties || noProperties;
                         this.children = children || noChildren;
                         this.key = key != null?String(key):undefined;
                         this.namespace
                         =
                         typeof namespace === "string"?namespace:null;
                         var
                          count=children && children.length || 0,
                          descendants=0,
                          hasWidgets=false,
                          hasThunks=false,
                          descendantHooks=false,
                          hooks;
                         for(var propName in properties)
                          if(properties.hasOwnProperty(propName))
                           {var property=properties[propName];
                            if(isVHook(property) && property.unhook)
                             {if(! hooks)hooks = {};hooks[propName] = property}}
                         for(var i=0;i < count;i++)
                          {var child=children[i];
                           if(isVNode(child))
                            {descendants += child.count || 0;
                             if(! hasWidgets && child.hasWidgets)hasWidgets = true;
                             if(! hasThunks && child.hasThunks)hasThunks = true;
                             if
                              (!
                               descendantHooks
                               &&
                               (child.hooks || child.descendantHooks))
                              descendantHooks = true}
                           else
                            if(! hasWidgets && isWidget(child))
                             {if(typeof child.destroy === "function")hasWidgets = true}
                            else
                             if(! hasThunks && isThunk(child))hasThunks = true}
                         this.count = count + descendants;
                         this.hasWidgets = hasWidgets;
                         this.hasThunks = hasThunks;
                         this.hooks = hooks;
                         this.descendantHooks = descendantHooks}
                       VirtualNode.prototype.version = version;
                       VirtualNode.prototype.type = "VirtualNode"},
                     {"./is-thunk":37,
                      "./is-vhook":38,
                      "./is-vnode":39,
                      "./is-widget":41,
                      "./version":42}],
                    44:
                    [function(require,module,exports)
                      {var version=require("./version");
                       VirtualPatch.NONE = 0;
                       VirtualPatch.VTEXT = 1;
                       VirtualPatch.VNODE = 2;
                       VirtualPatch.WIDGET = 3;
                       VirtualPatch.PROPS = 4;
                       VirtualPatch.ORDER = 5;
                       VirtualPatch.INSERT = 6;
                       VirtualPatch.REMOVE = 7;
                       VirtualPatch.THUNK = 8;
                       module.exports = VirtualPatch;
                       function VirtualPatch(type,vNode,patch)
                        {this.type = Number(type);
                         this.vNode = vNode;
                         this.patch = patch}
                       VirtualPatch.prototype.version = version;
                       VirtualPatch.prototype.type = "VirtualPatch"},
                     {"./version":42}],
                    45:
                    [function(require,module,exports)
                      {var version=require("./version");
                       module.exports = VirtualText;
                       function VirtualText(text){this.text = String(text)}
                       VirtualText.prototype.version = version;
                       VirtualText.prototype.type = "VirtualText"},
                     {"./version":42}],
                    46:
                    [function(require,module,exports)
                      {var
                        isObject=require("is-object"),
                        isHook=require("../vnode/is-vhook");
                       module.exports = diffProps;
                       function diffProps(a,b)
                        {var diff;
                         for(var aKey in a)
                          {if(! (aKey in b)){diff = diff || {};diff[aKey] = undefined}
                           var aValue=a[aKey],bValue=b[aKey];
                           if(aValue === bValue)
                            continue;
                           else
                            if(isObject(aValue) && isObject(bValue))
                             if(getPrototype(bValue) !== getPrototype(aValue))
                              {diff = diff || {};diff[aKey] = bValue}
                             else
                              if(isHook(bValue))
                               {diff = diff || {};diff[aKey] = bValue}
                              else
                               {var objectDiff=diffProps(aValue,bValue);
                                if(objectDiff){diff = diff || {};diff[aKey] = objectDiff}}
                            else
                             {diff = diff || {};diff[aKey] = bValue}}
                         for(var bKey in b)
                          if(! (bKey in a)){diff = diff || {};diff[bKey] = b[bKey]}
                         return diff}
                       function getPrototype(value)
                        {if(Object.getPrototypeOf)
                          return Object.getPrototypeOf(value);
                         else
                          if(value.__proto__)
                           return value.__proto__;
                          else
                           if(value.constructor)return value.constructor.prototype}},
                     {"../vnode/is-vhook":38,"is-object":20}],
                    47:
                    [function(require,module,exports)
                      {var
                        isArray=require("x-is-array"),
                        VPatch=require("../vnode/vpatch"),
                        isVNode=require("../vnode/is-vnode"),
                        isVText=require("../vnode/is-vtext"),
                        isWidget=require("../vnode/is-widget"),
                        isThunk=require("../vnode/is-thunk"),
                        handleThunk=require("../vnode/handle-thunk"),
                        diffProps=require("./diff-props");
                       module.exports = diff;
                       function diff(a,b)
                        {var patch={a:a};walk(a,b,patch,0);return patch}
                       function walk(a,b,patch,index)
                        {if(a === b)return;
                         var apply=patch[index],applyClear=false;
                         if(isThunk(a) || isThunk(b))
                          thunks(a,b,patch,index);
                         else
                          if(b == null)
                           {if(! isWidget(a))
                             {clearState(a,patch,index);apply = patch[index]}
                            apply = appendPatch(apply,new VPatch(VPatch.REMOVE,a,b))}
                          else
                           if(isVNode(b))
                            if(isVNode(a))
                             if
                              (a.tagName
                               ===
                               b.tagName
                               &&
                               a.namespace
                               ===
                               b.namespace
                               &&
                               a.key
                               ===
                               b.key)
                              {var propsPatch=diffProps(a.properties,b.properties);
                               if(propsPatch)
                                apply
                                =
                                appendPatch(apply,new VPatch(VPatch.PROPS,a,propsPatch));
                               apply = diffChildren(a,b,patch,apply,index)}
                             else
                              {apply = appendPatch(apply,new VPatch(VPatch.VNODE,a,b));
                               applyClear = true}
                            else
                             {apply = appendPatch(apply,new VPatch(VPatch.VNODE,a,b));
                              applyClear = true}
                           else
                            if(isVText(b))
                             {if(! isVText(a))
                               {apply = appendPatch(apply,new VPatch(VPatch.VTEXT,a,b));
                                applyClear = true}
                              else
                               if(a.text !== b.text)
                                apply = appendPatch(apply,new VPatch(VPatch.VTEXT,a,b))}
                            else
                             if(isWidget(b))
                              {if(! isWidget(a))applyClear = true;
                               apply = appendPatch(apply,new VPatch(VPatch.WIDGET,a,b))}
                         if(apply)patch[index] = apply;
                         if(applyClear)clearState(a,patch,index)}
                       function diffChildren(a,b,patch,apply,index)
                        {var
                          aChildren=a.children,
                          orderedSet=reorder(aChildren,b.children),
                          bChildren=orderedSet.children,
                          aLen=aChildren.length,
                          bLen=bChildren.length,
                          len=aLen > bLen?aLen:bLen;
                         for(var i=0;i < len;i++)
                          {var leftNode=aChildren[i],rightNode=bChildren[i];
                           index += 1;
                           if(! leftNode)
                            {if(rightNode)
                              apply
                              =
                              appendPatch(apply,new VPatch(VPatch.INSERT,null,rightNode))}
                           else
                            walk(leftNode,rightNode,patch,index);
                           if(isVNode(leftNode) && leftNode.count)
                            index += leftNode.count}
                         if(orderedSet.moves)
                          apply
                          =
                          appendPatch
                           (apply,new VPatch(VPatch.ORDER,a,orderedSet.moves));
                         return apply}
                       function clearState(vNode,patch,index)
                        {unhook(vNode,patch,index);
                         destroyWidgets(vNode,patch,index)}
                       function destroyWidgets(vNode,patch,index)
                        {if(isWidget(vNode))
                          {if(typeof vNode.destroy === "function")
                            patch[index]
                            =
                            appendPatch
                             (patch[index],new VPatch(VPatch.REMOVE,vNode,null))}
                         else
                          if(isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks))
                           {var children=vNode.children,len=children.length;
                            for(var i=0;i < len;i++)
                             {var child=children[i];
                              index += 1;
                              destroyWidgets(child,patch,index);
                              if(isVNode(child) && child.count)index += child.count}}
                          else
                           if(isThunk(vNode))thunks(vNode,null,patch,index)}
                       function thunks(a,b,patch,index)
                        {var
                          nodes=handleThunk(a,b),
                          thunkPatch=diff(nodes.a,nodes.b);
                         if(hasPatches(thunkPatch))
                          patch[index] = new VPatch(VPatch.THUNK,null,thunkPatch)}
                       function hasPatches(patch)
                        {for(var index in patch)if(index !== "a")return true;
                         return false}
                       function unhook(vNode,patch,index)
                        {if(isVNode(vNode))
                          {if(vNode.hooks)
                            patch[index]
                            =
                            appendPatch
                             (patch[index],
                              new VPatch(VPatch.PROPS,vNode,undefinedKeys(vNode.hooks)));
                           if(vNode.descendantHooks || vNode.hasThunks)
                            {var children=vNode.children,len=children.length;
                             for(var i=0;i < len;i++)
                              {var child=children[i];
                               index += 1;
                               unhook(child,patch,index);
                               if(isVNode(child) && child.count)index += child.count}}}
                         else
                          if(isThunk(vNode))thunks(vNode,null,patch,index)}
                       function undefinedKeys(obj)
                        {var result={};
                         for(var key in obj)result[key] = undefined;
                         return result}
                       function reorder(aChildren,bChildren)
                        {var
                          bChildIndex=keyIndex(bChildren),
                          bKeys=bChildIndex.keys,
                          bFree=bChildIndex.free;
                         if(bFree.length === bChildren.length)
                          return {children:bChildren,moves:null};
                         var
                          aChildIndex=keyIndex(aChildren),
                          aKeys=aChildIndex.keys,
                          aFree=aChildIndex.free;
                         if(aFree.length === aChildren.length)
                          return {children:bChildren,moves:null};
                         var
                          newChildren=[],
                          freeIndex=0,
                          freeCount=bFree.length,
                          deletedItems=0;
                         for(var i=0;i < aChildren.length;i++)
                          {var aItem=aChildren[i],itemIndex;
                           if(aItem.key)
                            if(bKeys.hasOwnProperty(aItem.key))
                             {itemIndex = bKeys[aItem.key];
                              newChildren.push(bChildren[itemIndex])}
                            else
                             {itemIndex = i - deletedItems++;newChildren.push(null)}
                           else
                            if(freeIndex < freeCount)
                             {itemIndex = bFree[freeIndex++];
                              newChildren.push(bChildren[itemIndex])}
                            else
                             {itemIndex = i - deletedItems++;newChildren.push(null)}}
                         var
                          lastFreeIndex=
                           freeIndex >= bFree.length?bChildren.length:bFree[freeIndex];
                         for(var j=0;j < bChildren.length;j++)
                          {var newItem=bChildren[j];
                           if(newItem.key)
                            {if(! aKeys.hasOwnProperty(newItem.key))
                              newChildren.push(newItem)}
                           else
                            if(j >= lastFreeIndex)newChildren.push(newItem)}
                         var
                          simulate=newChildren.slice(),
                          simulateIndex=0,
                          removes=[],
                          inserts=[],
                          simulateItem;
                         for(var k=0;k < bChildren.length;)
                          {var wantedItem=bChildren[k];
                           simulateItem = simulate[simulateIndex];
                           while(simulateItem === null && simulate.length)
                            {removes.push(remove(simulate,simulateIndex,null));
                             simulateItem = simulate[simulateIndex]}
                           if(! simulateItem || simulateItem.key !== wantedItem.key)
                            {if(wantedItem.key)
                              {if(simulateItem && simulateItem.key)
                                if(bKeys[simulateItem.key] !== k + 1)
                                 {removes.push
                                   (remove(simulate,simulateIndex,simulateItem.key));
                                  simulateItem = simulate[simulateIndex];
                                  if(! simulateItem || simulateItem.key !== wantedItem.key)
                                   inserts.push({key:wantedItem.key,to:k});
                                  else
                                   simulateIndex++}
                                else
                                 inserts.push({key:wantedItem.key,to:k});
                               else
                                inserts.push({key:wantedItem.key,to:k});
                               k++}
                             else
                              if(simulateItem && simulateItem.key)
                               removes.push
                                (remove(simulate,simulateIndex,simulateItem.key))}
                           else
                            {simulateIndex++;k++}}
                         while(simulateIndex < simulate.length)
                          {simulateItem = simulate[simulateIndex];
                           removes.push
                            (remove
                              (simulate,simulateIndex,simulateItem && simulateItem.key))}
                         if(removes.length === deletedItems && ! inserts.length)
                          return {children:newChildren,moves:null};
                         return {children:newChildren,
                                 moves:{removes:removes,inserts:inserts}}}
                       function remove(arr,index,key)
                        {arr.splice(index,1);return {from:index,key:key}}
                       function keyIndex(children)
                        {var keys={},free=[],length=children.length;
                         for(var i=0;i < length;i++)
                          {var child=children[i];
                           if(child.key)keys[child.key] = i;else free.push(i)}
                         return {keys:keys,free:free}}
                       function appendPatch(apply,patch)
                        {if(apply)
                          {if(isArray(apply))
                            apply.push(patch);
                           else
                            apply = [apply,patch];
                           return apply}
                         else
                          return patch}},
                     {"../vnode/handle-thunk":36,
                      "../vnode/is-thunk":37,
                      "../vnode/is-vnode":39,
                      "../vnode/is-vtext":40,
                      "../vnode/is-widget":41,
                      "../vnode/vpatch":44,
                      "./diff-props":46,
                      "x-is-array":21}],
                    48:
                    [function(require,module,exports)
                      {(function(global)
                          {var
                            vdom=
                             {VNode:require("virtual-dom/vnode/vnode"),
                              VText:require("virtual-dom/vnode/vtext"),
                              diff:require("virtual-dom/diff"),
                              patch:require("virtual-dom/patch"),
                              createElement:require("virtual-dom/create-element"),
                              svg:require("virtual-dom/virtual-hyperscript/svg")};
                           global.VirtualDom = vdom;
                           module.exports = vdom}.call
                         (this,
                          typeof global !== "undefined"
                           ?global
                           :typeof self !== "undefined"
                             ?self
                             :typeof window !== "undefined"?window:{}))},
                     {"virtual-dom/create-element":1,
                      "virtual-dom/diff":2,
                      "virtual-dom/patch":22,
                      "virtual-dom/virtual-hyperscript/svg":35,
                      "virtual-dom/vnode/vnode":43,
                      "virtual-dom/vnode/vtext":45}]},
                   {},
                   [48])
                 (48)}))}
  (function(){return this}()));
(function(joo_global_object)
   {joo_global_object.SoftSetHook
    =
    function(value)
     {if(! (this instanceof SoftSetHook))return new SoftSetHook(value);
      this.value = value};
    joo_global_object.SoftSetHook.prototype.hook
    =
    function(node,propertyName)
     {if(node[propertyName] !== this.value)node[propertyName] = this.value};
    function GenericHook(init,update,destroy,id)
     {if(! (this instanceof GenericHook))
       return new GenericHook(init,update,destroy,id);
      this.init = init;
      this.update = update;
      this.destroy = destroy;
      this.id = id}
    GenericHook.canTransition
    =
    function(from,to)
     {return from instanceof this
             &&
             to instanceof this
             &&
             from.id
             ===
             to.id
             &&
             to.update};
    GenericHook.prototype.hook
    =
    function(node,propName,prev)
     {if(GenericHook.canTransition(prev,this))
       this.state = this.update(prev.state,node);
      else
       this.state = this.init(node)};
    GenericHook.prototype.unhook
    =
    function(node,propName,next)
     {if(GenericHook.canTransition(this,next))
       ;
      else
       this.destroy(this.state,node)};
    joo_global_object.GenericHook = GenericHook}
  (function(){return this}()));
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function bigstring_blit_bigstring_bytes_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_ba_to_bytes(src,src_pos,dst,dst_pos,len)}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    var Base_internalhash_fold_string=caml_hash_mix_string;
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function bigstring_find(bs,chr,pos,len)
     {while(len > 0){if(caml_ba_get_1(bs,pos) == chr)return pos;pos++;len--}
      return - 1}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = undef_module;break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var expect_test_collector_saved_stderr,expect_test_collector_saved_stdout;
    function expect_test_collector_before_test(voutput,vstdout,vstderr)
     {expect_test_collector_saved_stderr = caml_ml_channels[vstderr];
      expect_test_collector_saved_stdout = caml_ml_channels[vstdout];
      var output=caml_ml_channels[voutput];
      caml_ml_channels[vstdout] = output;
      caml_ml_channels[vstderr] = output;
      return 0}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function bigstring_is_mmapped_stub(x){return 0}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_check_bound_bigstring(bigstring,i)
     {if(i >>> 0 >= bigstring.data.length)caml_array_bound_error()}
    function bin_prot_blit_buf_float_array_stub(src_pos,src,dst_pos,dst,len)
     {if(len == 0)return 0;
      caml_check_bound(dst,dst_pos);
      caml_check_bound(dst,dst_pos + len - 1);
      caml_check_bound_bigstring(src,src_pos);
      caml_check_bound_bigstring(src,src_pos + len * 8 - 1);
      var
       view=new (joo_global_object.Float64Array)(len),
       buffer=new (joo_global_object.Uint8Array)(view.buffer);
      buffer.set(src.data.subarray(src_pos,src_pos + len * 8));
      for(var i=0;i < len;i++)dst[dst_pos + i + 1] = view[i];
      return 0}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function Base_int_math_int32_clz(x)
     {var n=32,y;
      y = x >> 16;
      if(y != 0){n = n - 16;x = y}
      y = x >> 8;
      if(y != 0){n = n - 8;x = y}
      y = x >> 4;
      if(y != 0){n = n - 4;x = y}
      y = x >> 2;
      if(y != 0){n = n - 2;x = y}
      y = x >> 1;
      if(y != 0)return n - 2;
      return n - x}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function core_kernel_gc_minor_words(){return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function Base_hash_string(s){return caml_hash(1,1,0,s)}
    function caml_gc_compaction(){return 0}
    function bin_prot_blit_float_array_buf_stub(src_pos,src,dst_pos,dst,len)
     {if(len == 0)return 0;
      caml_check_bound(src,src_pos);
      caml_check_bound(src,src_pos + len - 1);
      caml_check_bound_bigstring(dst,dst_pos);
      caml_check_bound_bigstring(dst,dst_pos + len * 8 - 1);
      src_pos = src_pos + 1;
      var
       float64=
        new (joo_global_object.Float64Array)(src.slice(src_pos,src_pos + len)),
       float64_uint8=new (joo_global_object.Uint8Array)(float64.buffer),
       view=dst.data.subarray(dst_pos,dst_pos + len * 8);
      view.set(float64_uint8);
      return 0}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_string_of_bytes(s){return s}
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function core_md5_fd(fd)
     {var ic=caml_ml_open_descriptor_in(fd);
      try {return caml_md5_chan(ic,- 1)}finally {caml_ml_close_channel(ic)}}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function Base_int_math_int_pow_stub(base,exponent)
     {var one=1,mul=[one,base,one,one],res=one;
      while(! exponent == 0)
       {mul[1] = mul[1] * mul[3] | 0;
        mul[2] = mul[1] * mul[1] | 0;
        mul[3] = mul[2] * mul[1] | 0;
        res = res * mul[exponent & 3] | 0;
        exponent = exponent >> 2}
      return res}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function core_kernel_gc_major_plus_minor_words(){return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function bin_prot_blit_bytes_buf_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function bin_prot_blit_buf_stub(src_pos,src,dst_pos,dst,len)
     {if(src.kind != 12)src = bigstring_of_typed_array(src.data);
      if(dst.kind != 12)dst = bigstring_of_typed_array(dst.data);
      return caml_bigstring_blit_ba_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    var Base_internalhash_fold_float=caml_hash_mix_float;
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function bigstring_destroy_stub(v_bstr)
     {if(v_bstr.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_destroy: bigstring is already deallocated");
      v_bstr.__is_deallocated = true;
      v_bstr.data = new (v_bstr.data.__proto__.constructor)(0);
      v_bstr.dims = [0];
      return 0}
    function bigstring_realloc(bigstring,size)
     {if(bigstring.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_realloc: bigstring is already deallocated");
      var new_data=new (bigstring.data.__proto__.constructor)(size);
      new_data.set(bigstring.data.slice(0,size));
      var
       new_bigstring=
        caml_ba_create_unsafe(bigstring.kind,bigstring.layout,[size],new_data);
      bigstring_destroy_stub(bigstring);
      return new_bigstring}
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function Base_am_testing(x){return 0}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function core_kernel_gc_major_words(){return 0}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function bigstring_memcmp_stub(v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var
         a=caml_ba_get_1(v_s1,v_s1_pos + i),
         b=caml_ba_get_1(v_s2,v_s2_pos + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_int64_mul(x,y){return x.mul(y)}
    function Base_int_math_int64_pow_stub(base,exponent)
     {var one=caml_int64_create_lo_hi(1,0),mul=[one,base,one,one],res=one;
      while(! caml_int64_is_zero(exponent))
       {mul[1] = caml_int64_mul(mul[1],mul[3]);
        mul[2] = caml_int64_mul(mul[1],mul[1]);
        mul[3] = caml_int64_mul(mul[2],mul[1]);
        res = caml_int64_mul(res,mul[caml_int64_lo32(exponent) & 3]);
        exponent = caml_int64_shift_right_unsigned(exponent,2)}
      return res}
    function caml_sys_const_word_size(){return 32}
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function bigstring_alloc(_,size){return caml_ba_create(12,0,[0,size])}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function Base_int_math_int32_ctz(x)
     {if(x === 0)return 32;
      var n=1;
      if((x & 0x0000FFFF) === 0){n = n + 16;x = x >> 16}
      if((x & 0x000000FF) === 0){n = n + 8;x = x >> 8}
      if((x & 0x0000000F) === 0){n = n + 4;x = x >> 4}
      if((x & 0x00000003) === 0){n = n + 2;x = x >> 2}
      return n - (x & 1)}
    function Base_int_math_nativeint_ctz(x){return Base_int_math_int32_ctz(x)}
    function expect_test_collector_after_test(vstdout,vstderr)
     {caml_ml_channels[vstdout] = expect_test_collector_saved_stdout;
      caml_ml_channels[vstderr] = expect_test_collector_saved_stderr;
      return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    var Base_internalhash_fold_int=caml_hash_mix_int;
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function Base_int_math_nativeint_clz(x){return Base_int_math_int32_clz(x)}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function bigstring_memset_stub(bigstring,v_pos,v_len,v_char)
     {for(var i=0;i < v_len;i++)caml_ba_set_1(bigstring,v_pos + i,v_char)}
    function core_kernel_time_ns_format(time,format)
     {var
       d=new Date(time * 1000),
       formatjs=caml_jsbytes_of_string(format),
       jstring=joo_global_object.strftime(formatjs,d);
      return caml_string_of_jsbytes(jstring)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    var internalhash_fold_bigstring=caml_hash_mix_bigstring;
    function Base_int_math_int64_clz(x)
     {var n=64,y;
      y = caml_int64_shift_right_unsigned(x,32);
      if(! caml_int64_is_zero(y)){n = n - 32;x = y}
      y = caml_int64_shift_right_unsigned(x,16);
      if(! caml_int64_is_zero(y)){n = n - 16;x = y}
      y = caml_int64_shift_right_unsigned(x,8);
      if(! caml_int64_is_zero(y)){n = n - 8;x = y}
      y = caml_int64_shift_right_unsigned(x,4);
      if(! caml_int64_is_zero(y)){n = n - 4;x = y}
      y = caml_int64_shift_right_unsigned(x,2);
      if(! caml_int64_is_zero(y)){n = n - 2;x = y}
      y = caml_int64_shift_right_unsigned(x,1);
      if(! caml_int64_is_zero(y))return n - 2;
      return n - caml_int64_to_int32(x)}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    var Base_internalhash_fold_int64=caml_hash_mix_int64;
    function core_kernel_gc_promoted_words(){return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function core_kernel_gc_heap_chunks(){return 0}
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_out_channel_pos_fd(chan)
     {var info=caml_ml_channels[chan];return info.offset}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    var core_array_unsafe_int_blit=caml_array_blit;
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function core_kernel_gc_minor_collections(){return 0}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function Base_int_math_int_clz(x){return Base_int_math_int32_clz(x)}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function core_md5_digest_subbigstring(buf,ofs,len,res)
     {var bytes=caml_create_bytes(len);
      bigstring_blit_bigstring_bytes_stub(buf,ofs,bytes,0,len);
      var res2=caml_md5_string(caml_string_of_bytes(bytes),0,len);
      caml_blit_string(res2,0,res,0,16);
      return 0}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function bin_prot_blit_buf_bytes_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_ba_to_bytes(src,src_pos,dst,dst_pos,len)}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function Base_int_math_int_ctz(x){return Base_int_math_int32_ctz(x)}
    function bigstring_blit_string_bigstring_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function Base_int_math_int64_ctz(x)
     {if(caml_int64_is_zero(x))return 64;
      var n=1;
      function is_zero(x){return caml_int64_is_zero(x)}
      function land(x,y){return caml_int64_and(x,y)}
      function small_int64(x){return caml_int64_create_lo_mi_hi(x,0,0)}
      if
       (is_zero(land(x,caml_int64_create_lo_mi_hi(0xFFFFFF,0x0000FF,0x0000))))
       {n = n + 32;x = caml_int64_shift_right_unsigned(x,32)}
      if(is_zero(land(x,small_int64(0x00FFFF))))
       {n = n + 16;x = caml_int64_shift_right_unsigned(x,16)}
      if(is_zero(land(x,small_int64(0x0000FF))))
       {n = n + 8;x = caml_int64_shift_right_unsigned(x,8)}
      if(is_zero(land(x,small_int64(0x00000F))))
       {n = n + 4;x = caml_int64_shift_right_unsigned(x,4)}
      if(is_zero(land(x,small_int64(0x000003))))
       {n = n + 2;x = caml_int64_shift_right_unsigned(x,2)}
      return n - caml_int64_to_int32(caml_int64_and(x,small_int64(0x000001)))}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    var core_array_unsafe_float_blit=caml_array_blit;
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function Base_internalhash_get_hash_value(seed)
     {var h=caml_hash_mix_final(seed);return h & 0x3FFFFFFF}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function core_kernel_gc_compactions(){return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var caml_ephe_blit_key=caml_weak_blit;
    function Base_clear_caml_backtrace_pos(x){return 0}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function Core_kernel_heap_block_is_heap_block(x)
     {return + (x instanceof Array)}
    function bigstring_blit_bytes_bigstring_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_bytes_to_ba(src,src_pos,dst,dst_pos,len)}
    function core_kernel_gc_major_collections(){return 0}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function core_kernel_gc_top_heap_words(){return 0}
    function Base_hash_double(d){return caml_hash(1,1,0,d)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function core_kernel_gc_heap_words(){return 0}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    var ms_to_nano=caml_int64_of_int32(1000 * 1000);
    function time_now_nanoseconds_since_unix_epoch_or_zero()
     {var ms=Date.now(),ms_i63=caml_int64_of_float(ms * 2);
      return caml_int64_mul(ms_i63,ms_to_nano)}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {function loop(shape,real,x,parent,i)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:parent[i] = x;break;
           case 1:
           case 2:
           default:caml_update_dummy(real,x)}
        else
         switch(shape[0])
          {case 0:
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],real[i],x[i],real,i);
            break
           }}
      loop(shape,real,x,undefined,undefined);
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function bin_prot_blit_string_buf_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function bigstring_blit_stub(s1,i1,s2,i2,len)
     {return caml_bigstring_blit_ba_to_ba(s1,i1,s2,i2,len)}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function Base_int_math_int_popcount(v)
     {v = v - (v >>> 1 & 0x55555555);
      v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
      return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {bigstring_realloc:bigstring_realloc,
     bigstring_destroy_stub:bigstring_destroy_stub,
     core_md5_digest_subbigstring:core_md5_digest_subbigstring,
     core_md5_fd:core_md5_fd,
     Core_kernel_heap_block_is_heap_block:Core_kernel_heap_block_is_heap_block,
     core_kernel_gc_top_heap_words:core_kernel_gc_top_heap_words,
     core_kernel_gc_promoted_words:core_kernel_gc_promoted_words,
     core_kernel_gc_minor_words:core_kernel_gc_minor_words,
     core_kernel_gc_minor_collections:core_kernel_gc_minor_collections,
     core_kernel_gc_major_words:core_kernel_gc_major_words,
     core_kernel_gc_major_plus_minor_words:
     core_kernel_gc_major_plus_minor_words,
     core_kernel_gc_major_collections:core_kernel_gc_major_collections,
     core_kernel_gc_heap_words:core_kernel_gc_heap_words,
     core_kernel_gc_heap_chunks:core_kernel_gc_heap_chunks,
     core_kernel_gc_compactions:core_kernel_gc_compactions,
     core_kernel_time_ns_format:core_kernel_time_ns_format,
     core_array_unsafe_float_blit:core_array_unsafe_float_blit,
     core_array_unsafe_int_blit:core_array_unsafe_int_blit,
     bigstring_find:bigstring_find,
     internalhash_fold_bigstring:internalhash_fold_bigstring,
     bigstring_memcmp_stub:bigstring_memcmp_stub,
     bigstring_memset_stub:bigstring_memset_stub,
     bigstring_blit_string_bigstring_stub:bigstring_blit_string_bigstring_stub,
     bigstring_blit_bigstring_bytes_stub:bigstring_blit_bigstring_bytes_stub,
     bigstring_blit_bytes_bigstring_stub:bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_stub:bigstring_blit_stub,
     bigstring_is_mmapped_stub:bigstring_is_mmapped_stub,
     bigstring_alloc:bigstring_alloc,
     caml_out_channel_pos_fd:caml_out_channel_pos_fd,
     expect_test_collector_after_test:expect_test_collector_after_test,
     expect_test_collector_before_test:expect_test_collector_before_test,
     expect_test_collector_saved_stderr:expect_test_collector_saved_stderr,
     expect_test_collector_saved_stdout:expect_test_collector_saved_stdout,
     time_now_nanoseconds_since_unix_epoch_or_zero:
     time_now_nanoseconds_since_unix_epoch_or_zero,
     bin_prot_blit_buf_stub:bin_prot_blit_buf_stub,
     bin_prot_blit_bytes_buf_stub:bin_prot_blit_bytes_buf_stub,
     bin_prot_blit_string_buf_stub:bin_prot_blit_string_buf_stub,
     bin_prot_blit_float_array_buf_stub:bin_prot_blit_float_array_buf_stub,
     bin_prot_blit_buf_bytes_stub:bin_prot_blit_buf_bytes_stub,
     bin_prot_blit_buf_float_array_stub:bin_prot_blit_buf_float_array_stub,
     caml_check_bound_bigstring:caml_check_bound_bigstring,
     Base_am_testing:Base_am_testing,
     Base_hash_double:Base_hash_double,
     Base_hash_string:Base_hash_string,
     Base_int_math_int64_pow_stub:Base_int_math_int64_pow_stub,
     Base_int_math_int_pow_stub:Base_int_math_int_pow_stub,
     Base_int_math_int64_ctz:Base_int_math_int64_ctz,
     Base_int_math_nativeint_ctz:Base_int_math_nativeint_ctz,
     Base_int_math_int_ctz:Base_int_math_int_ctz,
     Base_int_math_int32_ctz:Base_int_math_int32_ctz,
     Base_int_math_int64_clz:Base_int_math_int64_clz,
     Base_int_math_nativeint_clz:Base_int_math_nativeint_clz,
     Base_int_math_int_clz:Base_int_math_int_clz,
     Base_int_math_int32_clz:Base_int_math_int32_clz,
     Base_clear_caml_backtrace_pos:Base_clear_caml_backtrace_pos,
     Base_int_math_int_popcount:Base_int_math_int_popcount,
     Base_internalhash_get_hash_value:Base_internalhash_get_hash_value,
     Base_internalhash_fold_string:Base_internalhash_fold_string,
     Base_internalhash_fold_float:Base_internalhash_fold_float,
     Base_internalhash_fold_int:Base_internalhash_fold_int,
     Base_internalhash_fold_int64:Base_internalhash_fold_int64,
     caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtYWluLmJjLnJ1bnRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiRGVmYXVsdExvY2FsZSIsImRlZmF1bHRTdHJmdGltZSIsIlN0cmZ0aW1lIiwiaXNDb21tb25KUyIsIm1vZHVsZSIsIm5hbWVzcGFjZSIsImFkYXB0ZWRTdHJmdGltZSIsImRlcHJlY2F0ZWRTdHJmdGltZSIsImpvb19nbG9iYWxfb2JqZWN0IiwidGhpcyIsImV2YWwiLCJfcmVxdWlyZSIsIl9kZXByZWNhdGlvbldhcm5pbmdzIiwiZGVwcmVjYXRpb25XYXJuaW5nIiwibmFtZSIsImluc3RlYWQiLCJjb25zb2xlIiwiZGVwcmVjYXRlZFN0cmZ0aW1lVFoiLCJkZXByZWNhdGVkU3RyZnRpbWVVVEMiLCJkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQiLCJhZGFwdEZvcndhcmRzIiwiZm4iLCJmbXQiLCJkIiwibG9jYWxlIiwidW5kZWZpbmVkIiwic3RyZnRpbWUiLCJ0aW1lem9uZSIsIm51bGwiLCJ1dGNTdHJmdGltZSIsIkRhdGUiLCJjdXN0b21UaW1lem9uZU9mZnNldCIsInVzZVV0Y1RpbWV6b25lIiwiX2xvY2FsZSIsIl9jdXN0b21UaW1lem9uZU9mZnNldCIsIl91c2VVdGNCYXNlZERhdGUiLCJfY2FjaGVkRGF0ZVRpbWVzdGFtcCIsIl9jYWNoZWREYXRlIiwiX3N0cmZ0aW1lIiwiZm9ybWF0IiwiZGF0ZSIsInRpbWVzdGFtcCIsImN1cnJlbnRUaW1lc3RhbXAiLCJnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvciIsIl9wcm9jZXNzRm9ybWF0IiwicmVzdWx0U3RyaW5nIiwicGFkZGluZyIsImlzSW5TY29wZSIsImxlbmd0aCIsImV4dGVuZGVkVFoiLCJpIiwiY3VycmVudENoYXJDb2RlIiwicGFkVGlsbDIiLCJNYXRoIiwiaG91cnMxMiIsInBhZFRpbGwzIiwid2Vla051bWJlciIsInR6U3RyaW5nIiwieSIsImRheSIsIlN0cmluZyIsIm9yZGluYWwiLCJvZmYiLCJzaWduIiwic2VwIiwiaG91cnMiLCJtaW5zIiwidXNlVXRjQmFzZWREYXRlIiwidGltZXpvbmVUeXBlIiwicGFyc2VJbnQiLCJtaW51dGVzIiwibnVtYmVyVG9QYWQiLCJwYWRkaW5nQ2hhciIsImhvdXIiLCJmaXJzdFdlZWtkYXkiLCJ3ZWVrZGF5IiwiZmlyc3REYXlPZlllYXJVdGMiLCJkYXRlVXRjIiwieWRheSIsIndlZWtOdW0iLCJudW1iZXIiLCJpaSIsImYiLCJleHBvcnRzIiwiZGVmaW5lIiwiZyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJlIiwidCIsIm4iLCJyIiwicyIsIm8iLCJ1IiwiYSIsInJlcXVpcmUiLCJFcnJvciIsImwiLCJjcmVhdGVFbGVtZW50IiwiZGlmZiIsInVuZGVmIiwibmF0aXZlU3BsaXQiLCJjb21wbGlhbnRFeGVjTnBjZyIsInN0ciIsInNlcGFyYXRvciIsImxpbWl0IiwiT2JqZWN0Iiwib3V0cHV0IiwiZmxhZ3MiLCJsYXN0TGFzdEluZGV4IiwiUmVnRXhwIiwic2VwYXJhdG9yMiIsIm1hdGNoIiwibGFzdEluZGV4IiwibGFzdExlbmd0aCIsImFyZ3VtZW50cyIsIkFycmF5IiwiT25lVmVyc2lvbkNvbnN0cmFpbnQiLCJNWV9WRVJTSU9OIiwiaGFzaEtleSIsIkV2U3RvcmUiLCJlbGVtIiwiaGFzaCIsInJvb3QiLCJJbmRpdmlkdWFsIiwia2V5IiwidmFsdWUiLCJPbmVWZXJzaW9uIiwibW9kdWxlTmFtZSIsInZlcnNpb24iLCJkZWZhdWx0VmFsdWUiLCJlbmZvcmNlS2V5IiwidmVyc2lvblZhbHVlIiwidG9wTGV2ZWwiLCJtaW5Eb2MiLCJkb2N1bWVudCIsImRvY2N5IiwiZG9tV2FsayIsIkNvbW1lbnQiLCJET01UZXh0IiwiRE9NRWxlbWVudCIsIkRvY3VtZW50RnJhZ21lbnQiLCJFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkRvY3VtZW50IiwicHJvdG8iLCJ0YWdOYW1lIiwibnMiLCJmYW1pbHkiLCJkYXRhIiwiaWQiLCJyZXN1bHQiLCJub2RlIiwib3duZXIiLCJzZXJpYWxpemVOb2RlIiwiaHRtbG5zIiwiY2hpbGQiLCJuZWVkbGUiLCJpbmRleCIsInByZWZpeCIsImxvY2FsTmFtZSIsImNvbG9uUG9zaXRpb24iLCJhdHRyaWJ1dGVzIiwiY2xhc3NOYW1lcyIsImNsYXNzZXMiLCJlbGVtcyIsIm5vZGVDbGFzc05hbWUiLCJub2RlQ2xhc3NlcyIsIml0ZW0iLCJlbGVtZW50IiwiY3VycmVudCIsImxlZnQiLCJyaWdodCIsInR5cGUiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImxpc3RlbmVyIiwiZXYiLCJsaXN0ZW5lcnMiLCJsaXN0Iiwic2xpY2UiLCJpdGVyYXRpdmVseVdhbGsiLCJub2RlcyIsImNiIiwicmV0Iiwidm9pZEVsZW1lbnRzIiwiZXNjYXBlVGV4dCIsInNlcmlhbGl6ZUVsZW1lbnQiLCJzdHJpbmdzIiwidGFnbmFtZSIsInByb3BlcnRpZXMiLCJkYXRhc2V0aWZ5IiwiaXNQcm9wZXJ0eSIsInN0eWxpZnkiLCJzdHlsZXMiLCJhdHRyIiwiYyIsImRzIiwicHJvcHMiLCJzdHJpbmdpZnkiLCJ0dXBsZSIsImVzY2FwZUF0dHJpYnV0ZVZhbHVlIiwiYXR0cmlidXRlIiwicHJvcCIsIngiLCJuYXRpdmVJc0FycmF5IiwidG9TdHJpbmciLCJpc0FycmF5Iiwib2JqIiwicGF0Y2giLCJpc09iamVjdCIsImlzSG9vayIsImFwcGx5UHJvcGVydGllcyIsInByZXZpb3VzIiwicHJvcE5hbWUiLCJwcm9wVmFsdWUiLCJyZW1vdmVQcm9wZXJ0eSIsInBhdGNoT2JqZWN0IiwicHJldmlvdXNWYWx1ZSIsImF0dHJOYW1lIiwiYXR0clZhbHVlIiwiZ2V0UHJvdG90eXBlIiwicmVwbGFjZXIiLCJrIiwiaXNWTm9kZSIsImlzVlRleHQiLCJpc1dpZGdldCIsImhhbmRsZVRodW5rIiwidm5vZGUiLCJvcHRzIiwiZG9jIiwid2FybiIsImNoaWxkcmVuIiwiY2hpbGROb2RlIiwibm9DaGlsZCIsImRvbUluZGV4Iiwicm9vdE5vZGUiLCJ0cmVlIiwiaW5kaWNlcyIsImFzY2VuZGluZyIsInJlY3Vyc2UiLCJyb290SW5kZXgiLCJpbmRleEluUmFuZ2UiLCJ2Q2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwidkNoaWxkIiwibmV4dEluZGV4IiwibWluSW5kZXgiLCJtYXhJbmRleCIsImN1cnJlbnRJbmRleCIsImN1cnJlbnRJdGVtIiwiYiIsIlZQYXRjaCIsInVwZGF0ZVdpZGdldCIsImFwcGx5UGF0Y2giLCJ2cGF0Y2giLCJkb21Ob2RlIiwicmVuZGVyT3B0aW9ucyIsInZOb2RlIiwicmVtb3ZlTm9kZSIsImluc2VydE5vZGUiLCJzdHJpbmdQYXRjaCIsIndpZGdldFBhdGNoIiwidk5vZGVQYXRjaCIsInJlb3JkZXJDaGlsZHJlbiIsInJlcGxhY2VSb290IiwicGFyZW50Tm9kZSIsImRlc3Ryb3lXaWRnZXQiLCJuZXdOb2RlIiwibGVmdFZOb2RlIiwidlRleHQiLCJ3aWRnZXQiLCJ1cGRhdGluZyIsInciLCJtb3ZlcyIsImtleU1hcCIsInJlbW92ZSIsImluc2VydCIsImoiLCJvbGRSb290IiwibmV3Um9vdCIsInJlbmRlciIsInBhdGNoT3AiLCJwYXRjaGVzIiwicGF0Y2hSZWN1cnNpdmUiLCJwYXRjaEluZGljZXMiLCJvd25lckRvY3VtZW50Iiwibm9kZUluZGV4IiwicGF0Y2hMaXN0IiwiTnVtYmVyIiwiQXR0cmlidXRlSG9vayIsInByZXYiLCJuZXh0IiwiRXZIb29rIiwicHJvcGVydHlOYW1lIiwiZXMiLCJTb2Z0U2V0SG9vayIsIlZOb2RlIiwiVlRleHQiLCJpc1ZUaHVuayIsInBhcnNlVGFnIiwic29mdFNldEhvb2siLCJldkhvb2siLCJoIiwidGFnIiwiaXNDaGlsZHJlbiIsInRyYW5zZm9ybVByb3BlcnRpZXMiLCJhZGRDaGlsZCIsImlzQ2hpbGQiLCJVbmV4cGVjdGVkVmlydHVhbEVsZW1lbnQiLCJlcnIiLCJlcnJvclN0cmluZyIsIkpTT04iLCJzcGxpdCIsImNsYXNzSWRTcGxpdCIsIm5vdENsYXNzSWQiLCJub0lkIiwidGFnUGFydHMiLCJwYXJ0IiwiREVGQVVMVF9OQU1FU1BBQ0UiLCJFVl9OQU1FU1BBQ0UiLCJYTElOS19OQU1FU1BBQ0UiLCJYTUxfTkFNRVNQQUNFIiwiU1ZHX1BST1BFUlRJRVMiLCJTVkdBdHRyaWJ1dGVOYW1lc3BhY2UiLCJhdHRyaWJ1dGVIb29rIiwiU1ZHX05BTUVTUEFDRSIsInN2ZyIsImlzVGh1bmsiLCJyZW5kZXJlZEEiLCJyZW5kZXJlZEIiLCJyZW5kZXJUaHVuayIsInRodW5rIiwicmVuZGVyZWRUaHVuayIsImhvb2siLCJpc1ZpcnR1YWxOb2RlIiwiaXNWaXJ0dWFsVGV4dCIsImlzVkhvb2siLCJWaXJ0dWFsTm9kZSIsIm5vUHJvcGVydGllcyIsIm5vQ2hpbGRyZW4iLCJjb3VudCIsImRlc2NlbmRhbnRzIiwiaGFzV2lkZ2V0cyIsImhhc1RodW5rcyIsImRlc2NlbmRhbnRIb29rcyIsImhvb2tzIiwicHJvcGVydHkiLCJWaXJ0dWFsUGF0Y2giLCJWaXJ0dWFsVGV4dCIsInRleHQiLCJkaWZmUHJvcHMiLCJhS2V5IiwiYVZhbHVlIiwiYlZhbHVlIiwib2JqZWN0RGlmZiIsImJLZXkiLCJ3YWxrIiwiYXBwbHkiLCJhcHBseUNsZWFyIiwidGh1bmtzIiwiY2xlYXJTdGF0ZSIsImFwcGVuZFBhdGNoIiwicHJvcHNQYXRjaCIsImRpZmZDaGlsZHJlbiIsImFDaGlsZHJlbiIsIm9yZGVyZWRTZXQiLCJyZW9yZGVyIiwiYkNoaWxkcmVuIiwiYUxlbiIsImJMZW4iLCJsZW4iLCJsZWZ0Tm9kZSIsInJpZ2h0Tm9kZSIsInVuaG9vayIsImRlc3Ryb3lXaWRnZXRzIiwidGh1bmtQYXRjaCIsImhhc1BhdGNoZXMiLCJ1bmRlZmluZWRLZXlzIiwiYkNoaWxkSW5kZXgiLCJrZXlJbmRleCIsImJLZXlzIiwiYkZyZWUiLCJhQ2hpbGRJbmRleCIsImFLZXlzIiwiYUZyZWUiLCJuZXdDaGlsZHJlbiIsImZyZWVJbmRleCIsImZyZWVDb3VudCIsImRlbGV0ZWRJdGVtcyIsImFJdGVtIiwiaXRlbUluZGV4IiwibGFzdEZyZWVJbmRleCIsIm5ld0l0ZW0iLCJzaW11bGF0ZSIsInNpbXVsYXRlSW5kZXgiLCJyZW1vdmVzIiwiaW5zZXJ0cyIsInNpbXVsYXRlSXRlbSIsIndhbnRlZEl0ZW0iLCJhcnIiLCJrZXlzIiwiZnJlZSIsInZkb20iLCJHZW5lcmljSG9vayIsImluaXQiLCJ1cGRhdGUiLCJkZXN0cm95IiwiZnJvbSIsInRvIiwiY2FtbF9pbnQ2NF9pc196ZXJvIiwiY2FtbF9zdHJfcmVwZWF0IiwiY2FtbF9pbnQ2NF9vZmZzZXQiLCJjYW1sX3JhaXNlX2NvbnN0YW50IiwiY2FtbF9nbG9iYWxfZGF0YSIsImNhbWxfcmFpc2VfemVyb19kaXZpZGUiLCJNbEludDY0IiwibG8iLCJtaSIsImhpIiwieGhpIiwib2Zmc2V0IiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInEiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9yYWlzZV93aXRoX2FyZyIsImFyZyIsImpzb29faXNfYXNjaWkiLCJjYW1sX3V0ZjE2X29mX3V0ZjgiLCJjMSIsImMyIiwidiIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImNvbnRlbnQiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfcGFyc2VfZm9ybWF0IiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImJ1ZmZlciIsImNhbWxfaW50NjRfZm9ybWF0Iiwid2Jhc2UiLCJjdnRibCIsInAiLCJjYW1sX2V4cG0xX2Zsb2F0IiwieiIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiY2FtbF9jdXJyZW50X2RpciIsImNhbWxfbWFrZV9wYXRoIiwiY29tcCIsIm5jb21wIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyIsImNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIiwiY2FtbF9yYWlzZV9zeXNfZXJyb3IiLCJjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSIsImNhbWxfYnl0ZXNfYm91bmRfZXJyb3IiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsImNhbWxfYmxpdF9zdHJpbmciLCJNbEZpbGUiLCJNbEZha2VGaWxlIiwib2xkIiwiYnVmIiwicG9zIiwiY2xlbiIsIm5ld19zdHIiLCJvbGRfZGF0YSIsIk1sRmFrZURldmljZSIsInJlcyIsIm5hbWVfc2xhc2giLCJzZWVuIiwibSIsIm9rIiwiZmlsZSIsImJ5dGVzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9hcnJheV9vZl9ieXRlcyIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmlsZSIsImZkIiwiYnVmX29mZnNldCIsIk1sTm9kZURldmljZSIsImNvbnN0cyIsImNhbWxfcm9vdCIsImZzX25vZGVfc3VwcG9ydGVkIiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwicGF0aCIsImNhbWxfc3lzX2lzX2RpcmVjdG9yeSIsImNhbWxfcmFpc2Vfbm90X2ZvdW5kIiwiY2FtbF9zeXNfZ2V0ZW52Iiwic2hpZnRfcmlnaHRfbmF0IiwibmF0MSIsIm9mczEiLCJsZW4xIiwibmF0MiIsIm9mczIiLCJuYml0cyIsIndyYXAiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImNhbWxfZ3Jfc3RhdGUiLCJjYW1sX2dyX3N0YXRlX2dldCIsImNhbWxfZ3JfcG9pbnRfY29sb3IiLCJpbSIsIk1sT2JqZWN0VGFibGUiLCJOYWl2ZUxvb2t1cCIsIm9ianMiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9sb2cxMF9mbG9hdCIsImNhbWxfcnVudGltZV93YXJuaW5ncyIsImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJib29sIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImlzRmluaXRlIiwiaXNOYU4iLCJjYW1sX21sX3JlZmlsbF9pbnB1dCIsImNoYW4iLCJzdHJfbGVuIiwiY2FtbF9tbF9jaGFubmVscyIsImNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCIsImNoYW5pZCIsImNhbWxfYXJyYXlfYm91bmRfZXJyb3IiLCJjYW1sX21sX2lucHV0X3NjYW5fbGluZSIsImNhbWxfZ2NfbWlub3IiLCJjYW1sX2ludDY0X29mX2J5dGVzIiwiY2FtbF9iYV91aW50OF9nZXQ2NCIsImJhIiwiaTAiLCJvZnMiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiY2FtbF9pbnQ2NF90b19ieXRlcyIsImNhbWxfaW50NjRfbWFyc2hhbCIsIndyaXRlciIsInNpemVzIiwiY2FtbF9iYV9udW1fZGltcyIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMiLCJiYTEiLCJwb3MxIiwiYnl0ZXMyIiwicG9zMiIsImJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViIiwic3JjIiwic3JjX3BvcyIsImRzdCIsImRzdF9wb3MiLCJjYW1sX3JldHVybl9leG5fY29uc3RhbnQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jcmVhdGVfZmlsZSIsImNhbWxfZnNfaW5pdCIsInRtcCIsImNhbWxfbXVsIiwiY2FtbF9oYXNoX21peF9pbnQiLCJjYW1sX2hhc2hfbWl4X2pzYnl0ZXMiLCJjYW1sX2hhc2hfbWl4X3N0cmluZyIsIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwidW5peF9nZXR0aW1lb2ZkYXkiLCJudW1fZGlnaXRzX25hdCIsIm5hdCIsImNhbWxfaGFzaF9uYXQiLCJjYW1sX2NhbGxfZ2VuIiwiYXJncyIsImFyZ3NMZW4iLCJleHRyYV9hcmdzIiwibmFyZ3MiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zeXNfY2hkaXIiLCJkaXIiLCJjYW1sX2djX2NvdW50ZXJzIiwiY2FtbF9ncl9zeW5jaHJvbml6ZSIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJJbmZpbml0eSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImZsb2F0MzJhIiwiaW50MzJhIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJleHAiLCJyMyIsInIyIiwicjEiLCJjYW1sX2JhX3NlcmlhbGl6ZSIsInN6IiwiY29tcGxleCIsImNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQiLCJraW5kIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwic2l6ZSIsInZpZXciLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5IiwibGF5b3V0IiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwiY2FtbF9pbnQzMl91bm1hcnNoYWwiLCJjYW1sX25hdGl2ZWludF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X3VubWFyc2hhbCIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX2J5dGVzX2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfZ3JlYXRlcnRoYW4iLCJkaXZfaGVscGVyIiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIk1sTmF0IiwiY3JlYXRlX25hdCIsInNldF90b196ZXJvX25hdCIsImluY3JfbmF0IiwiY2FycnlfaW4iLCJjYXJyeSIsImFkZF9uYXQiLCJsZW4yIiwibmF0X29mX2FycmF5IiwibXVsdF9kaWdpdF9uYXQiLCJuYXQzIiwib2ZzMyIsIngxIiwieDIiLCJ4MyIsImRlY3JfbmF0IiwiYm9ycm93Iiwic3ViX25hdCIsImNvbXBhcmVfbmF0IiwiZGl2X25hdCIsInF1byIsImNhbWxfYmFfYmxpdCIsImlzX2RpZ2l0X2ludCIsImNhbWxfaW50NjRfZGl2IiwiY2FtbF9iYV9nZXRfMSIsImJpZ3N0cmluZ19maW5kIiwiYnMiLCJjaHIiLCJjYW1sX2pzX2h0bWxfZW50aXRpZXMiLCJlbnRpdHkiLCJ0ZW1wIiwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldCIsImNhbWxfaW50NjRfb2ZfZmxvYXQiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NCIsImNhbWxfYmFfc2V0XzIiLCJjYW1sX2FyZ3YiLCJtYWluIiwiYXJndiIsImFyZ3MyIiwiY2FtbF9leGVjdXRhYmxlX25hbWUiLCJjYW1sX2pzX2V2YWxfc3RyaW5nIiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QiLCJsb2MiLCJzaGFwZSIsInVuZGVmX21vZHVsZSIsIl94IiwibG9vcCIsInN0cnVjdCIsImlkeCIsInNlcmlhbGl6ZV9uYXQiLCJjYW1sX21lbXByb2Zfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX3N5c19leGl0IiwiY29kZSIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfcmVzaGFwZSIsInZpbmQiLCJuZXdfZGltIiwiZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyciIsImV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXQiLCJleHBlY3RfdGVzdF9jb2xsZWN0b3JfYmVmb3JlX3Rlc3QiLCJ2b3V0cHV0IiwidnN0ZG91dCIsInZzdGRlcnIiLCJjYW1sX29vX2xhc3RfaWQiLCJjYW1sX3NldF9vb19pZCIsImNhbWxfZ3JfZmlsbF9yZWN0IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJzdHIxIiwiYmEyIiwiY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlIiwianNuYW1lIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImJpZ3N0cmluZ19pc19tbWFwcGVkX3N0dWIiLCJjYW1sX2NoZWNrX2JvdW5kIiwiYXJyYXkiLCJjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZyIsImJpZ3N0cmluZyIsImJpbl9wcm90X2JsaXRfYnVmX2Zsb2F0X2FycmF5X3N0dWIiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfbmV3X3N0cmluZyIsImNhbWxfYmFfdWludDhfZ2V0MzIiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImx4b3JfZGlnaXRfbmF0IiwiY2FtbF9maW5hbF9yZWxlYXNlIiwiY2FtbF9qc190b19hcnJheSIsImNhbWxfZ3JfcGxvdCIsImNvbG9yIiwiY2FtbF9ieXRlc19zZXQ2NCIsImk2NCIsImNhbWxfYnl0ZXNfc2V0MTYiLCJpMTYiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX2ZpbGxfYnl0ZXMiLCJjYW1sX2ZpbGxfc3RyaW5nIiwiY2FtbF9nY19tYWpvciIsImNhbWxfbGV4X2FycmF5IiwiY2FtbF9sZXhfZW5naW5lIiwidGJsIiwic3RhcnRfc3RhdGUiLCJsZXhidWYiLCJsZXhfYnVmZmVyIiwibGV4X2J1ZmZlcl9sZW4iLCJsZXhfc3RhcnRfcG9zIiwibGV4X2N1cnJfcG9zIiwibGV4X2xhc3RfcG9zIiwibGV4X2xhc3RfYWN0aW9uIiwibGV4X2VvZl9yZWFjaGVkIiwibGV4X2Jhc2UiLCJsZXhfYmFja3RyayIsImxleF9kZWZhdWx0IiwibGV4X3RyYW5zIiwibGV4X2NoZWNrIiwic3RhdGUiLCJiYXNlIiwiYmFja3RyayIsImNhbWxfc3lzX2ZpbGVfZXhpc3RzIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfYXJyYXlfc3ViIiwiYTIiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9ncl9zaXplX3giLCJCYXNlX2ludF9tYXRoX2ludDMyX2NseiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4iLCJjYW1sX2Nvc2hfZmxvYXQiLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfd2Vha19jaGVjayIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9ncl90ZXh0X3NpemUiLCJ0eHQiLCJjYW1sX2xleF9ydW5fbWVtIiwibWVtIiwiY3Vycl9wb3MiLCJjYW1sX2xleF9ydW5fdGFnIiwiY2FtbF9uZXdfbGV4X2VuZ2luZSIsImxleF9tZW0iLCJsZXhfYmFzZV9jb2RlIiwibGV4X2JhY2t0cmtfY29kZSIsImxleF9kZWZhdWx0X2NvZGUiLCJsZXhfdHJhbnNfY29kZSIsImxleF9jaGVja19jb2RlIiwibGV4X2NvZGUiLCJwY19vZmYiLCJwc3RhdGUiLCJiYXNlX2NvZGUiLCJjYW1sX2JhX3VpbnQ4X3NldDY0IiwiY29yZV9rZXJuZWxfZ2NfbWlub3Jfd29yZHMiLCJjYW1sX3N5c19leGVjdXRhYmxlX25hbWUiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbWxfZmx1c2giLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY29tcGFyZV9uYXRfcmVhbCIsImNhbWxfZ2Nfc2V0IiwiY2FtbF9qc19nZXQiLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2hhc2giLCJzZWVkIiwicXVldWUiLCJyZCIsIndyIiwiaGgiLCJCYXNlX2hhc2hfc3RyaW5nIiwiY2FtbF9nY19jb21wYWN0aW9uIiwiYmluX3Byb3RfYmxpdF9mbG9hdF9hcnJheV9idWZfc3R1YiIsImZsb2F0NjQiLCJmbG9hdDY0X3VpbnQ4IiwiY2FtbF9zdGRfb3V0cHV0Iiwic2xlbiIsImpzX3ByaW50X3N0ZGVyciIsImpzX3ByaW50X3N0ZG91dCIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpbmZvIiwiY2FtbF9zeXNfb3BlbiIsIl9wZXJtcyIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIiwiY2hhbm5lbCIsImNhbWxfcmFpc2VfZW5kX29mX2ZpbGUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9tZDVfYnl0ZXMiLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJtZDUiLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX3N5c19jbG9zZSIsImNhbWxfbWxfY2xvc2VfY2hhbm5lbCIsImNvcmVfbWQ1X2ZkIiwiaWMiLCJjYW1sX3dlYWtfZ2V0IiwiY2FtbF9lcGhlX2dldF9rZXkiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhIiwid2luX2NsZWFudXAiLCJjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZSIsImV4biIsImZvcmNlIiwiQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWIiLCJleHBvbmVudCIsIm9uZSIsIm11bCIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsInVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsImNhbWxfanNfc2V0IiwiY29yZV9rZXJuZWxfZ2NfbWFqb3JfcGx1c19taW5vcl93b3JkcyIsImNhbWxfYXJyYXlfZ2V0IiwiYmluX3Byb3RfYmxpdF9ieXRlc19idWZfc3R1YiIsImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwidGEiLCJiaW5fcHJvdF9ibGl0X2J1Zl9zdHViIiwiY2FtbF9tbF9zZWVrX2luXzY0IiwiY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IiwiY2FtbF9ub3RlcXVhbCIsImNhbWxfc3lzX2NvbnN0X2ludF9zaXplIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2siLCJjYW1sX2lzX2pzIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdCIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJiaWdzdHJpbmdfZGVzdHJveV9zdHViIiwidl9ic3RyIiwiYmlnc3RyaW5nX3JlYWxsb2MiLCJuZXdfZGF0YSIsIm5ld19iaWdzdHJpbmciLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsIkJhc2VfYW1fdGVzdGluZyIsImNhbWxfYnl0ZXNfbGVzc3RoYW4iLCJjYW1sX2dyX2ZpbGxfcG9seSIsImFyIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9tbF9pbnB1dF9pbnQiLCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSIsIm50aF9kaWdpdF9uYXQiLCJjYW1sX2FycmF5X2JsaXQiLCJhMSIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibTMiLCJtYW50aXNzYSIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4iLCJjYW1sX2xpc3RfdG9fanNfYXJyYXkiLCJjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsIm5vX3NoYXJpbmciLCJjbG9zdXJlcyIsImludGVybl9vYmpfdGFibGUiLCJtZW1vIiwiZXhpc3Rpbmdfb2Zmc2V0IiwiZXh0ZXJuX3JlYyIsIm9wcyIsInN6XzMyXzY0IiwiaGVhZGVyX3BvcyIsIm9sZF9wb3MiLCJ0eXBlX29mX3YiLCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmciLCJjYW1sX3JhaXNlX25vdF9hX2RpciIsImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kIiwiY21kIiwiY29yZV9rZXJuZWxfZ2NfbWFqb3Jfd29yZHMiLCJ1bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJkZXNlcmlhbGl6ZV9uYXQiLCJpbml0aWFsaXplX25hdCIsImJpZ3N0cmluZ19tZW1jbXBfc3R1YiIsInZfczEiLCJ2X3MxX3BvcyIsInZfczIiLCJ2X3MyX3BvcyIsInZfbGVuIiwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyIsImNhbWxfY29weXNpZ25fZmxvYXQiLCJjYW1sX2dyX3NldF90ZXh0X3NpemUiLCJjYW1sX2JhX3NldF9nZW5lcmljIiwiY2FtbF9lcGhlX3NldF9rZXkiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXQiLCJiaXRzIiwiY2FtbF9ncl9zaXplX3kiLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9pbnQ2NF9tdWwiLCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiTWxTdHJpbmdSZWFkZXIiLCJjYW1sX2Zsb2F0X29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciIsIl9tYWdpYyIsIl9ibG9ja19sZW4iLCJudW1fb2JqZWN0cyIsIl9zaXplXzMyIiwiX3NpemVfNjQiLCJvYmpfY291bnRlciIsImludGVybl9yZWMiLCJoZWFkZXIiLCJleHBlY3RlZF9zaXplIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIiwiY2FtbF9iYV9jcmVhdGUiLCJkaW1zX21sIiwiYmlnc3RyaW5nX2FsbG9jIiwiXyIsImNhbWxfc3RyaW5nX2dldCIsInJlX21hdGNoIiwicmVfd29yZF9sZXR0ZXJzIiwib3Bjb2RlcyIsImlzX3dvcmRfbGV0dGVyIiwiaW5fYml0c2V0IiwicmVfbWF0Y2hfaW1wbCIsInBhcnRpYWwiLCJwcm9nIiwiY3Bvb2wiLCJub3JtdGFibGUiLCJudW1ncm91cHMiLCJudW1yZWdpc3RlcnMiLCJzdGFydGNoYXJzIiwicGMiLCJxdWl0IiwiZ3JvdXBzIiwicmVfcmVnaXN0ZXIiLCJiYWNrdHJhY2siLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwib3AiLCJzYXJnIiwidWFyZyIsImdyb3VwIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJuZXdfZGltcyIsImNhbWxfZ2NfZnVsbF9tYWpvciIsImNhbWxfYnl0ZXNfc2V0MzIiLCJpMzIiLCJjYW1sX2dyX3NpZ2lvX3NpZ25hbCIsImNhbWxfYmFfdWludDhfc2V0MzIiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCIsImNhbWxfc2lnbmJpdF9mbG9hdCIsImNhbWxfZ3JfY3VycmVudF94IiwiY2FtbF9ncl9zZXRfbGluZV93aWR0aCIsImNhbWxfZ3Jfc2V0X2ZvbnQiLCJjYW1sX2dyX3NldF9jb2xvciIsImNvbnZlcnQiLCJjX3N0ciIsImNhbWxfZ3JfbW92ZXRvIiwiY2FtbF9ncl9yZXNpemVfd2luZG93IiwiY2FtbF9ncl9zdGF0ZV9pbml0IiwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IiwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfanNfdHlwZW9mIiwiY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UiLCJidCIsIkJhc2VfaW50X21hdGhfaW50MzJfY3R6IiwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6IiwiZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2FmdGVyX3Rlc3QiLCJjYW1sX2dyX2xpbmV0byIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludCIsImNhbWxfY3JlYXRlX3N0cmluZyIsIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2NseiIsImNhbWxfYmFfc2V0XzEiLCJiaWdzdHJpbmdfbWVtc2V0X3N0dWIiLCJ2X3BvcyIsInZfY2hhciIsImNvcmVfa2VybmVsX3RpbWVfbnNfZm9ybWF0IiwidGltZSIsImZvcm1hdGpzIiwianN0cmluZyIsImNhbWxfb2JqX2R1cCIsImNhbWxfd2Vha19nZXRfY29weSIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwic3RyaW5nIiwianNzdHJpbmciLCJjYW1sX21sX291dHB1dCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwidW5pdCIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyIsImludGVybmFsaGFzaF9mb2xkX2JpZ3N0cmluZyIsIkJhc2VfaW50X21hdGhfaW50NjRfY2x6IiwiY2FtbF9hcnJheV9hcHBlbmQiLCJsMSIsImwyIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwiLCJjYW1sX2pzX2V4cHIiLCJjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsIl91bml0IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMiLCJjYW1sX2hhc2hfdW5pdl9wYXJhbSIsImhhc2hfYWNjdSIsImhhc2hfYXV4IiwianNieXRlcyIsImNhbWxfc3RyaW5nX2VxdWFsIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwicmVfcmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwiY3VyIiwic3RhcnQiLCJlbmQiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUiLCJjYW1sX3RvX2pzX3N0cmluZyIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X29mX3N0cmluZyIsImJhc2U2NCIsInRocmVzaG9sZCIsInJlX3NlYXJjaF9mb3J3YXJkIiwiY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX21ha2VfdmVjdCIsImNhbWxfbWxfc2Vla19pbiIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9tbF9vdXRwdXRfY2hhciIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9tbF9pbnB1dF9jaGFyIiwiY2FtbF9qc192YXIiLCJjYW1sX3RydW5jX2Zsb2F0IiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjQiLCJjb3JlX2tlcm5lbF9nY19wcm9tb3RlZF93b3JkcyIsImNhbWxfaXNfcHJpbnRhYmxlIiwiY2FtbF9lcXVhbCIsInJlX3BhcnRpYWxfbWF0Y2giLCJjYW1sX3N5c19yYW5kb21fc2VlZCIsIm5vdyIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjb3JlX2tlcm5lbF9nY19oZWFwX2NodW5rcyIsImNhbWxfanNfZXF1YWxzIiwiYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IiwiY2FtbF9ncl9hcmNfYXV4IiwiY3R4IiwiY3giLCJjeSIsInJ5IiwicngiLCJyb3QiLCJ4UG9zIiwieVBvcyIsInhQb3NfcHJldiIsInlQb3NfcHJldiIsInNwYWNlIiwiZGVsdGEiLCJjYW1sX2dyX2ZpbGxfYXJjIiwiY2FtbF9iYV9zbGljZSIsIm51bV9pbmRzIiwic3ViX2RpbXMiLCJjYW1sX21hcnNoYWxfZGF0YV9zaXplIiwiZ2V0MzIiLCJjYW1sX2lucHV0X3ZhbHVlIiwiY2FtbF9iYV9raW5kIiwiY2FtbF9vdXRfY2hhbm5lbF9wb3NfZmQiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjb3JlX2FycmF5X3Vuc2FmZV9pbnRfYmxpdCIsImNvbXBhcmVfZGlnaXRzX25hdCIsImNhbWxfbWxfaW5wdXQiLCJjYW1sX2dyX3dhaXRfZXZlbnQiLCJfZXZsIiwiY2FtbF9ncl9zaWdpb19oYW5kbGVyIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwidW5peF9nbXRpbWUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwidW5peF90aW1lIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImNvcmVfa2VybmVsX2djX21pbm9yX2NvbGxlY3Rpb25zIiwiYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciIsImFiIiwiY2FtbF9tb2QiLCJjYW1sX2JhX2luaXQiLCJyZV9zdHJpbmdfbWF0Y2giLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2dyX2R1bXBfaW1hZ2UiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImNhbWxfZm9ybWF0X2Zsb2F0IiwidG9GaXhlZCIsImRwIiwicHJlYyIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJCYXNlX2ludF9tYXRoX2ludF9jbHoiLCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX2RpdiIsImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5IiwiY2FtbF9tZW1wcm9mX3N0YXJ0IiwicmF0ZSIsInN0YWNrX3NpemUiLCJ0cmFja2VyIiwiY2FtbF9zeXNfZ2V0X2FyZ3YiLCJjYW1sX2pzX3RvX2Jvb2wiLCJjYW1sX2dyX2NyZWF0ZV9pbWFnZSIsImNhbWxfZXBoZV9nZXRfa2V5X2NvcHkiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCIsImNhbWxfcmVnaXN0ZXJfZ2xvYmFsIiwibmFtZV9vcHQiLCJtdWx0X25hdCIsImxlbjMiLCJzcXVhcmVfbmF0IiwiY29yZV9tZDVfZGlnZXN0X3N1YmJpZ3N0cmluZyIsInJlczIiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImJpbl9wcm90X2JsaXRfYnVmX2J5dGVzX3N0dWIiLCJjYW1sX2pzX2dldF9jb25zb2xlIiwiY2FtbF9yb3VuZF9mbG9hdCIsImNhbWxfb2pzX25ld19hcnIiLCJGIiwiY29tcGxlbWVudF9uYXQiLCJjYW1sX2pzX3JlZ2V4cHMiLCJjYW1sX2pzX2h0bWxfZXNjYXBlIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc2luaF9mbG9hdCIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIiwibGFuZF9kaWdpdF9uYXQiLCJjYW1sX2ludDY0X21vZCIsImNhbWxfb2JqX3NldF90YWciLCJjYW1sX2NyZWF0ZV9maWxlX2V4dGVybiIsImNhbWxfaW50MzJfYnN3YXAiLCJ3aW5fc3RhcnR1cCIsImNhbWxfYmFfc2V0XzMiLCJjYW1sX2pzX2luc3RhbmNlb2YiLCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJkaWdpdCIsImNhbWxfc3RyaW5nX3NldDY0IiwiY2FtbF9ncl9zdGF0ZV9jcmVhdGUiLCJjYW52YXMiLCJjb250ZXh0IiwiY2FtbF9qc193cmFwX2NhbGxiYWNrIiwiY2FtbF9ncl9kcmF3X2FyYyIsImNhbWxfYmFfbWFwX2ZpbGUiLCJ2ZmQiLCJzaGFyZWQiLCJjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlIiwiYXJnbiIsImNhbWxfYmFfY3JlYXRlX2Zyb20iLCJkYXRhMSIsImRhdGEyIiwianN0eXAiLCJjYW1sX3RhbmhfZmxvYXQiLCJCYXNlX2ludF9tYXRoX2ludF9jdHoiLCJiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWIiLCJjYW1sX2dyX2RyYXdfc3RyIiwiZHgiLCJjYW1sX2dyX2RyYXdfc3RyaW5nIiwiY2FtbF9ncl9kcmF3X2NoYXIiLCJjYW1sX3VubW91bnQiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIiwiY2FtbF9tbF9wb3NfaW5fNjQiLCJjYW1sX2dyX2RyYXdfaW1hZ2UiLCJpbWFnZSIsImNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIiwiX2NoYW5uZWwiLCJjYW1sX3N0cmluZ19zZXQiLCJCYXNlX2ludF9tYXRoX2ludDY0X2N0eiIsImlzX3plcm8iLCJsYW5kIiwic21hbGxfaW50NjQiLCJjYW1sX21sX3Bvc19vdXQiLCJjb3JlX2FycmF5X3Vuc2FmZV9mbG9hdF9ibGl0IiwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX2dyX3JlbWVtYmVyX21vZGUiLCJCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZSIsImNhbWxfYnN3YXAxNiIsImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlIiwibW9kZSIsImNhbWxfZmluYWxfcmVnaXN0ZXIiLCJjYW1sX2dyX2RyYXdfcmVjdCIsImNvcmVfa2VybmVsX2djX2NvbXBhY3Rpb25zIiwiY2FtbF9zdHJpbmdfZ2V0MTYiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZXBoZV9ibGl0X2tleSIsIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zIiwiY2FtbF9vYmpfdGFnIiwiRnVuY3Rpb24iLCJjYW1sX2JhX3RvX3R5cGVkX2FycmF5IiwiY2FtbF9qc19leHBvcnRfdmFyIiwiY2FtbF9ieXRlc19nZXQzMiIsImNhbWxfZnJleHBfZmxvYXQiLCJuZWciLCJDb3JlX2tlcm5lbF9oZWFwX2Jsb2NrX2lzX2hlYXBfYmxvY2siLCJiaWdzdHJpbmdfYmxpdF9ieXRlc19iaWdzdHJpbmdfc3R1YiIsImNvcmVfa2VybmVsX2djX21ham9yX2NvbGxlY3Rpb25zIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJjb3JlX2tlcm5lbF9nY190b3BfaGVhcF93b3JkcyIsIkJhc2VfaGFzaF9kb3VibGUiLCJjYW1sX2pzX25ldyIsImNhbWxfZ3JfY3VycmVudF95IiwiY2FtbF9mb3JtYXRfaW50IiwiY2FtbF9vYmpfdHJ1bmNhdGUiLCJjYW1sX2pzX3RvX3N0cmluZyIsImlzX2RpZ2l0X29kZCIsImNhbWxfcnVudGltZV92YXJpYW50IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2dyX29wZW5fZ3JhcGgiLCJnZXQiLCJzcGVjcyIsInRhcmdldCIsInN0YXR1cyIsIndpbiIsInRpdGxlIiwiYm9keSIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIiwiY29yZV9rZXJuZWxfZ2NfaGVhcF93b3JkcyIsImNhbWxfbG9nMXBfZmxvYXQiLCJtc190b19uYW5vIiwidGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvIiwibXMiLCJtc19pNjMiLCJjYW1sX2ludDY0X29yIiwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZCIsImxvcl9kaWdpdF9uYXQiLCJjYW1sX2dyX2JsaXRfaW1hZ2UiLCJpbTIiLCJjYW1sX2dyX3dpbmRvd19pZCIsImNhbWxfanNfb25faWUiLCJ1YSIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHQiLCJjYW1sX2JhX2xheW91dCIsImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIiwiY2FtbF9hcnJheV9zZXQiLCJuZXd2YWwiLCJjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbCIsInNldF9kaWdpdF9uYXQiLCJjYW1sX3VwZGF0ZV9kdW1teSIsImNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2QiLCJyZWFsIiwicGFyZW50IiwiY2FtbF9ncl9kb2Nfb2Zfc3RhdGUiLCJjYW1sX21sX291dHB1dF9pbnQiLCJjYW1sX29ial93aXRoX3RhZyIsImNhbWxfaW5pdGlhbF90aW1lIiwiY2FtbF9zeXNfdGltZSIsImNhbWxfbWxfY2hhbm5lbF9zaXplIiwiYmluX3Byb3RfYmxpdF9zdHJpbmdfYnVmX3N0dWIiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9iYV9maWxsIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19zZXQzMiIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiRVJSQ09ERSIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX2FycmF5X2ZpbGwiLCJiaWdzdHJpbmdfYmxpdF9zdHViIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnQiLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcmVhZF9maWxlX2NvbnRlbnQiLCJjYW1sX2pzX3RvX2Zsb2F0Il0sInNvdXJjZXMiOlsiL1VzZXJzL2p2YW5icmllc2VuLy5vcGFtL2RlZmF1bHQvbGliL2NvcmVfa2VybmVsL3N0cmZ0aW1lLmpzIiwiL1VzZXJzL2p2YW5icmllc2VuLy5vcGFtL2RlZmF1bHQvbGliL3ZpcnR1YWxfZG9tL3ZpcnR1YWxkb20uY29tcGlsZWQuanMiLCIvVXNlcnMvanZhbmJyaWVzZW4vLm9wYW0vZGVmYXVsdC9saWIvdmlydHVhbF9kb20vaG9va3MuanMiLCIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8rZnNfbm9kZS5qcyIsIi9idWlsdGluLytuYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8rbWFyc2hhbC5qcyIsIi9idWlsdGluLytpby5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytiaWdhcnJheS5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvVXNlcnMvanZhbmJyaWVzZW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZV9iaWdzdHJpbmcvcnVudGltZS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytpbnRzLmpzIiwiL2J1aWx0aW4vK2hhc2guanMiLCIvVXNlcnMvanZhbmJyaWVzZW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9iYXNlX2ludGVybmFsaGFzaF90eXBlcy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK3BhcnNpbmcuanMiLCIvYnVpbHRpbi8ranNsaWJfanNfb2Zfb2NhbWwuanMiLCIvYnVpbHRpbi8rdW5peC5qcyIsIi9idWlsdGluLytjb21wYXJlLmpzIiwiL2J1aWx0aW4vK2ludGVybmFsTW9kLmpzIiwiL1VzZXJzL2p2YW5icmllc2VuLy5vcGFtL2RlZmF1bHQvbGliL3BweF9leHBlY3QvY29sbGVjdG9yL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL1VzZXJzL2p2YW5icmllc2VuLy5vcGFtL2RlZmF1bHQvbGliL2Jpbl9wcm90L3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rYmFja3RyYWNlLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9Vc2Vycy9qdmFuYnJpZXNlbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rd2Vhay5qcyIsIi9Vc2Vycy9qdmFuYnJpZXNlbi8ub3BhbS9kZWZhdWx0L2xpYi9jb3JlX2tlcm5lbC9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLWNzdHJ1Y3QuanMiLCIvVXNlcnMvanZhbmJyaWVzZW4vLm9wYW0vZGVmYXVsdC9saWIvdGltZV9ub3cvcnVudGltZS5qcyJdLCJtYXBwaW5ncyI6Ijs7S0FXRTtRQUVFO1NB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LElBQUU7U0FDRixJQUFFLGtCQUFrQjBQO1FBQzdCLFlBQVlvSCxNQUFNcEg7UUFDbEIsT0FBTyxxQkFBcUJvSDtNQUU5Qix3QkFBd0I3ZCxLQUMxQjtJaUI1T0EsU0FBU2s5QyxpQkFBaUJoeEMsR0FBSyxPQUFPQSxDQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VSIsInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBzdHJmdGltZVxuLy8gZ2l0aHViLmNvbS9zYW1zb25qcy9zdHJmdGltZVxuLy8gQF9zanNcbi8vXG4vLyBDb3B5cmlnaHQgMjAxMCAtIDIwMTUgU2FtaSBTYW1odXJpIDxzYW1pQHNhbWh1cmkubmV0PlxuLy9cbi8vIE1JVCBMaWNlbnNlXG4vLyBodHRwOi8vc2pzLm1pdC1saWNlbnNlLm9yZ1xuLy9cblxuOyhmdW5jdGlvbigpIHtcblxuICAgIHZhciBEZWZhdWx0TG9jYWxlID0ge1xuICAgICAgICAgICAgZGF5czogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICAgICAgICAgICAgc2hvcnREYXlzOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICAgICAgICAgbW9udGhzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICAgICAgICAgIHNob3J0TW9udGhzOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gICAgICAgICAgICBBTTogJ0FNJyxcbiAgICAgICAgICAgIFBNOiAnUE0nLFxuICAgICAgICAgICAgYW06ICdhbScsXG4gICAgICAgICAgICBwbTogJ3BtJyxcbiAgICAgICAgICAgIGZvcm1hdHM6IHtcbiAgICAgICAgICAgICAgICBEOiAnJW0vJWQvJXknLFxuICAgICAgICAgICAgICAgIEY6ICclWS0lbS0lZCcsXG4gICAgICAgICAgICAgICAgUjogJyVIOiVNJyxcbiAgICAgICAgICAgICAgICBUOiAnJUg6JU06JVMnLFxuICAgICAgICAgICAgICAgIFg6ICclVCcsXG4gICAgICAgICAgICAgICAgYzogJyVhICViICVkICVYICVZJyxcbiAgICAgICAgICAgICAgICByOiAnJUk6JU06JVMgJXAnLFxuICAgICAgICAgICAgICAgIHY6ICclZS0lYi0lWScsXG4gICAgICAgICAgICAgICAgeDogJyVEJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0U3RyZnRpbWUgPSBuZXcgU3RyZnRpbWUoRGVmYXVsdExvY2FsZSwgMCwgZmFsc2UpLFxuICAgICAgICBpc0NvbW1vbkpTID0gdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICAgIG5hbWVzcGFjZTtcblxuICAgIC8vIENvbW1vbkpTIC8gTm9kZSBtb2R1bGVcbiAgICBpZiAoaXNDb21tb25KUykge1xuICAgICAgICBuYW1lc3BhY2UgPSBtb2R1bGUuZXhwb3J0cyA9IGFkYXB0ZWRTdHJmdGltZTtcbiAgICAgICAgbmFtZXNwYWNlLnN0cmZ0aW1lID0gZGVwcmVjYXRlZFN0cmZ0aW1lO1xuICAgICAgICBpZihqb29fZ2xvYmFsX29iamVjdCkgam9vX2dsb2JhbF9vYmplY3Quc3RyZnRpbWUgPSBhZGFwdGVkU3RyZnRpbWU7XG4gICAgfVxuICAgIC8vIEJyb3dzZXJzIGFuZCBvdGhlciBlbnZpcm9ubWVudHNcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gR2V0IHRoZSBnbG9iYWwgb2JqZWN0LiBXb3JrcyBpbiBFUzMsIEVTNSwgYW5kIEVTNSBzdHJpY3QgbW9kZS5cbiAgICAgICAgbmFtZXNwYWNlID0gam9vX2dsb2JhbF9vYmplY3QgfHwgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB8fCAoMSxldmFsKSgndGhpcycpOyB9KCkpO1xuICAgICAgICBuYW1lc3BhY2Uuc3RyZnRpbWUgPSBhZGFwdGVkU3RyZnRpbWU7XG4gICAgfVxuXG4gICAgLy8gRGVwcmVjYXRlZCBBUEksIHRvIGJlIHJlbW92ZWQgaW4gdjEuMFxuICAgIHZhciBfcmVxdWlyZSA9IGlzQ29tbW9uSlMgPyBcInJlcXVpcmUoJ3N0cmZ0aW1lJylcIiA6IFwic3RyZnRpbWVcIjtcbiAgICB2YXIgX2RlcHJlY2F0aW9uV2FybmluZ3MgPSB7fTtcbiAgICBmdW5jdGlvbiBkZXByZWNhdGlvbldhcm5pbmcobmFtZSwgaW5zdGVhZCkge1xuICAgICAgICBpZiAoIV9kZXByZWNhdGlvbldhcm5pbmdzW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXSBcIiArIG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiAxLjAuIEluc3RlYWQsIHVzZSBgXCIgKyBpbnN0ZWFkICsgXCJgLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9kZXByZWNhdGlvbldhcm5pbmdzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5hbWVzcGFjZS5zdHJmdGltZVRaID0gZGVwcmVjYXRlZFN0cmZ0aW1lVFo7XG4gICAgbmFtZXNwYWNlLnN0cmZ0aW1lVVRDID0gZGVwcmVjYXRlZFN0cmZ0aW1lVVRDO1xuICAgIG5hbWVzcGFjZS5sb2NhbGl6ZWRTdHJmdGltZSA9IGRlcHJlY2F0ZWRTdHJmdGltZUxvY2FsaXplZDtcblxuICAgIC8vIEFkYXB0IHRoZSBvbGQgQVBJIHdoaWxlIHByZXNlcnZpbmcgdGhlIG5ldyBBUEkuXG4gICAgZnVuY3Rpb24gYWRhcHRGb3J3YXJkcyhmbikge1xuICAgICAgICBmbi5sb2NhbGl6ZSA9IGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZS5iaW5kKGRlZmF1bHRTdHJmdGltZSk7XG4gICAgICAgIGZuLnRpbWV6b25lID0gZGVmYXVsdFN0cmZ0aW1lLnRpbWV6b25lLmJpbmQoZGVmYXVsdFN0cmZ0aW1lKTtcbiAgICAgICAgZm4udXRjID0gZGVmYXVsdFN0cmZ0aW1lLnV0Yy5iaW5kKGRlZmF1bHRTdHJmdGltZSk7XG4gICAgfVxuXG4gICAgYWRhcHRGb3J3YXJkcyhhZGFwdGVkU3RyZnRpbWUpO1xuICAgIGZ1bmN0aW9uIGFkYXB0ZWRTdHJmdGltZShmbXQsIGQsIGxvY2FsZSkge1xuICAgICAgICAvLyBkIGFuZCBsb2NhbGUgYXJlIG9wdGlvbmFsLCBjaGVjayBpZiB0aGlzIGlzIChmb3JtYXQsIGxvY2FsZSlcbiAgICAgICAgaWYgKGQgJiYgZC5kYXlzKSB7XG4gICAgICAgICAgICBsb2NhbGUgPSBkO1xuICAgICAgICAgICAgZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiKGZvcm1hdCwgW2RhdGVdLCBbbG9jYWxlXSlgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKTsgcyhmb3JtYXQsIFtkYXRlXSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gbG9jYWxlID8gZGVmYXVsdFN0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSkgOiBkZWZhdWx0U3RyZnRpbWU7XG4gICAgICAgIHJldHVybiBzdHJmdGltZShmbXQsIGQpO1xuICAgIH1cblxuICAgIGFkYXB0Rm9yd2FyZHMoZGVwcmVjYXRlZFN0cmZ0aW1lKTtcbiAgICBmdW5jdGlvbiBkZXByZWNhdGVkU3RyZnRpbWUoZm10LCBkLCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZShmb3JtYXQsIFtkYXRlXSwgW2xvY2FsZV0pYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZShmb3JtYXQsIFtkYXRlXSlgXCIsIF9yZXF1aXJlICsgXCIoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpIDogZGVmYXVsdFN0cmZ0aW1lO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVkU3RyZnRpbWVUWihmbXQsIGQsIGxvY2FsZSwgdGltZXpvbmUpIHtcbiAgICAgICAgLy8gbG9jYWxlIGlzIG9wdGlvbmFsLCBjaGVjayBpZiB0aGlzIGlzIChmb3JtYXQsIGRhdGUsIHRpbWV6b25lKVxuICAgICAgICBpZiAoKHR5cGVvZiBsb2NhbGUgPT0gJ251bWJlcicgfHwgdHlwZW9mIGxvY2FsZSA9PSAnc3RyaW5nJykgJiYgdGltZXpvbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZXpvbmUgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLnN0cmZ0aW1lVFooZm9ybWF0LCBkYXRlLCBsb2NhbGUsIHR6KWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpLnRpbWV6b25lKHR6KTsgcyhmb3JtYXQsIFtkYXRlXSlgIG9yIGB2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpOyBzLnRpbWV6b25lKHR6KShmb3JtYXQsIFtkYXRlXSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLnN0cmZ0aW1lVFooZm9ybWF0LCBkYXRlLCB0eilgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIudGltZXpvbmUodHopOyBzKGZvcm1hdCwgW2RhdGVdKWAgb3IgYFwiICsgX3JlcXVpcmUgKyBcIi50aW1lem9uZSh0eikoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gKGxvY2FsZSA/IGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpIDogZGVmYXVsdFN0cmZ0aW1lKS50aW1lem9uZSh0aW1lem9uZSk7XG4gICAgICAgIHJldHVybiBzdHJmdGltZShmbXQsIGQpO1xuICAgIH1cblxuICAgIHZhciB1dGNTdHJmdGltZSA9IGRlZmF1bHRTdHJmdGltZS51dGMoKTtcbiAgICBmdW5jdGlvbiBkZXByZWNhdGVkU3RyZnRpbWVVVEMoZm10LCBkLCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVVUQyhmb3JtYXQsIGRhdGUsIGxvY2FsZSlgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKS51dGMoKTsgcyhmb3JtYXQsIFtkYXRlXSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLnN0cmZ0aW1lVVRDKGZvcm1hdCwgW2RhdGVdKWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi51dGMoKTsgcyhmb3JtYXQsIFtkYXRlXSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gbG9jYWxlID8gdXRjU3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IHV0Y1N0cmZ0aW1lO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQobG9jYWxlKSB7XG4gICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemVkU3RyZnRpbWUobG9jYWxlKWBcIiwgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpXCIpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFN0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSk7XG4gICAgfVxuICAgIC8vIEVuZCBvZiBkZXByZWNhdGVkIEFQSVxuXG4gICAgLy8gUG9seWZpbGwgRGF0ZS5ub3cgZm9yIG9sZCBicm93c2Vycy5cbiAgICBpZiAodHlwZW9mIERhdGUubm93ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIERhdGUubm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICtuZXcgRGF0ZSgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFN0cmZ0aW1lKGxvY2FsZSwgY3VzdG9tVGltZXpvbmVPZmZzZXQsIHVzZVV0Y1RpbWV6b25lKSB7XG4gICAgICAgIHZhciBfbG9jYWxlID0gbG9jYWxlIHx8IERlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICBfY3VzdG9tVGltZXpvbmVPZmZzZXQgPSBjdXN0b21UaW1lem9uZU9mZnNldCB8fCAwLFxuICAgICAgICAgICAgX3VzZVV0Y0Jhc2VkRGF0ZSA9IHVzZVV0Y1RpbWV6b25lIHx8IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyB3ZSBzdG9yZSB1bml4IHRpbWVzdGFtcCB2YWx1ZSBoZXJlIHRvIG5vdCBjcmVhdGUgbmV3IERhdGUoKSBlYWNoIGl0ZXJhdGlvbiAoZWFjaCBtaWxsaXNlY29uZClcbiAgICAgICAgICAgIC8vIERhdGUubm93KCkgaXMgMiB0aW1lcyBmYXN0ZXIgdGhhbiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAvLyB3aGlsZSBtaWxsaXNlY29uZCBwcmVjaXNlIGlzIGVub3VnaCBoZXJlXG4gICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIHZlcnkgaGVscGZ1bCB3aGVuIHN0cmZ0aW1lIHRyaWdnZXJlZCBhIGxvdCBvZiB0aW1lcyBvbmUgYnkgb25lXG4gICAgICAgICAgICBfY2FjaGVkRGF0ZVRpbWVzdGFtcCA9IDAsXG4gICAgICAgICAgICBfY2FjaGVkRGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBfc3RyZnRpbWUoZm9ybWF0LCBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lc3RhbXAgPiBfY2FjaGVkRGF0ZVRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBfY2FjaGVkRGF0ZVRpbWVzdGFtcCA9IGN1cnJlbnRUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIF9jYWNoZWREYXRlID0gbmV3IERhdGUoX2NhY2hlZERhdGVUaW1lc3RhbXApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IF9jYWNoZWREYXRlVGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdXNlVXRjQmFzZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBob3cgdG8gYXZvaWQgZHVwbGljYXRpb24gb2YgZGF0ZSBpbnN0YW50aWF0aW9uIGZvciB1dGMgaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRpZWQgdG8gZ2V0VGltZXpvbmVPZmZzZXQgb2YgdGhlIGN1cnJlbnQgZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgX2NhY2hlZERhdGUgPSBuZXcgRGF0ZShfY2FjaGVkRGF0ZVRpbWVzdGFtcCArIGdldFRpbWVzdGFtcFRvVXRjT2Zmc2V0Rm9yKF9jYWNoZWREYXRlKSArIF9jdXN0b21UaW1lem9uZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0ZSA9IF9jYWNoZWREYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3VzZVV0Y0Jhc2VkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihkYXRlKSArIF9jdXN0b21UaW1lem9uZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX3Byb2Nlc3NGb3JtYXQoZm9ybWF0LCBkYXRlLCBfbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX3Byb2Nlc3NGb3JtYXQoZm9ybWF0LCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdFN0cmluZyA9ICcnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBudWxsLFxuICAgICAgICAgICAgICAgIGlzSW5TY29wZSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZvcm1hdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRUWiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENoYXJDb2RlID0gZm9ybWF0LmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNJblNjb3BlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICctJ1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gJ18nXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gOTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAnMCdcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJDb2RlID09PSA0OCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICc6J1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDU4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkVFopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXSBkZXRlY3RlZCB1c2Ugb2YgdW5zdXBwb3J0ZWQgJTo6IG9yICU6OjogbW9kaWZpZXJzIHRvIHN0cmZ0aW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFRaID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudENoYXJDb2RlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4YW1wbGVzIGZvciBuZXcgRGF0ZSgwKSBpbiBHTVRcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ1RodXJzZGF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuZGF5c1tkYXRlLmdldERheSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0phbnVhcnknXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdCJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5tb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzE5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihNYXRoLmZsb29yKGRhdGUuZ2V0RnVsbFllYXIoKSAvIDEwMCksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEvMDEvNzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLkQsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzE5NzAtMDEtMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdGJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLkYsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDcyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldEhvdXJzKCksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTInXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdJJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGhvdXJzMTIoZGF0ZS5nZXRIb3VycygpKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwzKE1hdGguZmxvb3IodGltZXN0YW1wICUgMTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0TWludXRlcygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ2FtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnUCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDgwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IGxvY2FsZS5hbSA6IGxvY2FsZS5wbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnUic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDgyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5SLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRTZWNvbmRzKCksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDA6MDA6MDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLlQsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMih3ZWVrTnVtYmVyKGRhdGUsICdzdW5kYXknKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1cnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIod2Vla051bWJlcihkYXRlLCAnbW9uZGF5JyksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTY6MDA6MDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdYJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLlgsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzE5NzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdZJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0dNVCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3VzZVV0Y0Jhc2VkRGF0ZSAmJiBfY3VzdG9tVGltZXpvbmVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFwiR01UXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXhtZSBvcHRpbWl6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHpTdHJpbmcgPSBkYXRlLnRvU3RyaW5nKCkubWF0Y2goL1xcKChbXFx3XFxzXSspXFwpLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSB0elN0cmluZyAmJiB0elN0cmluZ1sxXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdUaHUnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5zaG9ydERheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdKYW4nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5zaG9ydE1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5jLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0RGF0ZSgpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJyAxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXREYXRlKCksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnSmFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLnNob3J0TW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF5ID0gTWF0aC5jZWlsKChkYXRlLmdldFRpbWUoKSAtIHkuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwzKGRheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcgMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2snOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0SG91cnMoKSwgcGFkZGluZyA9PSBudWxsID8gJyAnIDogcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxMidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGhvdXJzMTIoZGF0ZS5nZXRIb3VycygpKSwgcGFkZGluZyA9PSBudWxsID8gJyAnIDogcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0TW9udGgoKSArIDEsIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnXFxuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcoZGF0ZS5nZXREYXRlKCkpICsgb3JkaW5hbChkYXRlLmdldERhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdBTSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGRhdGUuZ2V0SG91cnMoKSA8IDEyID8gbG9jYWxlLkFNIDogbG9jYWxlLlBNO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTI6MDA6MDAgQU0nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5yLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gTWF0aC5mbG9vcih0aW1lc3RhbXAgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ1xcdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnNCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGRheSA9PT0gMCA/IDcgOiBkYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEgLSA3LCBNb25kYXkgaXMgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcgMS1KYW4tMTk3MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLnYsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAwIC0gNiwgU3VuZGF5IGlzIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTIvMzEvNjknXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy54LCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICc3MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3knOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9ICgnJyArIGRhdGUuZ2V0RnVsbFllYXIoKSkuc2xpY2UoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcrMDAwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUgJiYgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBleHRlbmRlZFRaID8gXCIrMDA6MDBcIiA6IFwiKzAwMDBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY3VzdG9tVGltZXpvbmVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IF9jdXN0b21UaW1lem9uZU9mZnNldCAvICg2MCAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IG9mZiA8IDAgPyAnLScgOiAnKyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXAgPSBleHRlbmRlZFRaID8gJzonIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IoTWF0aC5hYnMob2ZmIC8gNjApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbnMgPSBNYXRoLmFicyhvZmYgJSA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBzaWduICsgcGFkVGlsbDIoaG91cnMpICsgc2VwICsgcGFkVGlsbDIobWlucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBmb3JtYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaXNJblNjb3BlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vICclJ1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDM3KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5TY29wZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBmb3JtYXRbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRTdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyZnRpbWUgPSBfc3RyZnRpbWU7XG5cbiAgICAgICAgc3RyZnRpbWUubG9jYWxpemUgPSBmdW5jdGlvbihsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZnRpbWUobG9jYWxlIHx8IF9sb2NhbGUsIF9jdXN0b21UaW1lem9uZU9mZnNldCwgX3VzZVV0Y0Jhc2VkRGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RyZnRpbWUudGltZXpvbmUgPSBmdW5jdGlvbih0aW1lem9uZSkge1xuICAgICAgICAgICAgdmFyIGN1c3RvbVRpbWV6b25lT2Zmc2V0ID0gX2N1c3RvbVRpbWV6b25lT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHVzZVV0Y0Jhc2VkRGF0ZSA9IF91c2VVdGNCYXNlZERhdGU7XG5cbiAgICAgICAgICAgIHZhciB0aW1lem9uZVR5cGUgPSB0eXBlb2YgdGltZXpvbmU7XG4gICAgICAgICAgICBpZiAodGltZXpvbmVUeXBlID09PSAnbnVtYmVyJyB8fCB0aW1lem9uZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdXNlVXRjQmFzZWREYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIElTTyA4NjAxIGZvcm1hdCB0aW1lem9uZSBzdHJpbmcsIFstK11ISE1NXG4gICAgICAgICAgICAgICAgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSB0aW1lem9uZVswXSA9PT0gJy0nID8gLTEgOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG91cnMgPSBwYXJzZUludCh0aW1lem9uZS5zbGljZSgxLCAzKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHBhcnNlSW50KHRpbWV6b25lLnNsaWNlKDMsIDUpLCAxMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tVGltZXpvbmVPZmZzZXQgPSBzaWduICogKCg2MCAqIGhvdXJzKSArIG1pbnV0ZXMpICogNjAgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBtaW51dGVzOiA0MjBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZXpvbmVUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21UaW1lem9uZU9mZnNldCA9IHRpbWV6b25lICogNjAgKiAxMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJmdGltZShfbG9jYWxlLCBjdXN0b21UaW1lem9uZU9mZnNldCwgdXNlVXRjQmFzZWREYXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdHJmdGltZS51dGMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZnRpbWUoX2xvY2FsZSwgX2N1c3RvbVRpbWV6b25lT2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3RyZnRpbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFkVGlsbDIobnVtYmVyVG9QYWQsIHBhZGRpbmdDaGFyKSB7XG4gICAgICAgIGlmIChwYWRkaW5nQ2hhciA9PT0gJycgfHwgbnVtYmVyVG9QYWQgPiA5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyVG9QYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmdDaGFyID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhZGRpbmdDaGFyID0gJzAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWRkaW5nQ2hhciArIG51bWJlclRvUGFkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZFRpbGwzKG51bWJlclRvUGFkKSB7XG4gICAgICAgIGlmIChudW1iZXJUb1BhZCA+IDk5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyVG9QYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWJlclRvUGFkID4gOSkge1xuICAgICAgICAgICAgcmV0dXJuICcwJyArIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnMDAnICsgbnVtYmVyVG9QYWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaG91cnMxMihob3VyKSB7XG4gICAgICAgIGlmIChob3VyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaG91ciA+IDEyKSB7XG4gICAgICAgICAgICByZXR1cm4gaG91ciAtIDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cblxuICAgIC8vIGZpcnN0V2Vla2RheTogJ3N1bmRheScgb3IgJ21vbmRheScsIGRlZmF1bHQgaXMgJ3N1bmRheSdcbiAgICAvL1xuICAgIC8vIFBpbGZlcmVkICYgcG9ydGVkIGZyb20gUnVieSdzIHN0cmZ0aW1lIGltcGxlbWVudGF0aW9uLlxuICAgIGZ1bmN0aW9uIHdlZWtOdW1iZXIoZGF0ZSwgZmlyc3RXZWVrZGF5KSB7XG4gICAgICAgIGZpcnN0V2Vla2RheSA9IGZpcnN0V2Vla2RheSB8fCAnc3VuZGF5JztcblxuICAgICAgICAvLyBUaGlzIHdvcmtzIGJ5IHNoaWZ0aW5nIHRoZSB3ZWVrZGF5IGJhY2sgYnkgb25lIGRheSBpZiB3ZVxuICAgICAgICAvLyBhcmUgdHJlYXRpbmcgTW9uZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIHZhciB3ZWVrZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgaWYgKGZpcnN0V2Vla2RheSA9PT0gJ21vbmRheScpIHtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5ID09PSAwKSAvLyBTdW5kYXlcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gNjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3ZWVrZGF5LS07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3REYXlPZlllYXJVdGMgPSBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpLFxuICAgICAgICAgICAgZGF0ZVV0YyA9IERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSksXG4gICAgICAgICAgICB5ZGF5ID0gTWF0aC5mbG9vcigoZGF0ZVV0YyAtIGZpcnN0RGF5T2ZZZWFyVXRjKSAvIDg2NDAwMDAwKSxcbiAgICAgICAgICAgIHdlZWtOdW0gPSAoeWRheSArIDcgLSB3ZWVrZGF5KSAvIDc7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iod2Vla051bSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBvcmRpbmFsIHN1ZmZpeCBmb3IgYSBudW1iZXI6IHN0LCBuZCwgcmQsIG9yIHRoXG4gICAgZnVuY3Rpb24gb3JkaW5hbChudW1iZXIpIHtcbiAgICAgICAgdmFyIGkgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgdmFyIGlpID0gbnVtYmVyICUgMTAwO1xuXG4gICAgICAgIGlmICgoaWkgPj0gMTEgJiYgaWkgPD0gMTMpIHx8IGkgPT09IDAgfHwgaSA+PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuICdzdCc7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiAnbmQnO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gJ3JkJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRpbWVzdGFtcFRvVXRjT2Zmc2V0Rm9yKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgfHwgMCkgKiA2MDAwMDtcbiAgICB9XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5WaXJ0dWFsRG9tID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKFwiLi92ZG9tL2NyZWF0ZS1lbGVtZW50LmpzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRWxlbWVudFxuXG59LHtcIi4vdmRvbS9jcmVhdGUtZWxlbWVudC5qc1wiOjI0fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZGlmZiA9IHJlcXVpcmUoXCIuL3Z0cmVlL2RpZmYuanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmXG5cbn0se1wiLi92dHJlZS9kaWZmLmpzXCI6NDd9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIVxuICogQ3Jvc3MtQnJvd3NlciBTcGxpdCAxLjEuMVxuICogQ29weXJpZ2h0IDIwMDctMjAxMiBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT5cbiAqIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIEVDTUFTY3JpcHQgY29tcGxpYW50LCB1bmlmb3JtIGNyb3NzLWJyb3dzZXIgc3BsaXQgbWV0aG9kXG4gKi9cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGEgcmVnZXggb3Igc3RyaW5nIHNlcGFyYXRvci4gTWF0Y2hlcyBvZiB0aGVcbiAqIHNlcGFyYXRvciBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHQgYXJyYXkuIEhvd2V2ZXIsIGlmIGBzZXBhcmF0b3JgIGlzIGEgcmVnZXggdGhhdCBjb250YWluc1xuICogY2FwdHVyaW5nIGdyb3VwcywgYmFja3JlZmVyZW5jZXMgYXJlIHNwbGljZWQgaW50byB0aGUgcmVzdWx0IGVhY2ggdGltZSBgc2VwYXJhdG9yYCBpcyBtYXRjaGVkLlxuICogRml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseVxuICogY3Jvc3MtYnJvd3Nlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZXBhcmF0b3IgUmVnZXggb3Igc3RyaW5nIHRvIHVzZSBmb3Igc2VwYXJhdGluZyB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdF0gTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdWJzdHJpbmdzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBCYXNpYyB1c2VcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnKTtcbiAqIC8vIC0+IFsnYScsICdiJywgJ2MnLCAnZCddXG4gKlxuICogLy8gV2l0aCBsaW1pdFxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcsIDIpO1xuICogLy8gLT4gWydhJywgJ2InXVxuICpcbiAqIC8vIEJhY2tyZWZlcmVuY2VzIGluIHJlc3VsdCBhcnJheVxuICogc3BsaXQoJy4ud29yZDEgd29yZDIuLicsIC8oW2Etel0rKShcXGQrKS9pKTtcbiAqIC8vIC0+IFsnLi4nLCAnd29yZCcsICcxJywgJyAnLCAnd29yZCcsICcyJywgJy4uJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gc3BsaXQodW5kZWYpIHtcblxuICB2YXIgbmF0aXZlU3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LFxuICAgIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoXCJcIilbMV0gPT09IHVuZGVmLFxuICAgIC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgc2VsZjtcblxuICBzZWxmID0gZnVuY3Rpb24oc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBgbmF0aXZlU3BsaXRgXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSBcIltvYmplY3QgUmVnRXhwXVwiKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU3BsaXQuY2FsbChzdHIsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLm11bHRpbGluZSA/IFwibVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLmV4dGVuZGVkID8gXCJ4XCIgOiBcIlwiKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gXCJ5XCIgOiBcIlwiKSxcbiAgICAgIC8vIEZpcmVmb3ggMytcbiAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyBcImdcIiksXG4gICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgIHN0ciArPSBcIlwiOyAvLyBUeXBlLWNvbnZlcnRcbiAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VwYXJhdG9yLnNvdXJjZSArIFwiJCg/IVxcXFxzKVwiLCBmbGFncyk7XG4gICAgfVxuICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgKi9cbiAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZiA/IC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgIGxpbWl0ID4+PiAwOyAvLyBUb1VpbnQzMihsaW1pdClcbiAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHIpKSB7XG4gICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoXCJcIikpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufSkoKTtcblxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBPbmVWZXJzaW9uQ29uc3RyYWludCA9IHJlcXVpcmUoJ2luZGl2aWR1YWwvb25lLXZlcnNpb24nKTtcblxudmFyIE1ZX1ZFUlNJT04gPSAnNyc7XG5PbmVWZXJzaW9uQ29uc3RyYWludCgnZXYtc3RvcmUnLCBNWV9WRVJTSU9OKTtcblxudmFyIGhhc2hLZXkgPSAnX19FVl9TVE9SRV9LRVlAJyArIE1ZX1ZFUlNJT047XG5cbm1vZHVsZS5leHBvcnRzID0gRXZTdG9yZTtcblxuZnVuY3Rpb24gRXZTdG9yZShlbGVtKSB7XG4gICAgdmFyIGhhc2ggPSBlbGVtW2hhc2hLZXldO1xuXG4gICAgaWYgKCFoYXNoKSB7XG4gICAgICAgIGhhc2ggPSBlbGVtW2hhc2hLZXldID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG59XG5cbn0se1wiaW5kaXZpZHVhbC9vbmUtdmVyc2lvblwiOjZ9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xuXG52YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/XG4gICAgZ2xvYmFsIDoge307XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kaXZpZHVhbDtcblxuZnVuY3Rpb24gSW5kaXZpZHVhbChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiByb290KSB7XG4gICAgICAgIHJldHVybiByb290W2tleV07XG4gICAgfVxuXG4gICAgcm9vdFtrZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBJbmRpdmlkdWFsID0gcmVxdWlyZSgnLi9pbmRleC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9uZVZlcnNpb247XG5cbmZ1bmN0aW9uIE9uZVZlcnNpb24obW9kdWxlTmFtZSwgdmVyc2lvbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIGtleSA9ICdfX0lORElWSURVQUxfT05FX1ZFUlNJT05fJyArIG1vZHVsZU5hbWU7XG4gICAgdmFyIGVuZm9yY2VLZXkgPSBrZXkgKyAnX0VORk9SQ0VfU0lOR0xFVE9OJztcblxuICAgIHZhciB2ZXJzaW9uVmFsdWUgPSBJbmRpdmlkdWFsKGVuZm9yY2VLZXksIHZlcnNpb24pO1xuXG4gICAgaWYgKHZlcnNpb25WYWx1ZSAhPT0gdmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IGhhdmUgb25lIGNvcHkgb2YgJyArXG4gICAgICAgICAgICBtb2R1bGVOYW1lICsgJy5cXG4nICtcbiAgICAgICAgICAgICdZb3UgYWxyZWFkeSBoYXZlIHZlcnNpb24gJyArIHZlcnNpb25WYWx1ZSArXG4gICAgICAgICAgICAnIGluc3RhbGxlZC5cXG4nICtcbiAgICAgICAgICAgICdUaGlzIG1lYW5zIHlvdSBjYW5ub3QgaW5zdGFsbCB2ZXJzaW9uICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSW5kaXZpZHVhbChrZXksIGRlZmF1bHRWYWx1ZSk7XG59XG5cbn0se1wiLi9pbmRleC5qc1wiOjV9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudDtcbn0gZWxzZSB7XG4gICAgdmFyIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXTtcblxuICAgIGlmICghZG9jY3kpIHtcbiAgICAgICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddID0gbWluRG9jO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCJtaW4tZG9jdW1lbnRcIjoxN31dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGRvbVdhbGsgPSByZXF1aXJlKFwiZG9tLXdhbGtcIilcblxudmFyIENvbW1lbnQgPSByZXF1aXJlKFwiLi9kb20tY29tbWVudC5qc1wiKVxudmFyIERPTVRleHQgPSByZXF1aXJlKFwiLi9kb20tdGV4dC5qc1wiKVxudmFyIERPTUVsZW1lbnQgPSByZXF1aXJlKFwiLi9kb20tZWxlbWVudC5qc1wiKVxudmFyIERvY3VtZW50RnJhZ21lbnQgPSByZXF1aXJlKFwiLi9kb20tZnJhZ21lbnQuanNcIilcbnZhciBFdmVudCA9IHJlcXVpcmUoXCIuL2V2ZW50LmpzXCIpXG52YXIgZGlzcGF0Y2hFdmVudCA9IHJlcXVpcmUoXCIuL2V2ZW50L2Rpc3BhdGNoLWV2ZW50LmpzXCIpXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2V2ZW50L2FkZC1ldmVudC1saXN0ZW5lci5qc1wiKVxudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9ldmVudC9yZW1vdmUtZXZlbnQtbGlzdGVuZXIuanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudDtcblxuZnVuY3Rpb24gRG9jdW1lbnQoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50KCk7XG4gICAgfVxuXG4gICAgdGhpcy5oZWFkID0gdGhpcy5jcmVhdGVFbGVtZW50KFwiaGVhZFwiKVxuICAgIHRoaXMuYm9keSA9IHRoaXMuY3JlYXRlRWxlbWVudChcImJvZHlcIilcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IHRoaXMuY3JlYXRlRWxlbWVudChcImh0bWxcIilcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmhlYWQpXG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ib2R5KVxuICAgIHRoaXMuY2hpbGROb2RlcyA9IFt0aGlzLmRvY3VtZW50RWxlbWVudF1cbiAgICB0aGlzLm5vZGVUeXBlID0gOVxufVxuXG52YXIgcHJvdG8gPSBEb2N1bWVudC5wcm90b3R5cGU7XG5wcm90by5jcmVhdGVUZXh0Tm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBET01UZXh0KHZhbHVlLCB0aGlzKVxufVxuXG5wcm90by5jcmVhdGVFbGVtZW50TlMgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gICAgdmFyIG5zID0gbmFtZXNwYWNlID09PSBudWxsID8gbnVsbCA6IFN0cmluZyhuYW1lc3BhY2UpXG4gICAgcmV0dXJuIG5ldyBET01FbGVtZW50KHRhZ05hbWUsIHRoaXMsIG5zKVxufVxuXG5wcm90by5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBET01FbGVtZW50KHRhZ05hbWUsIHRoaXMpXG59XG5cbnByb3RvLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudEZyYWdtZW50KCkge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudCh0aGlzKVxufVxuXG5wcm90by5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGZhbWlseSkge1xuICAgIHJldHVybiBuZXcgRXZlbnQoZmFtaWx5KVxufVxuXG5wcm90by5jcmVhdGVDb21tZW50ID0gZnVuY3Rpb24gY3JlYXRlQ29tbWVudChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDb21tZW50KGRhdGEsIHRoaXMpXG59XG5cbnByb3RvLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICBpZCA9IFN0cmluZyhpZClcblxuICAgIHZhciByZXN1bHQgPSBkb21XYWxrKHRoaXMuY2hpbGROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKFN0cmluZyhub2RlLmlkKSA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdCB8fCBudWxsXG59XG5cbnByb3RvLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBET01FbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lXG5wcm90by5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IERPTUVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lXG5wcm90by5jb250YWlucyA9IERPTUVsZW1lbnQucHJvdG90eXBlLmNvbnRhaW5zXG5cbnByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyXG5wcm90by5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lclxucHJvdG8uZGlzcGF0Y2hFdmVudCA9IGRpc3BhdGNoRXZlbnRcblxufSx7XCIuL2RvbS1jb21tZW50LmpzXCI6OSxcIi4vZG9tLWVsZW1lbnQuanNcIjoxMCxcIi4vZG9tLWZyYWdtZW50LmpzXCI6MTEsXCIuL2RvbS10ZXh0LmpzXCI6MTIsXCIuL2V2ZW50LmpzXCI6MTMsXCIuL2V2ZW50L2FkZC1ldmVudC1saXN0ZW5lci5qc1wiOjE0LFwiLi9ldmVudC9kaXNwYXRjaC1ldmVudC5qc1wiOjE1LFwiLi9ldmVudC9yZW1vdmUtZXZlbnQtbGlzdGVuZXIuanNcIjoxNixcImRvbS13YWxrXCI6MTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudFxuXG5mdW5jdGlvbiBDb21tZW50KGRhdGEsIG93bmVyKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tbWVudChkYXRhLCBvd25lcilcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhXG4gICAgdGhpcy5ub2RlVmFsdWUgPSBkYXRhXG4gICAgdGhpcy5sZW5ndGggPSBkYXRhLmxlbmd0aFxuICAgIHRoaXMub3duZXJEb2N1bWVudCA9IG93bmVyIHx8IG51bGxcbn1cblxuQ29tbWVudC5wcm90b3R5cGUubm9kZVR5cGUgPSA4XG5Db21tZW50LnByb3RvdHlwZS5ub2RlTmFtZSA9IFwiI2NvbW1lbnRcIlxuXG5Db21tZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIF9Db21tZW50X3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgQ29tbWVudF1cIlxufVxuXG59LHt9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZG9tV2FsayA9IHJlcXVpcmUoXCJkb20td2Fsa1wiKVxudmFyIGRpc3BhdGNoRXZlbnQgPSByZXF1aXJlKFwiLi9ldmVudC9kaXNwYXRjaC1ldmVudC5qc1wiKVxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9ldmVudC9hZGQtZXZlbnQtbGlzdGVuZXIuanNcIilcbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gcmVxdWlyZShcIi4vZXZlbnQvcmVtb3ZlLWV2ZW50LWxpc3RlbmVyLmpzXCIpXG52YXIgc2VyaWFsaXplTm9kZSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZS5qc1wiKVxuXG52YXIgaHRtbG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJcblxubW9kdWxlLmV4cG9ydHMgPSBET01FbGVtZW50XG5cbmZ1bmN0aW9uIERPTUVsZW1lbnQodGFnTmFtZSwgb3duZXIsIG5hbWVzcGFjZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBET01FbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IERPTUVsZW1lbnQodGFnTmFtZSlcbiAgICB9XG5cbiAgICB2YXIgbnMgPSBuYW1lc3BhY2UgPT09IHVuZGVmaW5lZCA/IGh0bWxucyA6IChuYW1lc3BhY2UgfHwgbnVsbClcblxuICAgIHRoaXMudGFnTmFtZSA9IG5zID09PSBodG1sbnMgPyBTdHJpbmcodGFnTmFtZSkudG9VcHBlckNhc2UoKSA6IHRhZ05hbWVcbiAgICB0aGlzLm5vZGVOYW1lID0gdGhpcy50YWdOYW1lXG4gICAgdGhpcy5jbGFzc05hbWUgPSBcIlwiXG4gICAgdGhpcy5kYXRhc2V0ID0ge31cbiAgICB0aGlzLmNoaWxkTm9kZXMgPSBbXVxuICAgIHRoaXMucGFyZW50Tm9kZSA9IG51bGxcbiAgICB0aGlzLnN0eWxlID0ge31cbiAgICB0aGlzLm93bmVyRG9jdW1lbnQgPSBvd25lciB8fCBudWxsXG4gICAgdGhpcy5uYW1lc3BhY2VVUkkgPSBuc1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSB7fVxuXG4gICAgaWYgKHRoaXMudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgdGhpcy50eXBlID0gJ3RleHQnXG4gICAgfVxufVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS50eXBlID0gXCJET01FbGVtZW50XCJcbkRPTUVsZW1lbnQucHJvdG90eXBlLm5vZGVUeXBlID0gMVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIF9FbGVtZW50X2FwcGVuZENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudE5vZGUpIHtcbiAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZClcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZClcbiAgICBjaGlsZC5wYXJlbnROb2RlID0gdGhpc1xuXG4gICAgcmV0dXJuIGNoaWxkXG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VDaGlsZCA9XG4gICAgZnVuY3Rpb24gX0VsZW1lbnRfcmVwbGFjZUNoaWxkKGVsZW0sIG5lZWRsZSkge1xuICAgICAgICAvLyBUT0RPOiBUaHJvdyBOb3RGb3VuZEVycm9yIGlmIG5lZWRsZS5wYXJlbnROb2RlICE9PSB0aGlzXG5cbiAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihuZWVkbGUpXG5cbiAgICAgICAgbmVlZGxlLnBhcmVudE5vZGUgPSBudWxsXG4gICAgICAgIHRoaXMuY2hpbGROb2Rlc1tpbmRleF0gPSBlbGVtXG4gICAgICAgIGVsZW0ucGFyZW50Tm9kZSA9IHRoaXNcblxuICAgICAgICByZXR1cm4gbmVlZGxlXG4gICAgfVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIF9FbGVtZW50X3JlbW92ZUNoaWxkKGVsZW0pIHtcbiAgICAvLyBUT0RPOiBUaHJvdyBOb3RGb3VuZEVycm9yIGlmIGVsZW0ucGFyZW50Tm9kZSAhPT0gdGhpc1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoZWxlbSlcbiAgICB0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKGluZGV4LCAxKVxuXG4gICAgZWxlbS5wYXJlbnROb2RlID0gbnVsbFxuICAgIHJldHVybiBlbGVtXG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmluc2VydEJlZm9yZSA9XG4gICAgZnVuY3Rpb24gX0VsZW1lbnRfaW5zZXJ0QmVmb3JlKGVsZW0sIG5lZWRsZSkge1xuICAgICAgICAvLyBUT0RPOiBUaHJvdyBOb3RGb3VuZEVycm9yIGlmIHJlZmVyZW5jZUVsZW1lbnQgaXMgYSBkb20gbm9kZVxuICAgICAgICAvLyBhbmQgcGFyZW50Tm9kZSAhPT0gdGhpc1xuXG4gICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gbmVlZGxlID09PSBudWxsIHx8IG5lZWRsZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIC0xIDpcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKG5lZWRsZSlcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnNwbGljZShpbmRleCwgMCwgZWxlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5wdXNoKGVsZW0pXG4gICAgICAgIH1cblxuICAgICAgICBlbGVtLnBhcmVudE5vZGUgPSB0aGlzXG4gICAgICAgIHJldHVybiBlbGVtXG4gICAgfVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyA9XG4gICAgZnVuY3Rpb24gX0VsZW1lbnRfc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gbnVsbFxuICAgICAgICB2YXIgbG9jYWxOYW1lID0gbmFtZVxuICAgICAgICB2YXIgY29sb25Qb3NpdGlvbiA9IG5hbWUuaW5kZXhPZihcIjpcIilcbiAgICAgICAgaWYgKGNvbG9uUG9zaXRpb24gPiAtMSkge1xuICAgICAgICAgICAgcHJlZml4ID0gbmFtZS5zdWJzdHIoMCwgY29sb25Qb3NpdGlvbilcbiAgICAgICAgICAgIGxvY2FsTmFtZSA9IG5hbWUuc3Vic3RyKGNvbG9uUG9zaXRpb24gKyAxKVxuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lc3BhY2VdIHx8ICh0aGlzLl9hdHRyaWJ1dGVzW25hbWVzcGFjZV0gPSB7fSlcbiAgICAgICAgYXR0cmlidXRlc1tsb2NhbE5hbWVdID0ge3ZhbHVlOiB2YWx1ZSwgcHJlZml4OiBwcmVmaXh9XG4gICAgfVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVOUyA9XG4gICAgZnVuY3Rpb24gX0VsZW1lbnRfZ2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lc3BhY2VdO1xuICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXNbbmFtZV0gJiYgYXR0cmlidXRlc1tuYW1lXS52YWx1ZVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyA9XG4gICAgZnVuY3Rpb24gX0VsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lc3BhY2VdO1xuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNbbmFtZV1cbiAgICAgICAgfVxuICAgIH1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUuaGFzQXR0cmlidXRlTlMgPVxuICAgIGZ1bmN0aW9uIF9FbGVtZW50X2hhc0F0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuX2F0dHJpYnV0ZXNbbmFtZXNwYWNlXVxuICAgICAgICByZXR1cm4gISFhdHRyaWJ1dGVzICYmIG5hbWUgaW4gYXR0cmlidXRlcztcbiAgICB9XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9FbGVtZW50X3NldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZU5TKG51bGwsIG5hbWUsIHZhbHVlKVxufVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfRWxlbWVudF9nZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZU5TKG51bGwsIG5hbWUpXG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMobnVsbCwgbmFtZSlcbn1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUuaGFzQXR0cmlidXRlID0gZnVuY3Rpb24gX0VsZW1lbnRfaGFzQXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGVOUyhudWxsLCBuYW1lKVxufVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lclxuRE9NRWxlbWVudC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXJcbkRPTUVsZW1lbnQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBkaXNwYXRjaEV2ZW50XG5cbi8vIFVuLWltcGxlbWVudGVkXG5ET01FbGVtZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIF9FbGVtZW50X2ZvY3VzKCkge1xuICAgIHJldHVybiB2b2lkIDBcbn1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBfRWxlbWVudF90b1N0cmluZygpIHtcbiAgICByZXR1cm4gc2VyaWFsaXplTm9kZSh0aGlzKVxufVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gZnVuY3Rpb24gX0VsZW1lbnRfZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWVzKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBjbGFzc05hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICB2YXIgZWxlbXMgPSBbXVxuXG4gICAgZG9tV2Fsayh0aGlzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIG5vZGVDbGFzc05hbWUgPSBub2RlLmNsYXNzTmFtZSB8fCBcIlwiXG4gICAgICAgICAgICB2YXIgbm9kZUNsYXNzZXMgPSBub2RlQ2xhc3NOYW1lLnNwbGl0KFwiIFwiKVxuXG4gICAgICAgICAgICBpZiAoY2xhc3Nlcy5ldmVyeShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlQ2xhc3Nlcy5pbmRleE9mKGl0ZW0pICE9PSAtMVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBlbGVtcy5wdXNoKG5vZGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGVsZW1zXG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gZnVuY3Rpb24gX0VsZW1lbnRfZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSkge1xuICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICB2YXIgZWxlbXMgPSBbXVxuXG4gICAgZG9tV2Fsayh0aGlzLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmICh0YWdOYW1lID09PSAnKicgfHwgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZ05hbWUpKSB7XG4gICAgICAgICAgICBlbGVtcy5wdXNoKG5vZGUpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGVsZW1zXG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gX0VsZW1lbnRfY29udGFpbnMoZWxlbWVudCkge1xuICAgIHJldHVybiBkb21XYWxrKHRoaXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID09PSBub2RlXG4gICAgfSkgfHwgZmFsc2Vcbn1cblxufSx7XCIuL2V2ZW50L2FkZC1ldmVudC1saXN0ZW5lci5qc1wiOjE0LFwiLi9ldmVudC9kaXNwYXRjaC1ldmVudC5qc1wiOjE1LFwiLi9ldmVudC9yZW1vdmUtZXZlbnQtbGlzdGVuZXIuanNcIjoxNixcIi4vc2VyaWFsaXplLmpzXCI6MTksXCJkb20td2Fsa1wiOjE4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIERPTUVsZW1lbnQgPSByZXF1aXJlKFwiLi9kb20tZWxlbWVudC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50RnJhZ21lbnRcblxuZnVuY3Rpb24gRG9jdW1lbnRGcmFnbWVudChvd25lcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQoKVxuICAgIH1cblxuICAgIHRoaXMuY2hpbGROb2RlcyA9IFtdXG4gICAgdGhpcy5wYXJlbnROb2RlID0gbnVsbFxuICAgIHRoaXMub3duZXJEb2N1bWVudCA9IG93bmVyIHx8IG51bGxcbn1cblxuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUudHlwZSA9IFwiRG9jdW1lbnRGcmFnbWVudFwiXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5ub2RlVHlwZSA9IDExXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5ub2RlTmFtZSA9IFwiI2RvY3VtZW50LWZyYWdtZW50XCJcblxuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgID0gRE9NRWxlbWVudC5wcm90b3R5cGUuYXBwZW5kQ2hpbGRcbkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnJlcGxhY2VDaGlsZCA9IERPTUVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VDaGlsZFxuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgID0gRE9NRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGRcblxuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPVxuICAgIGZ1bmN0aW9uIF9Eb2N1bWVudEZyYWdtZW50X3RvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhub2RlKVxuICAgICAgICB9KS5qb2luKFwiXCIpXG4gICAgfVxuXG59LHtcIi4vZG9tLWVsZW1lbnQuanNcIjoxMH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gRE9NVGV4dFxuXG5mdW5jdGlvbiBET01UZXh0KHZhbHVlLCBvd25lcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBET01UZXh0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERPTVRleHQodmFsdWUpXG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0gdmFsdWUgfHwgXCJcIlxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aFxuICAgIHRoaXMub3duZXJEb2N1bWVudCA9IG93bmVyIHx8IG51bGxcbn1cblxuRE9NVGV4dC5wcm90b3R5cGUudHlwZSA9IFwiRE9NVGV4dE5vZGVcIlxuRE9NVGV4dC5wcm90b3R5cGUubm9kZVR5cGUgPSAzXG5ET01UZXh0LnByb3RvdHlwZS5ub2RlTmFtZSA9IFwiI3RleHRcIlxuXG5ET01UZXh0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIF9UZXh0X3RvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFcbn1cblxuRE9NVGV4dC5wcm90b3R5cGUucmVwbGFjZURhdGEgPSBmdW5jdGlvbiByZXBsYWNlRGF0YShpbmRleCwgbGVuZ3RoLCB2YWx1ZSkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5kYXRhXG4gICAgdmFyIGxlZnQgPSBjdXJyZW50LnN1YnN0cmluZygwLCBpbmRleClcbiAgICB2YXIgcmlnaHQgPSBjdXJyZW50LnN1YnN0cmluZyhpbmRleCArIGxlbmd0aCwgY3VycmVudC5sZW5ndGgpXG4gICAgdGhpcy5kYXRhID0gbGVmdCArIHZhbHVlICsgcmlnaHRcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGhcbn1cblxufSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBFdmVudFxuXG5mdW5jdGlvbiBFdmVudChmYW1pbHkpIHt9XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbiBfRXZlbnRfaW5pdEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlXG4gICAgdGhpcy5idWJibGVzID0gYnViYmxlc1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGVcbn1cblxuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gX0V2ZW50X3ByZXZlbnREZWZhdWx0KCkge1xuICAgIFxufVxuXG59LHt9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGFkZEV2ZW50TGlzdGVuZXJcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBlbGVtID0gdGhpc1xuXG4gICAgaWYgKCFlbGVtLmxpc3RlbmVycykge1xuICAgICAgICBlbGVtLmxpc3RlbmVycyA9IHt9XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBlbGVtLmxpc3RlbmVyc1t0eXBlXSA9IFtdXG4gICAgfVxuXG4gICAgaWYgKGVsZW0ubGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgICAgICBlbGVtLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKVxuICAgIH1cbn1cblxufSx7fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBkaXNwYXRjaEV2ZW50XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXYpIHtcbiAgICB2YXIgZWxlbSA9IHRoaXNcbiAgICB2YXIgdHlwZSA9IGV2LnR5cGVcblxuICAgIGlmICghZXYudGFyZ2V0KSB7XG4gICAgICAgIGV2LnRhcmdldCA9IGVsZW1cbiAgICB9XG5cbiAgICBpZiAoIWVsZW0ubGlzdGVuZXJzKSB7XG4gICAgICAgIGVsZW0ubGlzdGVuZXJzID0ge31cbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gZWxlbS5saXN0ZW5lcnNbdHlwZV1cblxuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgZXYuY3VycmVudFRhcmdldCA9IGVsZW1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihldilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQoZXYpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtLnBhcmVudE5vZGUuZGlzcGF0Y2hFdmVudChldilcbiAgICB9XG59XG5cbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlRXZlbnRMaXN0ZW5lclxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzXG5cbiAgICBpZiAoIWVsZW0ubGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghZWxlbS5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGxpc3QgPSBlbGVtLmxpc3RlbmVyc1t0eXBlXVxuICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihsaXN0ZW5lcilcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbn1cblxufSx7fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBEb2N1bWVudCgpO1xuXG59LHtcIi4vZG9jdW1lbnQuanNcIjo4fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5cbm1vZHVsZS5leHBvcnRzID0gaXRlcmF0aXZlbHlXYWxrXG5cbmZ1bmN0aW9uIGl0ZXJhdGl2ZWx5V2Fsayhub2RlcywgY2IpIHtcbiAgICBpZiAoISgnbGVuZ3RoJyBpbiBub2RlcykpIHtcbiAgICAgICAgbm9kZXMgPSBbbm9kZXNdXG4gICAgfVxuICAgIFxuICAgIG5vZGVzID0gc2xpY2UuY2FsbChub2RlcylcblxuICAgIHdoaWxlKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzLnNoaWZ0KCksXG4gICAgICAgICAgICByZXQgPSBjYihub2RlKVxuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZXMgPSBzbGljZS5jYWxsKG5vZGUuY2hpbGROb2RlcykuY29uY2F0KG5vZGVzKVxuICAgICAgICB9XG4gICAgfVxufVxuXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHNlcmlhbGl6ZU5vZGVcblxudmFyIHZvaWRFbGVtZW50cyA9IC9hcmVhfGJhc2V8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZW51aXRlbXxtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIvaTtcblxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVUZXh0KG5vZGUuZGF0YSlcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIFwiPCEtLVwiICsgbm9kZS5kYXRhICsgXCItLT5cIlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUVsZW1lbnQobm9kZSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVsZW1lbnQoZWxlbSkge1xuICAgIHZhciBzdHJpbmdzID0gW11cblxuICAgIHZhciB0YWduYW1lID0gZWxlbS50YWdOYW1lXG5cbiAgICBpZiAoZWxlbS5uYW1lc3BhY2VVUkkgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKSB7XG4gICAgICAgIHRhZ25hbWUgPSB0YWduYW1lLnRvTG93ZXJDYXNlKClcbiAgICB9XG5cbiAgICBzdHJpbmdzLnB1c2goXCI8XCIgKyB0YWduYW1lICsgcHJvcGVydGllcyhlbGVtKSArIGRhdGFzZXRpZnkoZWxlbSkpXG5cbiAgICBpZiAodm9pZEVsZW1lbnRzLnRlc3QodGFnbmFtZSkpIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKFwiIC8+XCIpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKFwiPlwiKVxuXG4gICAgICAgIGlmIChlbGVtLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJpbmdzLnB1c2guYXBwbHkoc3RyaW5ncywgZWxlbS5jaGlsZE5vZGVzLm1hcChzZXJpYWxpemVOb2RlKSlcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0KSB7XG4gICAgICAgICAgICBzdHJpbmdzLnB1c2goZXNjYXBlVGV4dChlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0KSlcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgc3RyaW5ncy5wdXNoKGVsZW0uaW5uZXJIVE1MKVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyaW5ncy5wdXNoKFwiPC9cIiArIHRhZ25hbWUgKyBcIj5cIilcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5ncy5qb2luKFwiXCIpXG59XG5cbmZ1bmN0aW9uIGlzUHJvcGVydHkoZWxlbSwga2V5KSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgZWxlbVtrZXldXG5cbiAgICBpZiAoa2V5ID09PSBcInN0eWxlXCIgJiYgT2JqZWN0LmtleXMoZWxlbS5zdHlsZSkubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICh0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIpICYmXG4gICAgICAgIGtleSAhPT0gXCJub2RlTmFtZVwiICYmIGtleSAhPT0gXCJjbGFzc05hbWVcIiAmJiBrZXkgIT09IFwidGFnTmFtZVwiICYmXG4gICAgICAgIGtleSAhPT0gXCJ0ZXh0Q29udGVudFwiICYmIGtleSAhPT0gXCJpbm5lclRleHRcIiAmJiBrZXkgIT09IFwibmFtZXNwYWNlVVJJXCIgJiYgIGtleSAhPT0gXCJpbm5lckhUTUxcIlxufVxuXG5mdW5jdGlvbiBzdHlsaWZ5KHN0eWxlcykge1xuICAgIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykgcmV0dXJuIHN0eWxlc1xuICAgIHZhciBhdHRyID0gXCJcIlxuICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1trZXldXG4gICAgICAgIGtleSA9IGtleS5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gXCItXCIgKyBjLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIGF0dHIgKz0ga2V5ICsgXCI6XCIgKyB2YWx1ZSArIFwiO1wiXG4gICAgfSlcbiAgICByZXR1cm4gYXR0clxufVxuXG5mdW5jdGlvbiBkYXRhc2V0aWZ5KGVsZW0pIHtcbiAgICB2YXIgZHMgPSBlbGVtLmRhdGFzZXRcbiAgICB2YXIgcHJvcHMgPSBbXVxuXG4gICAgZm9yICh2YXIga2V5IGluIGRzKSB7XG4gICAgICAgIHByb3BzLnB1c2goeyBuYW1lOiBcImRhdGEtXCIgKyBrZXksIHZhbHVlOiBkc1trZXldIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzLmxlbmd0aCA/IHN0cmluZ2lmeShwcm9wcykgOiBcIlwiXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShsaXN0KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBbXVxuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0dXBsZS5uYW1lXG4gICAgICAgIHZhciB2YWx1ZSA9IHR1cGxlLnZhbHVlXG5cbiAgICAgICAgaWYgKG5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgdmFsdWUgPSBzdHlsaWZ5KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlcy5wdXNoKG5hbWUgKyBcIj1cIiArIFwiXFxcIlwiICsgZXNjYXBlQXR0cmlidXRlVmFsdWUodmFsdWUpICsgXCJcXFwiXCIpXG4gICAgfSlcblxuICAgIHJldHVybiBhdHRyaWJ1dGVzLmxlbmd0aCA/IFwiIFwiICsgYXR0cmlidXRlcy5qb2luKFwiIFwiKSA6IFwiXCJcbn1cblxuZnVuY3Rpb24gcHJvcGVydGllcyhlbGVtKSB7XG4gICAgdmFyIHByb3BzID0gW11cbiAgICBmb3IgKHZhciBrZXkgaW4gZWxlbSkge1xuICAgICAgICBpZiAoaXNQcm9wZXJ0eShlbGVtLCBrZXkpKSB7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKHsgbmFtZToga2V5LCB2YWx1ZTogZWxlbVtrZXldIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBucyBpbiBlbGVtLl9hdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gZWxlbS5fYXR0cmlidXRlc1tuc10pIHtcbiAgICAgICAgdmFyIHByb3AgPSBlbGVtLl9hdHRyaWJ1dGVzW25zXVthdHRyaWJ1dGVdXG4gICAgICAgIHZhciBuYW1lID0gKHByb3AucHJlZml4ID8gcHJvcC5wcmVmaXggKyBcIjpcIiA6IFwiXCIpICsgYXR0cmlidXRlXG4gICAgICAgIHByb3BzLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogcHJvcC52YWx1ZSB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtLmNsYXNzTmFtZSkge1xuICAgICAgICBwcm9wcy5wdXNoKHsgbmFtZTogXCJjbGFzc1wiLCB2YWx1ZTogZWxlbS5jbGFzc05hbWUgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMubGVuZ3RoID8gc3RyaW5naWZ5KHByb3BzKSA6IFwiXCJcbn1cblxuZnVuY3Rpb24gZXNjYXBlVGV4dChzKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHsgXG4gICAgICAgIHN0ciA9IHM7IFxuICAgIH0gZWxzZSBpZiAocykge1xuICAgICAgICBzdHIgPSBzLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0clxuICAgICAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXG4gICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbn1cblxuZnVuY3Rpb24gZXNjYXBlQXR0cmlidXRlVmFsdWUoc3RyKSB7XG4gICAgcmV0dXJuIGVzY2FwZVRleHQoc3RyKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxufVxuXG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG5cdHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsO1xufTtcblxufSx7fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlSXNBcnJheSB8fCBpc0FycmF5XG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG59XG5cbn0se31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBwYXRjaCA9IHJlcXVpcmUoXCIuL3Zkb20vcGF0Y2guanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuXG59LHtcIi4vdmRvbS9wYXRjaC5qc1wiOjI3fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZShcImlzLW9iamVjdFwiKVxudmFyIGlzSG9vayA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy12aG9vay5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5UHJvcGVydGllc1xuXG5mdW5jdGlvbiBhcHBseVByb3BlcnRpZXMobm9kZSwgcHJvcHMsIHByZXZpb3VzKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXVxuXG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVtb3ZlUHJvcGVydHkobm9kZSwgcHJvcE5hbWUsIHByb3BWYWx1ZSwgcHJldmlvdXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSG9vayhwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgICByZW1vdmVQcm9wZXJ0eShub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCBwcmV2aW91cylcbiAgICAgICAgICAgIGlmIChwcm9wVmFsdWUuaG9vaykge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZS5ob29rKG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA/IHByZXZpb3VzW3Byb3BOYW1lXSA6IHVuZGVmaW5lZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hPYmplY3Qobm9kZSwgcHJvcHMsIHByZXZpb3VzLCBwcm9wTmFtZSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBwcm9wVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkobm9kZSwgcHJvcE5hbWUsIHByb3BWYWx1ZSwgcHJldmlvdXMpIHtcbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1twcm9wTmFtZV1cblxuICAgICAgICBpZiAoIWlzSG9vayhwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbaV0gPSBcIlwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJldmlvdXNWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gXCJcIlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlLnVuaG9vaykge1xuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZS51bmhvb2sobm9kZSwgcHJvcE5hbWUsIHByb3BWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hPYmplY3Qobm9kZSwgcHJvcHMsIHByZXZpb3VzLCBwcm9wTmFtZSwgcHJvcFZhbHVlKSB7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBwcmV2aW91cyA/IHByZXZpb3VzW3Byb3BOYW1lXSA6IHVuZGVmaW5lZFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXNcbiAgICBpZiAocHJvcE5hbWUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHByb3BWYWx1ZVthdHRyTmFtZV1cblxuICAgICAgICAgICAgaWYgKGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZihwcmV2aW91c1ZhbHVlICYmIGlzT2JqZWN0KHByZXZpb3VzVmFsdWUpICYmXG4gICAgICAgIGdldFByb3RvdHlwZShwcmV2aW91c1ZhbHVlKSAhPT0gZ2V0UHJvdG90eXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBwcm9wVmFsdWVcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFpc09iamVjdChub2RlW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSB7fVxuICAgIH1cblxuICAgIHZhciByZXBsYWNlciA9IHByb3BOYW1lID09PSBcInN0eWxlXCIgPyBcIlwiIDogdW5kZWZpbmVkXG5cbiAgICBmb3IgKHZhciBrIGluIHByb3BWYWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm9wVmFsdWVba11cbiAgICAgICAgbm9kZVtwcm9wTmFtZV1ba10gPSAodmFsdWUgPT09IHVuZGVmaW5lZCkgPyByZXBsYWNlciA6IHZhbHVlXG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm90b3R5cGUodmFsdWUpIHtcbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5fX3Byb3RvX18pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl9fcHJvdG9fX1xuICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICAgIH1cbn1cblxufSx7XCIuLi92bm9kZS9pcy12aG9vay5qc1wiOjM4LFwiaXMtb2JqZWN0XCI6MjB9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKFwiZ2xvYmFsL2RvY3VtZW50XCIpXG5cbnZhciBhcHBseVByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi9hcHBseS1wcm9wZXJ0aWVzXCIpXG5cbnZhciBpc1ZOb2RlID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZub2RlLmpzXCIpXG52YXIgaXNWVGV4dCA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy12dGV4dC5qc1wiKVxudmFyIGlzV2lkZ2V0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiKVxudmFyIGhhbmRsZVRodW5rID0gcmVxdWlyZShcIi4uL3Zub2RlL2hhbmRsZS10aHVuay5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVsZW1lbnRcblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh2bm9kZSwgb3B0cykge1xuICAgIHZhciBkb2MgPSBvcHRzID8gb3B0cy5kb2N1bWVudCB8fCBkb2N1bWVudCA6IGRvY3VtZW50XG4gICAgdmFyIHdhcm4gPSBvcHRzID8gb3B0cy53YXJuIDogbnVsbFxuXG4gICAgdm5vZGUgPSBoYW5kbGVUaHVuayh2bm9kZSkuYVxuXG4gICAgaWYgKGlzV2lkZ2V0KHZub2RlKSkge1xuICAgICAgICByZXR1cm4gdm5vZGUuaW5pdCgpXG4gICAgfSBlbHNlIGlmIChpc1ZUZXh0KHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpXG4gICAgfSBlbHNlIGlmICghaXNWTm9kZSh2bm9kZSkpIHtcbiAgICAgICAgaWYgKHdhcm4pIHtcbiAgICAgICAgICAgIHdhcm4oXCJJdGVtIGlzIG5vdCBhIHZhbGlkIHZpcnR1YWwgZG9tIG5vZGVcIiwgdm5vZGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9ICh2bm9kZS5uYW1lc3BhY2UgPT09IG51bGwpID9cbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnQodm5vZGUudGFnTmFtZSkgOlxuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5hbWVzcGFjZSwgdm5vZGUudGFnTmFtZSlcblxuICAgIHZhciBwcm9wcyA9IHZub2RlLnByb3BlcnRpZXNcbiAgICBhcHBseVByb3BlcnRpZXMobm9kZSwgcHJvcHMpXG5cbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gY3JlYXRlRWxlbWVudChjaGlsZHJlbltpXSwgb3B0cylcbiAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxufVxuXG59LHtcIi4uL3Zub2RlL2hhbmRsZS10aHVuay5qc1wiOjM2LFwiLi4vdm5vZGUvaXMtdm5vZGUuanNcIjozOSxcIi4uL3Zub2RlL2lzLXZ0ZXh0LmpzXCI6NDAsXCIuLi92bm9kZS9pcy13aWRnZXQuanNcIjo0MSxcIi4vYXBwbHktcHJvcGVydGllc1wiOjIzLFwiZ2xvYmFsL2RvY3VtZW50XCI6N31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIE1hcHMgYSB2aXJ0dWFsIERPTSB0cmVlIG9udG8gYSByZWFsIERPTSB0cmVlIGluIGFuIGVmZmljaWVudCBtYW5uZXIuXG4vLyBXZSBkb24ndCB3YW50IHRvIHJlYWQgYWxsIG9mIHRoZSBET00gbm9kZXMgaW4gdGhlIHRyZWUgc28gd2UgdXNlXG4vLyB0aGUgaW4tb3JkZXIgdHJlZSBpbmRleGluZyB0byBlbGltaW5hdGUgcmVjdXJzaW9uIGRvd24gY2VydGFpbiBicmFuY2hlcy5cbi8vIFdlIG9ubHkgcmVjdXJzZSBpbnRvIGEgRE9NIG5vZGUgaWYgd2Uga25vdyB0aGF0IGl0IGNvbnRhaW5zIGEgY2hpbGQgb2Zcbi8vIGludGVyZXN0LlxuXG52YXIgbm9DaGlsZCA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tSW5kZXhcblxuZnVuY3Rpb24gZG9tSW5kZXgocm9vdE5vZGUsIHRyZWUsIGluZGljZXMsIG5vZGVzKSB7XG4gICAgaWYgKCFpbmRpY2VzIHx8IGluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGljZXMuc29ydChhc2NlbmRpbmcpXG4gICAgICAgIHJldHVybiByZWN1cnNlKHJvb3ROb2RlLCB0cmVlLCBpbmRpY2VzLCBub2RlcywgMClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2Uocm9vdE5vZGUsIHRyZWUsIGluZGljZXMsIG5vZGVzLCByb290SW5kZXgpIHtcbiAgICBub2RlcyA9IG5vZGVzIHx8IHt9XG5cblxuICAgIGlmIChyb290Tm9kZSkge1xuICAgICAgICBpZiAoaW5kZXhJblJhbmdlKGluZGljZXMsIHJvb3RJbmRleCwgcm9vdEluZGV4KSkge1xuICAgICAgICAgICAgbm9kZXNbcm9vdEluZGV4XSA9IHJvb3ROb2RlXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdkNoaWxkcmVuID0gdHJlZS5jaGlsZHJlblxuXG4gICAgICAgIGlmICh2Q2hpbGRyZW4pIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSByb290Tm9kZS5jaGlsZE5vZGVzXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJvb3RJbmRleCArPSAxXG5cbiAgICAgICAgICAgICAgICB2YXIgdkNoaWxkID0gdkNoaWxkcmVuW2ldIHx8IG5vQ2hpbGRcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gcm9vdEluZGV4ICsgKHZDaGlsZC5jb3VudCB8fCAwKVxuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCByZWN1cnNpb24gZG93biB0aGUgdHJlZSBpZiB0aGVyZSBhcmUgbm8gbm9kZXMgZG93biBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4SW5SYW5nZShpbmRpY2VzLCByb290SW5kZXgsIG5leHRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZShjaGlsZE5vZGVzW2ldLCB2Q2hpbGQsIGluZGljZXMsIG5vZGVzLCByb290SW5kZXgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm9vdEluZGV4ID0gbmV4dEluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXNcbn1cblxuLy8gQmluYXJ5IHNlYXJjaCBmb3IgYW4gaW5kZXggaW4gdGhlIGludGVydmFsIFtsZWZ0LCByaWdodF1cbmZ1bmN0aW9uIGluZGV4SW5SYW5nZShpbmRpY2VzLCBsZWZ0LCByaWdodCkge1xuICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgbWluSW5kZXggPSAwXG4gICAgdmFyIG1heEluZGV4ID0gaW5kaWNlcy5sZW5ndGggLSAxXG4gICAgdmFyIGN1cnJlbnRJbmRleFxuICAgIHZhciBjdXJyZW50SXRlbVxuXG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9ICgobWF4SW5kZXggKyBtaW5JbmRleCkgLyAyKSA+PiAwXG4gICAgICAgIGN1cnJlbnRJdGVtID0gaW5kaWNlc1tjdXJyZW50SW5kZXhdXG5cbiAgICAgICAgaWYgKG1pbkluZGV4ID09PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJdGVtID49IGxlZnQgJiYgY3VycmVudEl0ZW0gPD0gcmlnaHRcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50SXRlbSA8IGxlZnQpIHtcbiAgICAgICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMVxuICAgICAgICB9IGVsc2UgIGlmIChjdXJyZW50SXRlbSA+IHJpZ2h0KSB7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IC0xXG59XG5cbn0se31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBhcHBseVByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi9hcHBseS1wcm9wZXJ0aWVzXCIpXG5cbnZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy13aWRnZXQuanNcIilcbnZhciBWUGF0Y2ggPSByZXF1aXJlKFwiLi4vdm5vZGUvdnBhdGNoLmpzXCIpXG5cbnZhciB1cGRhdGVXaWRnZXQgPSByZXF1aXJlKFwiLi91cGRhdGUtd2lkZ2V0XCIpXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlQYXRjaFxuXG5mdW5jdGlvbiBhcHBseVBhdGNoKHZwYXRjaCwgZG9tTm9kZSwgcmVuZGVyT3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gdnBhdGNoLnR5cGVcbiAgICB2YXIgdk5vZGUgPSB2cGF0Y2gudk5vZGVcbiAgICB2YXIgcGF0Y2ggPSB2cGF0Y2gucGF0Y2hcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFZQYXRjaC5SRU1PVkU6XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlTm9kZShkb21Ob2RlLCB2Tm9kZSlcbiAgICAgICAgY2FzZSBWUGF0Y2guSU5TRVJUOlxuICAgICAgICAgICAgcmV0dXJuIGluc2VydE5vZGUoZG9tTm9kZSwgcGF0Y2gsIHJlbmRlck9wdGlvbnMpXG4gICAgICAgIGNhc2UgVlBhdGNoLlZURVhUOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1BhdGNoKGRvbU5vZGUsIHZOb2RlLCBwYXRjaCwgcmVuZGVyT3B0aW9ucylcbiAgICAgICAgY2FzZSBWUGF0Y2guV0lER0VUOlxuICAgICAgICAgICAgcmV0dXJuIHdpZGdldFBhdGNoKGRvbU5vZGUsIHZOb2RlLCBwYXRjaCwgcmVuZGVyT3B0aW9ucylcbiAgICAgICAgY2FzZSBWUGF0Y2guVk5PREU6XG4gICAgICAgICAgICByZXR1cm4gdk5vZGVQYXRjaChkb21Ob2RlLCB2Tm9kZSwgcGF0Y2gsIHJlbmRlck9wdGlvbnMpXG4gICAgICAgIGNhc2UgVlBhdGNoLk9SREVSOlxuICAgICAgICAgICAgcmVvcmRlckNoaWxkcmVuKGRvbU5vZGUsIHBhdGNoKVxuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGVcbiAgICAgICAgY2FzZSBWUGF0Y2guUFJPUFM6XG4gICAgICAgICAgICBhcHBseVByb3BlcnRpZXMoZG9tTm9kZSwgcGF0Y2gsIHZOb2RlLnByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gZG9tTm9kZVxuICAgICAgICBjYXNlIFZQYXRjaC5USFVOSzpcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlUm9vdChkb21Ob2RlLFxuICAgICAgICAgICAgICAgIHJlbmRlck9wdGlvbnMucGF0Y2goZG9tTm9kZSwgcGF0Y2gsIHJlbmRlck9wdGlvbnMpKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGVcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUoZG9tTm9kZSwgdk5vZGUpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGRvbU5vZGUucGFyZW50Tm9kZVxuXG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb21Ob2RlKVxuICAgIH1cblxuICAgIGRlc3Ryb3lXaWRnZXQoZG9tTm9kZSwgdk5vZGUpO1xuXG4gICAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnROb2RlLCB2Tm9kZSwgcmVuZGVyT3B0aW9ucykge1xuICAgIHZhciBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIodk5vZGUsIHJlbmRlck9wdGlvbnMpXG5cbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5ld05vZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gc3RyaW5nUGF0Y2goZG9tTm9kZSwgbGVmdFZOb2RlLCB2VGV4dCwgcmVuZGVyT3B0aW9ucykge1xuICAgIHZhciBuZXdOb2RlXG5cbiAgICBpZiAoZG9tTm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICBkb21Ob2RlLnJlcGxhY2VEYXRhKDAsIGRvbU5vZGUubGVuZ3RoLCB2VGV4dC50ZXh0KVxuICAgICAgICBuZXdOb2RlID0gZG9tTm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlXG4gICAgICAgIG5ld05vZGUgPSByZW5kZXJPcHRpb25zLnJlbmRlcih2VGV4dCwgcmVuZGVyT3B0aW9ucylcblxuICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBuZXdOb2RlICE9PSBkb21Ob2RlKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBkb21Ob2RlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld05vZGVcbn1cblxuZnVuY3Rpb24gd2lkZ2V0UGF0Y2goZG9tTm9kZSwgbGVmdFZOb2RlLCB3aWRnZXQsIHJlbmRlck9wdGlvbnMpIHtcbiAgICB2YXIgdXBkYXRpbmcgPSB1cGRhdGVXaWRnZXQobGVmdFZOb2RlLCB3aWRnZXQpXG4gICAgdmFyIG5ld05vZGVcblxuICAgIGlmICh1cGRhdGluZykge1xuICAgICAgICBuZXdOb2RlID0gd2lkZ2V0LnVwZGF0ZShsZWZ0Vk5vZGUsIGRvbU5vZGUpIHx8IGRvbU5vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIod2lkZ2V0LCByZW5kZXJPcHRpb25zKVxuICAgIH1cblxuICAgIHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlXG5cbiAgICBpZiAocGFyZW50Tm9kZSAmJiBuZXdOb2RlICE9PSBkb21Ob2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIGRvbU5vZGUpXG4gICAgfVxuXG4gICAgaWYgKCF1cGRhdGluZykge1xuICAgICAgICBkZXN0cm95V2lkZ2V0KGRvbU5vZGUsIGxlZnRWTm9kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3Tm9kZVxufVxuXG5mdW5jdGlvbiB2Tm9kZVBhdGNoKGRvbU5vZGUsIGxlZnRWTm9kZSwgdk5vZGUsIHJlbmRlck9wdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGRvbU5vZGUucGFyZW50Tm9kZVxuICAgIHZhciBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIodk5vZGUsIHJlbmRlck9wdGlvbnMpXG5cbiAgICBpZiAocGFyZW50Tm9kZSAmJiBuZXdOb2RlICE9PSBkb21Ob2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIGRvbU5vZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld05vZGVcbn1cblxuZnVuY3Rpb24gZGVzdHJveVdpZGdldChkb21Ob2RlLCB3KSB7XG4gICAgaWYgKHR5cGVvZiB3LmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIiAmJiBpc1dpZGdldCh3KSkge1xuICAgICAgICB3LmRlc3Ryb3koZG9tTm9kZSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihkb21Ob2RlLCBtb3Zlcykge1xuICAgIHZhciBjaGlsZE5vZGVzID0gZG9tTm9kZS5jaGlsZE5vZGVzXG4gICAgdmFyIGtleU1hcCA9IHt9XG4gICAgdmFyIG5vZGVcbiAgICB2YXIgcmVtb3ZlXG4gICAgdmFyIGluc2VydFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3Zlcy5yZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlbW92ZSA9IG1vdmVzLnJlbW92ZXNbaV1cbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNbcmVtb3ZlLmZyb21dXG4gICAgICAgIGlmIChyZW1vdmUua2V5KSB7XG4gICAgICAgICAgICBrZXlNYXBbcmVtb3ZlLmtleV0gPSBub2RlXG4gICAgICAgIH1cbiAgICAgICAgZG9tTm9kZS5yZW1vdmVDaGlsZChub2RlKVxuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW92ZXMuaW5zZXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBpbnNlcnQgPSBtb3Zlcy5pbnNlcnRzW2pdXG4gICAgICAgIG5vZGUgPSBrZXlNYXBbaW5zZXJ0LmtleV1cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgd2VpcmRlc3QgYnVnIGkndmUgZXZlciBzZWVuIGluIHdlYmtpdFxuICAgICAgICBkb21Ob2RlLmluc2VydEJlZm9yZShub2RlLCBpbnNlcnQudG8gPj0gbGVuZ3RoKysgPyBudWxsIDogY2hpbGROb2Rlc1tpbnNlcnQudG9dKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVJvb3Qob2xkUm9vdCwgbmV3Um9vdCkge1xuICAgIGlmIChvbGRSb290ICYmIG5ld1Jvb3QgJiYgb2xkUm9vdCAhPT0gbmV3Um9vdCAmJiBvbGRSb290LnBhcmVudE5vZGUpIHtcbiAgICAgICAgb2xkUm9vdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdSb290LCBvbGRSb290KVxuICAgIH1cblxuICAgIHJldHVybiBuZXdSb290O1xufVxuXG59LHtcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiOjQxLFwiLi4vdm5vZGUvdnBhdGNoLmpzXCI6NDQsXCIuL2FwcGx5LXByb3BlcnRpZXNcIjoyMyxcIi4vdXBkYXRlLXdpZGdldFwiOjI4fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZShcImdsb2JhbC9kb2N1bWVudFwiKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKFwieC1pcy1hcnJheVwiKVxuXG52YXIgcmVuZGVyID0gcmVxdWlyZShcIi4vY3JlYXRlLWVsZW1lbnRcIilcbnZhciBkb21JbmRleCA9IHJlcXVpcmUoXCIuL2RvbS1pbmRleFwiKVxudmFyIHBhdGNoT3AgPSByZXF1aXJlKFwiLi9wYXRjaC1vcFwiKVxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuXG5mdW5jdGlvbiBwYXRjaChyb290Tm9kZSwgcGF0Y2hlcywgcmVuZGVyT3B0aW9ucykge1xuICAgIHJlbmRlck9wdGlvbnMgPSByZW5kZXJPcHRpb25zIHx8IHt9XG4gICAgcmVuZGVyT3B0aW9ucy5wYXRjaCA9IHJlbmRlck9wdGlvbnMucGF0Y2ggJiYgcmVuZGVyT3B0aW9ucy5wYXRjaCAhPT0gcGF0Y2hcbiAgICAgICAgPyByZW5kZXJPcHRpb25zLnBhdGNoXG4gICAgICAgIDogcGF0Y2hSZWN1cnNpdmVcbiAgICByZW5kZXJPcHRpb25zLnJlbmRlciA9IHJlbmRlck9wdGlvbnMucmVuZGVyIHx8IHJlbmRlclxuXG4gICAgcmV0dXJuIHJlbmRlck9wdGlvbnMucGF0Y2gocm9vdE5vZGUsIHBhdGNoZXMsIHJlbmRlck9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHBhdGNoUmVjdXJzaXZlKHJvb3ROb2RlLCBwYXRjaGVzLCByZW5kZXJPcHRpb25zKSB7XG4gICAgdmFyIGluZGljZXMgPSBwYXRjaEluZGljZXMocGF0Y2hlcylcblxuICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcm9vdE5vZGVcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBkb21JbmRleChyb290Tm9kZSwgcGF0Y2hlcy5hLCBpbmRpY2VzKVxuICAgIHZhciBvd25lckRvY3VtZW50ID0gcm9vdE5vZGUub3duZXJEb2N1bWVudFxuXG4gICAgaWYgKCFyZW5kZXJPcHRpb25zLmRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIHJlbmRlck9wdGlvbnMuZG9jdW1lbnQgPSBvd25lckRvY3VtZW50XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSW5kZXggPSBpbmRpY2VzW2ldXG4gICAgICAgIHJvb3ROb2RlID0gYXBwbHlQYXRjaChyb290Tm9kZSxcbiAgICAgICAgICAgIGluZGV4W25vZGVJbmRleF0sXG4gICAgICAgICAgICBwYXRjaGVzW25vZGVJbmRleF0sXG4gICAgICAgICAgICByZW5kZXJPcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiByb290Tm9kZVxufVxuXG5mdW5jdGlvbiBhcHBseVBhdGNoKHJvb3ROb2RlLCBkb21Ob2RlLCBwYXRjaExpc3QsIHJlbmRlck9wdGlvbnMpIHtcbiAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJvb3ROb2RlXG4gICAgfVxuXG4gICAgdmFyIG5ld05vZGVcblxuICAgIGlmIChpc0FycmF5KHBhdGNoTGlzdCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRjaExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld05vZGUgPSBwYXRjaE9wKHBhdGNoTGlzdFtpXSwgZG9tTm9kZSwgcmVuZGVyT3B0aW9ucylcblxuICAgICAgICAgICAgaWYgKGRvbU5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUgPSBuZXdOb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdOb2RlID0gcGF0Y2hPcChwYXRjaExpc3QsIGRvbU5vZGUsIHJlbmRlck9wdGlvbnMpXG5cbiAgICAgICAgaWYgKGRvbU5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICByb290Tm9kZSA9IG5ld05vZGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb290Tm9kZVxufVxuXG5mdW5jdGlvbiBwYXRjaEluZGljZXMocGF0Y2hlcykge1xuICAgIHZhciBpbmRpY2VzID0gW11cblxuICAgIGZvciAodmFyIGtleSBpbiBwYXRjaGVzKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwiYVwiKSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goTnVtYmVyKGtleSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kaWNlc1xufVxuXG59LHtcIi4vY3JlYXRlLWVsZW1lbnRcIjoyNCxcIi4vZG9tLWluZGV4XCI6MjUsXCIuL3BhdGNoLW9wXCI6MjYsXCJnbG9iYWwvZG9jdW1lbnRcIjo3LFwieC1pcy1hcnJheVwiOjIxfV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzV2lkZ2V0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZGF0ZVdpZGdldFxuXG5mdW5jdGlvbiB1cGRhdGVXaWRnZXQoYSwgYikge1xuICAgIGlmIChpc1dpZGdldChhKSAmJiBpc1dpZGdldChiKSkge1xuICAgICAgICBpZiAoXCJuYW1lXCIgaW4gYSAmJiBcIm5hbWVcIiBpbiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5pZCA9PT0gYi5pZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGEuaW5pdCA9PT0gYi5pbml0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxufSx7XCIuLi92bm9kZS9pcy13aWRnZXQuanNcIjo0MX1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGVIb29rO1xuXG5mdW5jdGlvbiBBdHRyaWJ1dGVIb29rKG5hbWVzcGFjZSwgdmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXR0cmlidXRlSG9vaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVIb29rKG5hbWVzcGFjZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuQXR0cmlidXRlSG9vay5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChub2RlLCBwcm9wLCBwcmV2KSB7XG4gICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSAnQXR0cmlidXRlSG9vaycgJiZcbiAgICAgICAgcHJldi52YWx1ZSA9PT0gdGhpcy52YWx1ZSAmJlxuICAgICAgICBwcmV2Lm5hbWVzcGFjZSA9PT0gdGhpcy5uYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlTlModGhpcy5uYW1lc3BhY2UsIHByb3AsIHRoaXMudmFsdWUpO1xufTtcblxuQXR0cmlidXRlSG9vay5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24gKG5vZGUsIHByb3AsIG5leHQpIHtcbiAgICBpZiAobmV4dCAmJiBuZXh0LnR5cGUgPT09ICdBdHRyaWJ1dGVIb29rJyAmJlxuICAgICAgICBuZXh0Lm5hbWVzcGFjZSA9PT0gdGhpcy5uYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb2xvblBvc2l0aW9uID0gcHJvcC5pbmRleE9mKCc6Jyk7XG4gICAgdmFyIGxvY2FsTmFtZSA9IGNvbG9uUG9zaXRpb24gPiAtMSA/IHByb3Auc3Vic3RyKGNvbG9uUG9zaXRpb24gKyAxKSA6IHByb3A7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyh0aGlzLm5hbWVzcGFjZSwgbG9jYWxOYW1lKTtcbn07XG5cbkF0dHJpYnV0ZUhvb2sucHJvdG90eXBlLnR5cGUgPSAnQXR0cmlidXRlSG9vayc7XG5cbn0se31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2U3RvcmUgPSByZXF1aXJlKCdldi1zdG9yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2SG9vaztcblxuZnVuY3Rpb24gRXZIb29rKHZhbHVlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEV2SG9vaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFdkhvb2sodmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuRXZIb29rLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5vZGUsIHByb3BlcnR5TmFtZSkge1xuICAgIHZhciBlcyA9IEV2U3RvcmUobm9kZSk7XG4gICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlOYW1lLnN1YnN0cigzKTtcblxuICAgIGVzW3Byb3BOYW1lXSA9IHRoaXMudmFsdWU7XG59O1xuXG5Fdkhvb2sucHJvdG90eXBlLnVuaG9vayA9IGZ1bmN0aW9uKG5vZGUsIHByb3BlcnR5TmFtZSkge1xuICAgIHZhciBlcyA9IEV2U3RvcmUobm9kZSk7XG4gICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlOYW1lLnN1YnN0cigzKTtcblxuICAgIGVzW3Byb3BOYW1lXSA9IHVuZGVmaW5lZDtcbn07XG5cbn0se1wiZXYtc3RvcmVcIjo0fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvZnRTZXRIb29rO1xuXG5mdW5jdGlvbiBTb2Z0U2V0SG9vayh2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2Z0U2V0SG9vaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb2Z0U2V0SG9vayh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5Tb2Z0U2V0SG9vay5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChub2RlLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBpZiAobm9kZVtwcm9wZXJ0eU5hbWVdICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHRoaXMudmFsdWU7XG4gICAgfVxufTtcblxufSx7fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ3gtaXMtYXJyYXknKTtcblxudmFyIFZOb2RlID0gcmVxdWlyZSgnLi4vdm5vZGUvdm5vZGUuanMnKTtcbnZhciBWVGV4dCA9IHJlcXVpcmUoJy4uL3Zub2RlL3Z0ZXh0LmpzJyk7XG52YXIgaXNWTm9kZSA9IHJlcXVpcmUoJy4uL3Zub2RlL2lzLXZub2RlJyk7XG52YXIgaXNWVGV4dCA9IHJlcXVpcmUoJy4uL3Zub2RlL2lzLXZ0ZXh0Jyk7XG52YXIgaXNXaWRnZXQgPSByZXF1aXJlKCcuLi92bm9kZS9pcy13aWRnZXQnKTtcbnZhciBpc0hvb2sgPSByZXF1aXJlKCcuLi92bm9kZS9pcy12aG9vaycpO1xudmFyIGlzVlRodW5rID0gcmVxdWlyZSgnLi4vdm5vZGUvaXMtdGh1bmsnKTtcblxudmFyIHBhcnNlVGFnID0gcmVxdWlyZSgnLi9wYXJzZS10YWcuanMnKTtcbnZhciBzb2Z0U2V0SG9vayA9IHJlcXVpcmUoJy4vaG9va3Mvc29mdC1zZXQtaG9vay5qcycpO1xudmFyIGV2SG9vayA9IHJlcXVpcmUoJy4vaG9va3MvZXYtaG9vay5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGg7XG5cbmZ1bmN0aW9uIGgodGFnTmFtZSwgcHJvcGVydGllcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGROb2RlcyA9IFtdO1xuICAgIHZhciB0YWcsIHByb3BzLCBrZXksIG5hbWVzcGFjZTtcblxuICAgIGlmICghY2hpbGRyZW4gJiYgaXNDaGlsZHJlbihwcm9wZXJ0aWVzKSkge1xuICAgICAgICBjaGlsZHJlbiA9IHByb3BlcnRpZXM7XG4gICAgICAgIHByb3BzID0ge307XG4gICAgfVxuXG4gICAgcHJvcHMgPSBwcm9wcyB8fCBwcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHRhZyA9IHBhcnNlVGFnKHRhZ05hbWUsIHByb3BzKTtcblxuICAgIC8vIHN1cHBvcnQga2V5c1xuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHtcbiAgICAgICAga2V5ID0gcHJvcHMua2V5O1xuICAgICAgICBwcm9wcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydCBuYW1lc3BhY2VcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ25hbWVzcGFjZScpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgICAgcHJvcHMubmFtZXNwYWNlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGZpeCBjdXJzb3IgYnVnXG4gICAgaWYgKHRhZyA9PT0gJ0lOUFVUJyAmJlxuICAgICAgICAhbmFtZXNwYWNlICYmXG4gICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpICYmXG4gICAgICAgIHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIWlzSG9vayhwcm9wcy52YWx1ZSlcbiAgICApIHtcbiAgICAgICAgcHJvcHMudmFsdWUgPSBzb2Z0U2V0SG9vayhwcm9wcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtUHJvcGVydGllcyhwcm9wcyk7XG5cbiAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiBjaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICBhZGRDaGlsZChjaGlsZHJlbiwgY2hpbGROb2RlcywgdGFnLCBwcm9wcyk7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gbmV3IFZOb2RlKHRhZywgcHJvcHMsIGNoaWxkTm9kZXMsIGtleSwgbmFtZXNwYWNlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2hpbGQoYywgY2hpbGROb2RlcywgdGFnLCBwcm9wcykge1xuICAgIGlmICh0eXBlb2YgYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKG5ldyBWVGV4dChjKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKG5ldyBWVGV4dChTdHJpbmcoYykpKTtcbiAgICB9IGVsc2UgaWYgKGlzQ2hpbGQoYykpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKGMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFkZENoaWxkKGNbaV0sIGNoaWxkTm9kZXMsIHRhZywgcHJvcHMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChjID09PSBudWxsIHx8IGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgVW5leHBlY3RlZFZpcnR1YWxFbGVtZW50KHtcbiAgICAgICAgICAgIGZvcmVpZ25PYmplY3Q6IGMsXG4gICAgICAgICAgICBwYXJlbnRWbm9kZToge1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhZyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cbiAgICAgICAgICAgIGlmIChpc0hvb2sodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wTmFtZS5zdWJzdHIoMCwgMykgPT09ICdldi0nKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGV2LWZvbyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZXZIb29rKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNDaGlsZCh4KSB7XG4gICAgcmV0dXJuIGlzVk5vZGUoeCkgfHwgaXNWVGV4dCh4KSB8fCBpc1dpZGdldCh4KSB8fCBpc1ZUaHVuayh4KTtcbn1cblxuZnVuY3Rpb24gaXNDaGlsZHJlbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyB8fCBpc0FycmF5KHgpIHx8IGlzQ2hpbGQoeCk7XG59XG5cbmZ1bmN0aW9uIFVuZXhwZWN0ZWRWaXJ0dWFsRWxlbWVudChkYXRhKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuXG4gICAgZXJyLnR5cGUgPSAndmlydHVhbC1oeXBlcnNjcmlwdC51bmV4cGVjdGVkLnZpcnR1YWwtZWxlbWVudCc7XG4gICAgZXJyLm1lc3NhZ2UgPSAnVW5leHBlY3RlZCB2aXJ0dWFsIGNoaWxkIHBhc3NlZCB0byBoKCkuXFxuJyArXG4gICAgICAgICdFeHBlY3RlZCBhIFZOb2RlIC8gVnRodW5rIC8gVldpZGdldCAvIHN0cmluZyBidXQ6XFxuJyArXG4gICAgICAgICdnb3Q6XFxuJyArXG4gICAgICAgIGVycm9yU3RyaW5nKGRhdGEuZm9yZWlnbk9iamVjdCkgK1xuICAgICAgICAnLlxcbicgK1xuICAgICAgICAnVGhlIHBhcmVudCB2bm9kZSBpczpcXG4nICtcbiAgICAgICAgZXJyb3JTdHJpbmcoZGF0YS5wYXJlbnRWbm9kZSlcbiAgICAgICAgJ1xcbicgK1xuICAgICAgICAnU3VnZ2VzdGVkIGZpeDogY2hhbmdlIHlvdXIgYGgoLi4uLCBbIC4uLiBdKWAgY2FsbHNpdGUuJztcbiAgICBlcnIuZm9yZWlnbk9iamVjdCA9IGRhdGEuZm9yZWlnbk9iamVjdDtcbiAgICBlcnIucGFyZW50Vm5vZGUgPSBkYXRhLnBhcmVudFZub2RlO1xuXG4gICAgcmV0dXJuIGVycjtcbn1cblxuZnVuY3Rpb24gZXJyb3JTdHJpbmcob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgJyAgICAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcob2JqKTtcbiAgICB9XG59XG5cbn0se1wiLi4vdm5vZGUvaXMtdGh1bmtcIjozNyxcIi4uL3Zub2RlL2lzLXZob29rXCI6MzgsXCIuLi92bm9kZS9pcy12bm9kZVwiOjM5LFwiLi4vdm5vZGUvaXMtdnRleHRcIjo0MCxcIi4uL3Zub2RlL2lzLXdpZGdldFwiOjQxLFwiLi4vdm5vZGUvdm5vZGUuanNcIjo0MyxcIi4uL3Zub2RlL3Z0ZXh0LmpzXCI6NDUsXCIuL2hvb2tzL2V2LWhvb2suanNcIjozMCxcIi4vaG9va3Mvc29mdC1zZXQtaG9vay5qc1wiOjMxLFwiLi9wYXJzZS10YWcuanNcIjozMyxcIngtaXMtYXJyYXlcIjoyMX1dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHNwbGl0ID0gcmVxdWlyZSgnYnJvd3Nlci1zcGxpdCcpO1xuXG52YXIgY2xhc3NJZFNwbGl0ID0gLyhbXFwuI10/W2EtekEtWjAtOVxcdTAwN0YtXFx1RkZGRl86LV0rKS87XG52YXIgbm90Q2xhc3NJZCA9IC9eXFwufCMvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVGFnO1xuXG5mdW5jdGlvbiBwYXJzZVRhZyh0YWcsIHByb3BzKSB7XG4gICAgaWYgKCF0YWcpIHtcbiAgICAgICAgcmV0dXJuICdESVYnO1xuICAgIH1cblxuICAgIHZhciBub0lkID0gIShwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaWQnKSk7XG5cbiAgICB2YXIgdGFnUGFydHMgPSBzcGxpdCh0YWcsIGNsYXNzSWRTcGxpdCk7XG4gICAgdmFyIHRhZ05hbWUgPSBudWxsO1xuXG4gICAgaWYgKG5vdENsYXNzSWQudGVzdCh0YWdQYXJ0c1sxXSkpIHtcbiAgICAgICAgdGFnTmFtZSA9ICdESVYnO1xuICAgIH1cblxuICAgIHZhciBjbGFzc2VzLCBwYXJ0LCB0eXBlLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRhZ1BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnQgPSB0YWdQYXJ0c1tpXTtcblxuICAgICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IHBhcnQuY2hhckF0KDApO1xuXG4gICAgICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICAgICAgdGFnTmFtZSA9IHBhcnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaChwYXJ0LnN1YnN0cmluZygxLCBwYXJ0Lmxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcjJyAmJiBub0lkKSB7XG4gICAgICAgICAgICBwcm9wcy5pZCA9IHBhcnQuc3Vic3RyaW5nKDEsIHBhcnQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICAgIGlmIChwcm9wcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaChwcm9wcy5jbGFzc05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzLm5hbWVzcGFjZSA/IHRhZ05hbWUgOiB0YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG59XG5cbn0se1wiYnJvd3Nlci1zcGxpdFwiOjN9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBERUZBVUxUX05BTUVTUEFDRSA9IG51bGw7XG52YXIgRVZfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEveG1sLWV2ZW50cyc7XG52YXIgWExJTktfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xudmFyIFhNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHVGlueTEyL2F0dHJpYnV0ZVRhYmxlLmh0bWxcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG52YXIgU1ZHX1BST1BFUlRJRVMgPSB7XG4gICAgJ2Fib3V0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2FjY2VudC1oZWlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYWNjdW11bGF0ZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhZGRpdGl2ZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhbGlnbm1lbnQtYmFzZWxpbmUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYWxwaGFiZXRpYyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhbXBsaXR1ZGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYXJhYmljLWZvcm0nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYXNjZW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2F0dHJpYnV0ZU5hbWUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYXR0cmlidXRlVHlwZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhemltdXRoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2JhbmR3aWR0aCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdiYXNlRnJlcXVlbmN5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Jhc2VQcm9maWxlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Jhc2VsaW5lLXNoaWZ0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Jib3gnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYmVnaW4nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYmlhcyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdieSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjYWxjTW9kZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjYXAtaGVpZ2h0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NsYXNzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NsaXAnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY2xpcC1wYXRoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NsaXAtcnVsZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjbGlwUGF0aFVuaXRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NvbG9yJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NvbG9yLWludGVycG9sYXRpb24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NvbG9yLXByb2ZpbGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY29sb3ItcmVuZGVyaW5nJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NvbnRlbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY29udGVudFNjcmlwdFR5cGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY29udGVudFN0eWxlVHlwZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjdXJzb3InOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY3gnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY3knOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdkYXRhdHlwZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdkZWZhdWx0QWN0aW9uJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Rlc2NlbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZGlmZnVzZUNvbnN0YW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2RpcmVjdGlvbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdkaXNwbGF5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Rpdmlzb3InOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZG9taW5hbnQtYmFzZWxpbmUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZHVyJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2R4JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2R5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2VkZ2VNb2RlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2VkaXRhYmxlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2VsZXZhdGlvbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdlbmFibGUtYmFja2dyb3VuZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdlbmQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZXY6ZXZlbnQnOiBFVl9OQU1FU1BBQ0UsXG4gICAgJ2V2ZW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2V4cG9uZW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZmlsbCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmaWxsLW9wYWNpdHknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZmlsbC1ydWxlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ZpbHRlcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmaWx0ZXJSZXMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZmlsdGVyVW5pdHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZmxvb2QtY29sb3InOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZmxvb2Qtb3BhY2l0eSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmb2N1c0hpZ2hsaWdodCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmb2N1c2FibGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZm9udC1mYW1pbHknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZm9udC1zaXplJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZm9udC1zdHJldGNoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ZvbnQtc3R5bGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZm9udC12YXJpYW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ZvbnQtd2VpZ2h0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Zvcm1hdCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmcm9tJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Z4JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Z5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2cxJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2cyJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2dseXBoLW5hbWUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdnbHlwaFJlZic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdncmFkaWVudFRyYW5zZm9ybSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdncmFkaWVudFVuaXRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2hhbmRsZXInOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaGFuZ2luZyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdoZWlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaG9yaXotYWR2LXgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaG9yaXotb3JpZ2luLXgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaG9yaXotb3JpZ2luLXknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaWQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaWRlb2dyYXBoaWMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaW1hZ2UtcmVuZGVyaW5nJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2luJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2luMic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdpbml0aWFsVmlzaWJpbGl0eSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdpbnRlcmNlcHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnayc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrMSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrMic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrMyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrNCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrZXJuZWxNYXRyaXgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAna2VybmVsVW5pdExlbmd0aCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrZXJuaW5nJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2tleVBvaW50cyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrZXlTcGxpbmVzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2tleVRpbWVzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2xhbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbGVuZ3RoQWRqdXN0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2xldHRlci1zcGFjaW5nJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2xpZ2h0aW5nLWNvbG9yJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2xpbWl0aW5nQ29uZUFuZ2xlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2xvY2FsJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21hcmtlci1lbmQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWFya2VyLW1pZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtYXJrZXItc3RhcnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWFya2VySGVpZ2h0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21hcmtlclVuaXRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21hcmtlcldpZHRoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21hc2snOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWFza0NvbnRlbnRVbml0cyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtYXNrVW5pdHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWF0aGVtYXRpY2FsJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21heCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtZWRpYSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtZWRpYUNoYXJhY3RlckVuY29kaW5nJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21lZGlhQ29udGVudEVuY29kaW5ncyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtZWRpYVNpemUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWVkaWFUaW1lJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21ldGhvZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtaW4nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbW9kZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICduYW1lJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ25hdi1kb3duJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ25hdi1kb3duLWxlZnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbmF2LWRvd24tcmlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbmF2LWxlZnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbmF2LW5leHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbmF2LXByZXYnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbmF2LXJpZ2h0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ25hdi11cCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICduYXYtdXAtbGVmdCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICduYXYtdXAtcmlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbnVtT2N0YXZlcyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvYnNlcnZlcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvZmZzZXQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnb3BhY2l0eSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvcGVyYXRvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvcmRlcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvcmllbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnb3JpZW50YXRpb24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnb3JpZ2luJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ292ZXJmbG93JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ292ZXJsYXknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnb3ZlcmxpbmUtcG9zaXRpb24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3Bhbm9zZS0xJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3BhdGgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncGF0aExlbmd0aCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwYXR0ZXJuQ29udGVudFVuaXRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3BhdHRlcm5UcmFuc2Zvcm0nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncGF0dGVyblVuaXRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3BoYXNlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3BsYXliYWNrT3JkZXInOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncG9pbnRlci1ldmVudHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncG9pbnRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3BvaW50c0F0WCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwb2ludHNBdFknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncG9pbnRzQXRaJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3ByZXNlcnZlQWxwaGEnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncHJlc2VydmVBc3BlY3RSYXRpbyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwcmltaXRpdmVVbml0cyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwcm9wYWdhdGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncHJvcGVydHknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyYWRpdXMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncmVmWCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZWZZJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JlbCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZW5kZXJpbmctaW50ZW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JlcGVhdENvdW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JlcGVhdER1cic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZXF1aXJlZEV4dGVuc2lvbnMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncmVxdWlyZWRGZWF0dXJlcyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZXF1aXJlZEZvbnRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JlcXVpcmVkRm9ybWF0cyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZXNvdXJjZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZXN0YXJ0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3Jlc3VsdCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZXYnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncm9sZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyb3RhdGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncngnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncnknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc2NhbGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc2VlZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzaGFwZS1yZW5kZXJpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc2xvcGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc25hcHNob3RUaW1lJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3NwYWNpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3BlY3VsYXJDb25zdGFudCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzcGVjdWxhckV4cG9uZW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3NwcmVhZE1ldGhvZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdGFydE9mZnNldCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdGREZXZpYXRpb24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3RlbWgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3RlbXYnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3RpdGNoVGlsZXMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3RvcC1jb2xvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdG9wLW9wYWNpdHknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdHJpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3Ryb2tlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0cm9rZS1kYXNoYXJyYXknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3Ryb2tlLWxpbmVjYXAnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3Ryb2tlLWxpbmVqb2luJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0cm9rZS1vcGFjaXR5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0cm9rZS13aWR0aCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdXJmYWNlU2NhbGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3luY0JlaGF2aW9yJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N5bmNCZWhhdmlvckRlZmF1bHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3luY01hc3Rlcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzeW5jVG9sZXJhbmNlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N5bmNUb2xlcmFuY2VEZWZhdWx0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N5c3RlbUxhbmd1YWdlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RhYmxlVmFsdWVzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RhcmdldCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0YXJnZXRYJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RhcmdldFknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndGV4dC1hbmNob3InOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndGV4dC1kZWNvcmF0aW9uJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RleHQtcmVuZGVyaW5nJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RleHRMZW5ndGgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndGltZWxpbmVCZWdpbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0aXRsZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0byc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0cmFuc2Zvcm0nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndHJhbnNmb3JtQmVoYXZpb3InOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndHlwZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0eXBlb2YnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndTEnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndTInOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndW5kZXJsaW5lLXBvc2l0aW9uJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3VuZGVybGluZS10aGlja25lc3MnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndW5pY29kZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd1bmljb2RlLWJpZGknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndW5pY29kZS1yYW5nZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd1bml0cy1wZXItZW0nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndi1hbHBoYWJldGljJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3YtaGFuZ2luZyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd2LWlkZW9ncmFwaGljJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3YtbWF0aGVtYXRpY2FsJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3ZhbHVlcyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd2ZXJzaW9uJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3ZlcnQtYWR2LXknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndmVydC1vcmlnaW4teCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd2ZXJ0LW9yaWdpbi15JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3ZpZXdCb3gnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndmlld1RhcmdldCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd2aXNpYmlsaXR5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3dpZHRoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3dpZHRocyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd3b3JkLXNwYWNpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnd3JpdGluZy1tb2RlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3gnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAneC1oZWlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAneDEnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAneDInOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAneENoYW5uZWxTZWxlY3Rvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd4bGluazphY3R1YXRlJzogWExJTktfTkFNRVNQQUNFLFxuICAgICd4bGluazphcmNyb2xlJzogWExJTktfTkFNRVNQQUNFLFxuICAgICd4bGluazpocmVmJzogWExJTktfTkFNRVNQQUNFLFxuICAgICd4bGluazpyb2xlJzogWExJTktfTkFNRVNQQUNFLFxuICAgICd4bGluazpzaG93JzogWExJTktfTkFNRVNQQUNFLFxuICAgICd4bGluazp0aXRsZSc6IFhMSU5LX05BTUVTUEFDRSxcbiAgICAneGxpbms6dHlwZSc6IFhMSU5LX05BTUVTUEFDRSxcbiAgICAneG1sOmJhc2UnOiBYTUxfTkFNRVNQQUNFLFxuICAgICd4bWw6aWQnOiBYTUxfTkFNRVNQQUNFLFxuICAgICd4bWw6bGFuZyc6IFhNTF9OQU1FU1BBQ0UsXG4gICAgJ3htbDpzcGFjZSc6IFhNTF9OQU1FU1BBQ0UsXG4gICAgJ3knOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAneTEnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAneTInOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAneUNoYW5uZWxTZWxlY3Rvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd6JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3pvb21BbmRQYW4nOiBERUZBVUxUX05BTUVTUEFDRVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdBdHRyaWJ1dGVOYW1lc3BhY2U7XG5cbmZ1bmN0aW9uIFNWR0F0dHJpYnV0ZU5hbWVzcGFjZSh2YWx1ZSkge1xuICBpZiAoU1ZHX1BST1BFUlRJRVMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFNWR19QUk9QRVJUSUVTW3ZhbHVlXTtcbiAgfVxufVxuXG59LHt9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgneC1pcy1hcnJheScpO1xuXG52YXIgaCA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcblxuXG52YXIgU1ZHQXR0cmlidXRlTmFtZXNwYWNlID0gcmVxdWlyZSgnLi9zdmctYXR0cmlidXRlLW5hbWVzcGFjZScpO1xudmFyIGF0dHJpYnV0ZUhvb2sgPSByZXF1aXJlKCcuL2hvb2tzL2F0dHJpYnV0ZS1ob29rJyk7XG5cbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxubW9kdWxlLmV4cG9ydHMgPSBzdmc7XG5cbmZ1bmN0aW9uIHN2Zyh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4gJiYgaXNDaGlsZHJlbihwcm9wZXJ0aWVzKSkge1xuICAgICAgICBjaGlsZHJlbiA9IHByb3BlcnRpZXM7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcblxuICAgIC8vIHNldCBuYW1lc3BhY2UgZm9yIHN2Z1xuICAgIHByb3BlcnRpZXMubmFtZXNwYWNlID0gU1ZHX05BTUVTUEFDRTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gcHJvcGVydGllcy5hdHRyaWJ1dGVzIHx8IChwcm9wZXJ0aWVzLmF0dHJpYnV0ZXMgPSB7fSk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICBpZiAoIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZXNwYWNlID0gU1ZHQXR0cmlidXRlTmFtZXNwYWNlKGtleSk7XG5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkKSB7IC8vIG5vdCBhIHN2ZyBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gcHJvcGVydGllc1trZXldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gbnVsbCkgeyAvLyBuYW1lc3BhY2VkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgcHJvcGVydGllc1trZXldID0gYXR0cmlidXRlSG9vayhuYW1lc3BhY2UsIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWVcbiAgICAgICAgcHJvcGVydGllc1trZXldID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnTmFtZSwgcHJvcGVydGllcywgY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBpc0NoaWxkcmVuKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnIHx8IGlzQXJyYXkoeCk7XG59XG5cbn0se1wiLi9ob29rcy9hdHRyaWJ1dGUtaG9va1wiOjI5LFwiLi9pbmRleC5qc1wiOjMyLFwiLi9zdmctYXR0cmlidXRlLW5hbWVzcGFjZVwiOjM0LFwieC1pcy1hcnJheVwiOjIxfV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi9pcy12bm9kZVwiKVxudmFyIGlzVlRleHQgPSByZXF1aXJlKFwiLi9pcy12dGV4dFwiKVxudmFyIGlzV2lkZ2V0ID0gcmVxdWlyZShcIi4vaXMtd2lkZ2V0XCIpXG52YXIgaXNUaHVuayA9IHJlcXVpcmUoXCIuL2lzLXRodW5rXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlVGh1bmtcblxuZnVuY3Rpb24gaGFuZGxlVGh1bmsoYSwgYikge1xuICAgIHZhciByZW5kZXJlZEEgPSBhXG4gICAgdmFyIHJlbmRlcmVkQiA9IGJcblxuICAgIGlmIChpc1RodW5rKGIpKSB7XG4gICAgICAgIHJlbmRlcmVkQiA9IHJlbmRlclRodW5rKGIsIGEpXG4gICAgfVxuXG4gICAgaWYgKGlzVGh1bmsoYSkpIHtcbiAgICAgICAgcmVuZGVyZWRBID0gcmVuZGVyVGh1bmsoYSwgbnVsbClcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhOiByZW5kZXJlZEEsXG4gICAgICAgIGI6IHJlbmRlcmVkQlxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyVGh1bmsodGh1bmssIHByZXZpb3VzKSB7XG4gICAgdmFyIHJlbmRlcmVkVGh1bmsgPSB0aHVuay52bm9kZVxuXG4gICAgaWYgKCFyZW5kZXJlZFRodW5rKSB7XG4gICAgICAgIHJlbmRlcmVkVGh1bmsgPSB0aHVuay52bm9kZSA9IHRodW5rLnJlbmRlcihwcmV2aW91cylcbiAgICB9XG5cbiAgICBpZiAoIShpc1ZOb2RlKHJlbmRlcmVkVGh1bmspIHx8XG4gICAgICAgICAgICBpc1ZUZXh0KHJlbmRlcmVkVGh1bmspIHx8XG4gICAgICAgICAgICBpc1dpZGdldChyZW5kZXJlZFRodW5rKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGh1bmsgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBub2RlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZFRodW5rXG59XG5cbn0se1wiLi9pcy10aHVua1wiOjM3LFwiLi9pcy12bm9kZVwiOjM5LFwiLi9pcy12dGV4dFwiOjQwLFwiLi9pcy13aWRnZXRcIjo0MX1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gaXNUaHVua1xyXG5cclxuZnVuY3Rpb24gaXNUaHVuayh0KSB7XHJcbiAgICByZXR1cm4gdCAmJiB0LnR5cGUgPT09IFwiVGh1bmtcIlxyXG59XHJcblxufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBpc0hvb2tcblxuZnVuY3Rpb24gaXNIb29rKGhvb2spIHtcbiAgICByZXR1cm4gaG9vayAmJlxuICAgICAgKHR5cGVvZiBob29rLmhvb2sgPT09IFwiZnVuY3Rpb25cIiAmJiAhaG9vay5oYXNPd25Qcm9wZXJ0eShcImhvb2tcIikgfHxcbiAgICAgICB0eXBlb2YgaG9vay51bmhvb2sgPT09IFwiZnVuY3Rpb25cIiAmJiAhaG9vay5oYXNPd25Qcm9wZXJ0eShcInVuaG9va1wiKSlcbn1cblxufSx7fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlcnNpb24gPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gaXNWaXJ0dWFsTm9kZVxuXG5mdW5jdGlvbiBpc1ZpcnR1YWxOb2RlKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGUgPT09IFwiVmlydHVhbE5vZGVcIiAmJiB4LnZlcnNpb24gPT09IHZlcnNpb25cbn1cblxufSx7XCIuL3ZlcnNpb25cIjo0Mn1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVmlydHVhbFRleHRcblxuZnVuY3Rpb24gaXNWaXJ0dWFsVGV4dCh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlID09PSBcIlZpcnR1YWxUZXh0XCIgJiYgeC52ZXJzaW9uID09PSB2ZXJzaW9uXG59XG5cbn0se1wiLi92ZXJzaW9uXCI6NDJ9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGlzV2lkZ2V0XG5cbmZ1bmN0aW9uIGlzV2lkZ2V0KHcpIHtcbiAgICByZXR1cm4gdyAmJiB3LnR5cGUgPT09IFwiV2lkZ2V0XCJcbn1cblxufSx7fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBcIjJcIlxuXG59LHt9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVyc2lvbiA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIilcbnZhciBpc1ZOb2RlID0gcmVxdWlyZShcIi4vaXMtdm5vZGVcIilcbnZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuL2lzLXdpZGdldFwiKVxudmFyIGlzVGh1bmsgPSByZXF1aXJlKFwiLi9pcy10aHVua1wiKVxudmFyIGlzVkhvb2sgPSByZXF1aXJlKFwiLi9pcy12aG9va1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxOb2RlXG5cbnZhciBub1Byb3BlcnRpZXMgPSB7fVxudmFyIG5vQ2hpbGRyZW4gPSBbXVxuXG5mdW5jdGlvbiBWaXJ0dWFsTm9kZSh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbiwga2V5LCBuYW1lc3BhY2UpIHtcbiAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBub1Byb3BlcnRpZXNcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgbm9DaGlsZHJlblxuICAgIHRoaXMua2V5ID0ga2V5ICE9IG51bGwgPyBTdHJpbmcoa2V5KSA6IHVuZGVmaW5lZFxuICAgIHRoaXMubmFtZXNwYWNlID0gKHR5cGVvZiBuYW1lc3BhY2UgPT09IFwic3RyaW5nXCIpID8gbmFtZXNwYWNlIDogbnVsbFxuXG4gICAgdmFyIGNvdW50ID0gKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkgfHwgMFxuICAgIHZhciBkZXNjZW5kYW50cyA9IDBcbiAgICB2YXIgaGFzV2lkZ2V0cyA9IGZhbHNlXG4gICAgdmFyIGhhc1RodW5rcyA9IGZhbHNlXG4gICAgdmFyIGRlc2NlbmRhbnRIb29rcyA9IGZhbHNlXG4gICAgdmFyIGhvb2tzXG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1twcm9wTmFtZV1cbiAgICAgICAgICAgIGlmIChpc1ZIb29rKHByb3BlcnR5KSAmJiBwcm9wZXJ0eS51bmhvb2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0ge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBob29rc1twcm9wTmFtZV0gPSBwcm9wZXJ0eVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgZGVzY2VuZGFudHMgKz0gY2hpbGQuY291bnQgfHwgMFxuXG4gICAgICAgICAgICBpZiAoIWhhc1dpZGdldHMgJiYgY2hpbGQuaGFzV2lkZ2V0cykge1xuICAgICAgICAgICAgICAgIGhhc1dpZGdldHMgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzVGh1bmtzICYmIGNoaWxkLmhhc1RodW5rcykge1xuICAgICAgICAgICAgICAgIGhhc1RodW5rcyA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkZXNjZW5kYW50SG9va3MgJiYgKGNoaWxkLmhvb2tzIHx8IGNoaWxkLmRlc2NlbmRhbnRIb29rcykpIHtcbiAgICAgICAgICAgICAgICBkZXNjZW5kYW50SG9va3MgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWhhc1dpZGdldHMgJiYgaXNXaWRnZXQoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkLmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhc1dpZGdldHMgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWhhc1RodW5rcyAmJiBpc1RodW5rKGNoaWxkKSkge1xuICAgICAgICAgICAgaGFzVGh1bmtzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY291bnQgPSBjb3VudCArIGRlc2NlbmRhbnRzXG4gICAgdGhpcy5oYXNXaWRnZXRzID0gaGFzV2lkZ2V0c1xuICAgIHRoaXMuaGFzVGh1bmtzID0gaGFzVGh1bmtzXG4gICAgdGhpcy5ob29rcyA9IGhvb2tzXG4gICAgdGhpcy5kZXNjZW5kYW50SG9va3MgPSBkZXNjZW5kYW50SG9va3Ncbn1cblxuVmlydHVhbE5vZGUucHJvdG90eXBlLnZlcnNpb24gPSB2ZXJzaW9uXG5WaXJ0dWFsTm9kZS5wcm90b3R5cGUudHlwZSA9IFwiVmlydHVhbE5vZGVcIlxuXG59LHtcIi4vaXMtdGh1bmtcIjozNyxcIi4vaXMtdmhvb2tcIjozOCxcIi4vaXMtdm5vZGVcIjozOSxcIi4vaXMtd2lkZ2V0XCI6NDEsXCIuL3ZlcnNpb25cIjo0Mn1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKVxuXG5WaXJ0dWFsUGF0Y2guTk9ORSA9IDBcblZpcnR1YWxQYXRjaC5WVEVYVCA9IDFcblZpcnR1YWxQYXRjaC5WTk9ERSA9IDJcblZpcnR1YWxQYXRjaC5XSURHRVQgPSAzXG5WaXJ0dWFsUGF0Y2guUFJPUFMgPSA0XG5WaXJ0dWFsUGF0Y2guT1JERVIgPSA1XG5WaXJ0dWFsUGF0Y2guSU5TRVJUID0gNlxuVmlydHVhbFBhdGNoLlJFTU9WRSA9IDdcblZpcnR1YWxQYXRjaC5USFVOSyA9IDhcblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsUGF0Y2hcblxuZnVuY3Rpb24gVmlydHVhbFBhdGNoKHR5cGUsIHZOb2RlLCBwYXRjaCkge1xuICAgIHRoaXMudHlwZSA9IE51bWJlcih0eXBlKVxuICAgIHRoaXMudk5vZGUgPSB2Tm9kZVxuICAgIHRoaXMucGF0Y2ggPSBwYXRjaFxufVxuXG5WaXJ0dWFsUGF0Y2gucHJvdG90eXBlLnZlcnNpb24gPSB2ZXJzaW9uXG5WaXJ0dWFsUGF0Y2gucHJvdG90eXBlLnR5cGUgPSBcIlZpcnR1YWxQYXRjaFwiXG5cbn0se1wiLi92ZXJzaW9uXCI6NDJ9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVyc2lvbiA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIilcblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsVGV4dFxuXG5mdW5jdGlvbiBWaXJ0dWFsVGV4dCh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gU3RyaW5nKHRleHQpXG59XG5cblZpcnR1YWxUZXh0LnByb3RvdHlwZS52ZXJzaW9uID0gdmVyc2lvblxuVmlydHVhbFRleHQucHJvdG90eXBlLnR5cGUgPSBcIlZpcnR1YWxUZXh0XCJcblxufSx7XCIuL3ZlcnNpb25cIjo0Mn1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoXCJpcy1vYmplY3RcIilcbnZhciBpc0hvb2sgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdmhvb2tcIilcblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmUHJvcHNcblxuZnVuY3Rpb24gZGlmZlByb3BzKGEsIGIpIHtcbiAgICB2YXIgZGlmZlxuXG4gICAgZm9yICh2YXIgYUtleSBpbiBhKSB7XG4gICAgICAgIGlmICghKGFLZXkgaW4gYikpIHtcbiAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9XG4gICAgICAgICAgICBkaWZmW2FLZXldID0gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYVZhbHVlID0gYVthS2V5XVxuICAgICAgICB2YXIgYlZhbHVlID0gYlthS2V5XVxuXG4gICAgICAgIGlmIChhVmFsdWUgPT09IGJWYWx1ZSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChhVmFsdWUpICYmIGlzT2JqZWN0KGJWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChnZXRQcm90b3R5cGUoYlZhbHVlKSAhPT0gZ2V0UHJvdG90eXBlKGFWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gZGlmZiB8fCB7fVxuICAgICAgICAgICAgICAgIGRpZmZbYUtleV0gPSBiVmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNIb29rKGJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgZGlmZiA9IGRpZmYgfHwge31cbiAgICAgICAgICAgICAgICAgZGlmZlthS2V5XSA9IGJWYWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0RGlmZiA9IGRpZmZQcm9wcyhhVmFsdWUsIGJWYWx1ZSlcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0RGlmZikge1xuICAgICAgICAgICAgICAgICAgICBkaWZmID0gZGlmZiB8fCB7fVxuICAgICAgICAgICAgICAgICAgICBkaWZmW2FLZXldID0gb2JqZWN0RGlmZlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9XG4gICAgICAgICAgICBkaWZmW2FLZXldID0gYlZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBiS2V5IGluIGIpIHtcbiAgICAgICAgaWYgKCEoYktleSBpbiBhKSkge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmYgfHwge31cbiAgICAgICAgICAgIGRpZmZbYktleV0gPSBiW2JLZXldXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlmZlxufVxuXG5mdW5jdGlvbiBnZXRQcm90b3R5cGUodmFsdWUpIHtcbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZikge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG4gIH0gZWxzZSBpZiAodmFsdWUuX19wcm90b19fKSB7XG4gICAgcmV0dXJuIHZhbHVlLl9fcHJvdG9fX1xuICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICB9XG59XG5cbn0se1wiLi4vdm5vZGUvaXMtdmhvb2tcIjozOCxcImlzLW9iamVjdFwiOjIwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKFwieC1pcy1hcnJheVwiKVxuXG52YXIgVlBhdGNoID0gcmVxdWlyZShcIi4uL3Zub2RlL3ZwYXRjaFwiKVxudmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdm5vZGVcIilcbnZhciBpc1ZUZXh0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZ0ZXh0XCIpXG52YXIgaXNXaWRnZXQgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtd2lkZ2V0XCIpXG52YXIgaXNUaHVuayA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy10aHVua1wiKVxudmFyIGhhbmRsZVRodW5rID0gcmVxdWlyZShcIi4uL3Zub2RlL2hhbmRsZS10aHVua1wiKVxuXG52YXIgZGlmZlByb3BzID0gcmVxdWlyZShcIi4vZGlmZi1wcm9wc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcblxuZnVuY3Rpb24gZGlmZihhLCBiKSB7XG4gICAgdmFyIHBhdGNoID0geyBhOiBhIH1cbiAgICB3YWxrKGEsIGIsIHBhdGNoLCAwKVxuICAgIHJldHVybiBwYXRjaFxufVxuXG5mdW5jdGlvbiB3YWxrKGEsIGIsIHBhdGNoLCBpbmRleCkge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBhcHBseSA9IHBhdGNoW2luZGV4XVxuICAgIHZhciBhcHBseUNsZWFyID0gZmFsc2VcblxuICAgIGlmIChpc1RodW5rKGEpIHx8IGlzVGh1bmsoYikpIHtcbiAgICAgICAgdGh1bmtzKGEsIGIsIHBhdGNoLCBpbmRleClcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuXG4gICAgICAgIC8vIElmIGEgaXMgYSB3aWRnZXQgd2Ugd2lsbCBhZGQgYSByZW1vdmUgcGF0Y2ggZm9yIGl0XG4gICAgICAgIC8vIE90aGVyd2lzZSBhbnkgY2hpbGQgd2lkZ2V0cy9ob29rcyBtdXN0IGJlIGRlc3Ryb3llZC5cbiAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBhZGRpbmcgdHdvIHJlbW92ZSBwYXRjaGVzIGZvciBhIHdpZGdldC5cbiAgICAgICAgaWYgKCFpc1dpZGdldChhKSkge1xuICAgICAgICAgICAgY2xlYXJTdGF0ZShhLCBwYXRjaCwgaW5kZXgpXG4gICAgICAgICAgICBhcHBseSA9IHBhdGNoW2luZGV4XVxuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guUkVNT1ZFLCBhLCBiKSlcbiAgICB9IGVsc2UgaWYgKGlzVk5vZGUoYikpIHtcbiAgICAgICAgaWYgKGlzVk5vZGUoYSkpIHtcbiAgICAgICAgICAgIGlmIChhLnRhZ05hbWUgPT09IGIudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgIGEubmFtZXNwYWNlID09PSBiLm5hbWVzcGFjZSAmJlxuICAgICAgICAgICAgICAgIGEua2V5ID09PSBiLmtleSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wc1BhdGNoID0gZGlmZlByb3BzKGEucHJvcGVydGllcywgYi5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wc1BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVlBhdGNoKFZQYXRjaC5QUk9QUywgYSwgcHJvcHNQYXRjaCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGx5ID0gZGlmZkNoaWxkcmVuKGEsIGIsIHBhdGNoLCBhcHBseSwgaW5kZXgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLlZOT0RFLCBhLCBiKSlcbiAgICAgICAgICAgICAgICBhcHBseUNsZWFyID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guVk5PREUsIGEsIGIpKVxuICAgICAgICAgICAgYXBwbHlDbGVhciA9IHRydWVcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWVGV4dChiKSkge1xuICAgICAgICBpZiAoIWlzVlRleHQoYSkpIHtcbiAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLlZURVhULCBhLCBiKSlcbiAgICAgICAgICAgIGFwcGx5Q2xlYXIgPSB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAoYS50ZXh0ICE9PSBiLnRleHQpIHtcbiAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLlZURVhULCBhLCBiKSlcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNXaWRnZXQoYikpIHtcbiAgICAgICAgaWYgKCFpc1dpZGdldChhKSkge1xuICAgICAgICAgICAgYXBwbHlDbGVhciA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLldJREdFVCwgYSwgYikpXG4gICAgfVxuXG4gICAgaWYgKGFwcGx5KSB7XG4gICAgICAgIHBhdGNoW2luZGV4XSA9IGFwcGx5XG4gICAgfVxuXG4gICAgaWYgKGFwcGx5Q2xlYXIpIHtcbiAgICAgICAgY2xlYXJTdGF0ZShhLCBwYXRjaCwgaW5kZXgpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaWZmQ2hpbGRyZW4oYSwgYiwgcGF0Y2gsIGFwcGx5LCBpbmRleCkge1xuICAgIHZhciBhQ2hpbGRyZW4gPSBhLmNoaWxkcmVuXG4gICAgdmFyIG9yZGVyZWRTZXQgPSByZW9yZGVyKGFDaGlsZHJlbiwgYi5jaGlsZHJlbilcbiAgICB2YXIgYkNoaWxkcmVuID0gb3JkZXJlZFNldC5jaGlsZHJlblxuXG4gICAgdmFyIGFMZW4gPSBhQ2hpbGRyZW4ubGVuZ3RoXG4gICAgdmFyIGJMZW4gPSBiQ2hpbGRyZW4ubGVuZ3RoXG4gICAgdmFyIGxlbiA9IGFMZW4gPiBiTGVuID8gYUxlbiA6IGJMZW5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGxlZnROb2RlID0gYUNoaWxkcmVuW2ldXG4gICAgICAgIHZhciByaWdodE5vZGUgPSBiQ2hpbGRyZW5baV1cbiAgICAgICAgaW5kZXggKz0gMVxuXG4gICAgICAgIGlmICghbGVmdE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChyaWdodE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlc3Mgbm9kZXMgaW4gYiBuZWVkIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZQYXRjaChWUGF0Y2guSU5TRVJULCBudWxsLCByaWdodE5vZGUpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FsayhsZWZ0Tm9kZSwgcmlnaHROb2RlLCBwYXRjaCwgaW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNWTm9kZShsZWZ0Tm9kZSkgJiYgbGVmdE5vZGUuY291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IGxlZnROb2RlLmNvdW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3JkZXJlZFNldC5tb3Zlcykge1xuICAgICAgICAvLyBSZW9yZGVyIG5vZGVzIGxhc3RcbiAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChcbiAgICAgICAgICAgIFZQYXRjaC5PUkRFUixcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBvcmRlcmVkU2V0Lm1vdmVzXG4gICAgICAgICkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcGx5XG59XG5cbmZ1bmN0aW9uIGNsZWFyU3RhdGUodk5vZGUsIHBhdGNoLCBpbmRleCkge1xuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBhIHNpbmdsZSB3YWxrLCBub3QgdHdvXG4gICAgdW5ob29rKHZOb2RlLCBwYXRjaCwgaW5kZXgpXG4gICAgZGVzdHJveVdpZGdldHModk5vZGUsIHBhdGNoLCBpbmRleClcbn1cblxuLy8gUGF0Y2ggcmVjb3JkcyBmb3IgYWxsIGRlc3Ryb3llZCB3aWRnZXRzIG11c3QgYmUgYWRkZWQgYmVjYXVzZSB3ZSBuZWVkXG4vLyBhIERPTSBub2RlIHJlZmVyZW5jZSBmb3IgdGhlIGRlc3Ryb3kgZnVuY3Rpb25cbmZ1bmN0aW9uIGRlc3Ryb3lXaWRnZXRzKHZOb2RlLCBwYXRjaCwgaW5kZXgpIHtcbiAgICBpZiAoaXNXaWRnZXQodk5vZGUpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygdk5vZGUuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXRjaFtpbmRleF0gPSBhcHBlbmRQYXRjaChcbiAgICAgICAgICAgICAgICBwYXRjaFtpbmRleF0sXG4gICAgICAgICAgICAgICAgbmV3IFZQYXRjaChWUGF0Y2guUkVNT1ZFLCB2Tm9kZSwgbnVsbClcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWTm9kZSh2Tm9kZSkgJiYgKHZOb2RlLmhhc1dpZGdldHMgfHwgdk5vZGUuaGFzVGh1bmtzKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlblxuICAgICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgICAgICBpbmRleCArPSAxXG5cbiAgICAgICAgICAgIGRlc3Ryb3lXaWRnZXRzKGNoaWxkLCBwYXRjaCwgaW5kZXgpXG5cbiAgICAgICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSAmJiBjaGlsZC5jb3VudCkge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGNoaWxkLmNvdW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGh1bmsodk5vZGUpKSB7XG4gICAgICAgIHRodW5rcyh2Tm9kZSwgbnVsbCwgcGF0Y2gsIGluZGV4KVxuICAgIH1cbn1cblxuLy8gQ3JlYXRlIGEgc3ViLXBhdGNoIGZvciB0aHVua3NcbmZ1bmN0aW9uIHRodW5rcyhhLCBiLCBwYXRjaCwgaW5kZXgpIHtcbiAgICB2YXIgbm9kZXMgPSBoYW5kbGVUaHVuayhhLCBiKVxuICAgIHZhciB0aHVua1BhdGNoID0gZGlmZihub2Rlcy5hLCBub2Rlcy5iKVxuICAgIGlmIChoYXNQYXRjaGVzKHRodW5rUGF0Y2gpKSB7XG4gICAgICAgIHBhdGNoW2luZGV4XSA9IG5ldyBWUGF0Y2goVlBhdGNoLlRIVU5LLCBudWxsLCB0aHVua1BhdGNoKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUGF0Y2hlcyhwYXRjaCkge1xuICAgIGZvciAodmFyIGluZGV4IGluIHBhdGNoKSB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gXCJhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gRXhlY3V0ZSBob29rcyB3aGVuIHR3byBub2RlcyBhcmUgaWRlbnRpY2FsXG5mdW5jdGlvbiB1bmhvb2sodk5vZGUsIHBhdGNoLCBpbmRleCkge1xuICAgIGlmIChpc1ZOb2RlKHZOb2RlKSkge1xuICAgICAgICBpZiAodk5vZGUuaG9va3MpIHtcbiAgICAgICAgICAgIHBhdGNoW2luZGV4XSA9IGFwcGVuZFBhdGNoKFxuICAgICAgICAgICAgICAgIHBhdGNoW2luZGV4XSxcbiAgICAgICAgICAgICAgICBuZXcgVlBhdGNoKFxuICAgICAgICAgICAgICAgICAgICBWUGF0Y2guUFJPUFMsXG4gICAgICAgICAgICAgICAgICAgIHZOb2RlLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWRLZXlzKHZOb2RlLmhvb2tzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2Tm9kZS5kZXNjZW5kYW50SG9va3MgfHwgdk5vZGUuaGFzVGh1bmtzKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlblxuICAgICAgICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuXG4gICAgICAgICAgICAgICAgdW5ob29rKGNoaWxkLCBwYXRjaCwgaW5kZXgpXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkgJiYgY2hpbGQuY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gY2hpbGQuY291bnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGh1bmsodk5vZGUpKSB7XG4gICAgICAgIHRodW5rcyh2Tm9kZSwgbnVsbCwgcGF0Y2gsIGluZGV4KVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdW5kZWZpbmVkS2V5cyhvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge31cblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIExpc3QgZGlmZiwgbmFpdmUgbGVmdCB0byByaWdodCByZW9yZGVyaW5nXG5mdW5jdGlvbiByZW9yZGVyKGFDaGlsZHJlbiwgYkNoaWxkcmVuKSB7XG4gICAgLy8gTyhNKSB0aW1lLCBPKE0pIG1lbW9yeVxuICAgIHZhciBiQ2hpbGRJbmRleCA9IGtleUluZGV4KGJDaGlsZHJlbilcbiAgICB2YXIgYktleXMgPSBiQ2hpbGRJbmRleC5rZXlzXG4gICAgdmFyIGJGcmVlID0gYkNoaWxkSW5kZXguZnJlZVxuXG4gICAgaWYgKGJGcmVlLmxlbmd0aCA9PT0gYkNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGJDaGlsZHJlbixcbiAgICAgICAgICAgIG1vdmVzOiBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPKE4pIHRpbWUsIE8oTikgbWVtb3J5XG4gICAgdmFyIGFDaGlsZEluZGV4ID0ga2V5SW5kZXgoYUNoaWxkcmVuKVxuICAgIHZhciBhS2V5cyA9IGFDaGlsZEluZGV4LmtleXNcbiAgICB2YXIgYUZyZWUgPSBhQ2hpbGRJbmRleC5mcmVlXG5cbiAgICBpZiAoYUZyZWUubGVuZ3RoID09PSBhQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogYkNoaWxkcmVuLFxuICAgICAgICAgICAgbW92ZXM6IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE8oTUFYKE4sIE0pKSBtZW1vcnlcbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXVxuXG4gICAgdmFyIGZyZWVJbmRleCA9IDBcbiAgICB2YXIgZnJlZUNvdW50ID0gYkZyZWUubGVuZ3RoXG4gICAgdmFyIGRlbGV0ZWRJdGVtcyA9IDBcblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhIGFuZCBtYXRjaCBhIG5vZGUgaW4gYlxuICAgIC8vIE8oTikgdGltZSxcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBhQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFJdGVtID0gYUNoaWxkcmVuW2ldXG4gICAgICAgIHZhciBpdGVtSW5kZXhcblxuICAgICAgICBpZiAoYUl0ZW0ua2V5KSB7XG4gICAgICAgICAgICBpZiAoYktleXMuaGFzT3duUHJvcGVydHkoYUl0ZW0ua2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoIHVwIHRoZSBvbGQga2V5c1xuICAgICAgICAgICAgICAgIGl0ZW1JbmRleCA9IGJLZXlzW2FJdGVtLmtleV1cbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGJDaGlsZHJlbltpdGVtSW5kZXhdKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQga2V5ZWQgaXRlbXNcbiAgICAgICAgICAgICAgICBpdGVtSW5kZXggPSBpIC0gZGVsZXRlZEl0ZW1zKytcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNYXRjaCB0aGUgaXRlbSBpbiBhIHdpdGggdGhlIG5leHQgZnJlZSBpdGVtIGluIGJcbiAgICAgICAgICAgIGlmIChmcmVlSW5kZXggPCBmcmVlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBpdGVtSW5kZXggPSBiRnJlZVtmcmVlSW5kZXgrK11cbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGJDaGlsZHJlbltpdGVtSW5kZXhdKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gZnJlZSBpdGVtcyBpbiBiIHRvIG1hdGNoIHdpdGhcbiAgICAgICAgICAgICAgICAvLyB0aGUgZnJlZSBpdGVtcyBpbiBhLCBzbyB0aGUgZXh0cmEgZnJlZSBub2Rlc1xuICAgICAgICAgICAgICAgIC8vIGFyZSBkZWxldGVkLlxuICAgICAgICAgICAgICAgIGl0ZW1JbmRleCA9IGkgLSBkZWxldGVkSXRlbXMrK1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobnVsbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYXN0RnJlZUluZGV4ID0gZnJlZUluZGV4ID49IGJGcmVlLmxlbmd0aCA/XG4gICAgICAgIGJDaGlsZHJlbi5sZW5ndGggOlxuICAgICAgICBiRnJlZVtmcmVlSW5kZXhdXG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggYiBhbmQgYXBwZW5kIGFueSBuZXcga2V5c1xuICAgIC8vIE8oTSkgdGltZVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYkNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuZXdJdGVtID0gYkNoaWxkcmVuW2pdXG5cbiAgICAgICAgaWYgKG5ld0l0ZW0ua2V5KSB7XG4gICAgICAgICAgICBpZiAoIWFLZXlzLmhhc093blByb3BlcnR5KG5ld0l0ZW0ua2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgbmV3IGtleWVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFkZGluZyBuZXcgaXRlbXMgdG8gdGhlIGVuZCBhbmQgdGhlbiBzb3J0aW5nIHRoZW1cbiAgICAgICAgICAgICAgICAvLyBpbiBwbGFjZS4gSW4gZnV0dXJlIHdlIHNob3VsZCBpbnNlcnQgbmV3IGl0ZW1zIGluIHBsYWNlLlxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV3SXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChqID49IGxhc3RGcmVlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhbnkgbGVmdG92ZXIgbm9uLWtleWVkIGl0ZW1zXG4gICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG5ld0l0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2ltdWxhdGUgPSBuZXdDaGlsZHJlbi5zbGljZSgpXG4gICAgdmFyIHNpbXVsYXRlSW5kZXggPSAwXG4gICAgdmFyIHJlbW92ZXMgPSBbXVxuICAgIHZhciBpbnNlcnRzID0gW11cbiAgICB2YXIgc2ltdWxhdGVJdGVtXG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGJDaGlsZHJlbi5sZW5ndGg7KSB7XG4gICAgICAgIHZhciB3YW50ZWRJdGVtID0gYkNoaWxkcmVuW2tdXG4gICAgICAgIHNpbXVsYXRlSXRlbSA9IHNpbXVsYXRlW3NpbXVsYXRlSW5kZXhdXG5cbiAgICAgICAgLy8gcmVtb3ZlIGl0ZW1zXG4gICAgICAgIHdoaWxlIChzaW11bGF0ZUl0ZW0gPT09IG51bGwgJiYgc2ltdWxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZW1vdmVzLnB1c2gocmVtb3ZlKHNpbXVsYXRlLCBzaW11bGF0ZUluZGV4LCBudWxsKSlcbiAgICAgICAgICAgIHNpbXVsYXRlSXRlbSA9IHNpbXVsYXRlW3NpbXVsYXRlSW5kZXhdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNpbXVsYXRlSXRlbSB8fCBzaW11bGF0ZUl0ZW0ua2V5ICE9PSB3YW50ZWRJdGVtLmtleSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgbmVlZCBhIGtleSBpbiB0aGlzIHBvc2l0aW9uLi4uXG4gICAgICAgICAgICBpZiAod2FudGVkSXRlbS5rZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2ltdWxhdGVJdGVtICYmIHNpbXVsYXRlSXRlbS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW4gaW5zZXJ0IGRvZXNuJ3QgcHV0IHRoaXMga2V5IGluIHBsYWNlLCBpdCBuZWVkcyB0byBtb3ZlXG4gICAgICAgICAgICAgICAgICAgIGlmIChiS2V5c1tzaW11bGF0ZUl0ZW0ua2V5XSAhPT0gayArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaChyZW1vdmUoc2ltdWxhdGUsIHNpbXVsYXRlSW5kZXgsIHNpbXVsYXRlSXRlbS5rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGVJdGVtID0gc2ltdWxhdGVbc2ltdWxhdGVJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZW1vdmUgZGlkbid0IHB1dCB0aGUgd2FudGVkIGl0ZW0gaW4gcGxhY2UsIHdlIG5lZWQgdG8gaW5zZXJ0IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbXVsYXRlSXRlbSB8fCBzaW11bGF0ZUl0ZW0ua2V5ICE9PSB3YW50ZWRJdGVtLmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydHMucHVzaCh7a2V5OiB3YW50ZWRJdGVtLmtleSwgdG86IGt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlbXMgYXJlIG1hdGNoaW5nLCBzbyBza2lwIGFoZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW11bGF0ZUluZGV4KytcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydHMucHVzaCh7a2V5OiB3YW50ZWRJdGVtLmtleSwgdG86IGt9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRzLnB1c2goe2tleTogd2FudGVkSXRlbS5rZXksIHRvOiBrfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaysrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhIGtleSBpbiBzaW11bGF0ZSBoYXMgbm8gbWF0Y2hpbmcgd2FudGVkIGtleSwgcmVtb3ZlIGl0XG4gICAgICAgICAgICBlbHNlIGlmIChzaW11bGF0ZUl0ZW0gJiYgc2ltdWxhdGVJdGVtLmtleSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaChyZW1vdmUoc2ltdWxhdGUsIHNpbXVsYXRlSW5kZXgsIHNpbXVsYXRlSXRlbS5rZXkpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2ltdWxhdGVJbmRleCsrXG4gICAgICAgICAgICBrKytcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwgdGhlIHJlbWFpbmluZyBub2RlcyBmcm9tIHNpbXVsYXRlXG4gICAgd2hpbGUoc2ltdWxhdGVJbmRleCA8IHNpbXVsYXRlLmxlbmd0aCkge1xuICAgICAgICBzaW11bGF0ZUl0ZW0gPSBzaW11bGF0ZVtzaW11bGF0ZUluZGV4XVxuICAgICAgICByZW1vdmVzLnB1c2gocmVtb3ZlKHNpbXVsYXRlLCBzaW11bGF0ZUluZGV4LCBzaW11bGF0ZUl0ZW0gJiYgc2ltdWxhdGVJdGVtLmtleSkpXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgbW92ZXMgd2UgaGF2ZSBhcmUgZGVsZXRlcyB0aGVuIHdlIGNhbiBqdXN0XG4gICAgLy8gbGV0IHRoZSBkZWxldGUgcGF0Y2ggcmVtb3ZlIHRoZXNlIGl0ZW1zLlxuICAgIGlmIChyZW1vdmVzLmxlbmd0aCA9PT0gZGVsZXRlZEl0ZW1zICYmICFpbnNlcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuLFxuICAgICAgICAgICAgbW92ZXM6IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlbixcbiAgICAgICAgbW92ZXM6IHtcbiAgICAgICAgICAgIHJlbW92ZXM6IHJlbW92ZXMsXG4gICAgICAgICAgICBpbnNlcnRzOiBpbnNlcnRzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShhcnIsIGluZGV4LCBrZXkpIHtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAxKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogaW5kZXgsXG4gICAgICAgIGtleToga2V5XG4gICAgfVxufVxuXG5mdW5jdGlvbiBrZXlJbmRleChjaGlsZHJlbikge1xuICAgIHZhciBrZXlzID0ge31cbiAgICB2YXIgZnJlZSA9IFtdXG4gICAgdmFyIGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXG4gICAgICAgIGlmIChjaGlsZC5rZXkpIHtcbiAgICAgICAgICAgIGtleXNbY2hpbGQua2V5XSA9IGlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyZWUucHVzaChpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5czoga2V5cywgICAgIC8vIEEgaGFzaCBvZiBrZXkgbmFtZSB0byBpbmRleFxuICAgICAgICBmcmVlOiBmcmVlICAgICAgLy8gQW4gYXJyYXkgb2YgdW5rZXllZCBpdGVtIGluZGljZXNcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFBhdGNoKGFwcGx5LCBwYXRjaCkge1xuICAgIGlmIChhcHBseSkge1xuICAgICAgICBpZiAoaXNBcnJheShhcHBseSkpIHtcbiAgICAgICAgICAgIGFwcGx5LnB1c2gocGF0Y2gpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBseSA9IFthcHBseSwgcGF0Y2hdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXBwbHlcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0Y2hcbiAgICB9XG59XG5cbn0se1wiLi4vdm5vZGUvaGFuZGxlLXRodW5rXCI6MzYsXCIuLi92bm9kZS9pcy10aHVua1wiOjM3LFwiLi4vdm5vZGUvaXMtdm5vZGVcIjozOSxcIi4uL3Zub2RlL2lzLXZ0ZXh0XCI6NDAsXCIuLi92bm9kZS9pcy13aWRnZXRcIjo0MSxcIi4uL3Zub2RlL3ZwYXRjaFwiOjQ0LFwiLi9kaWZmLXByb3BzXCI6NDYsXCJ4LWlzLWFycmF5XCI6MjF9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgdmRvbSA9IHtcbiAgVk5vZGU6IHJlcXVpcmUoJ3ZpcnR1YWwtZG9tL3Zub2RlL3Zub2RlJyksXG4gIFZUZXh0OiByZXF1aXJlKCd2aXJ0dWFsLWRvbS92bm9kZS92dGV4dCcpLFxuICBkaWZmOiByZXF1aXJlKCd2aXJ0dWFsLWRvbS9kaWZmJyksXG4gIHBhdGNoOiByZXF1aXJlKCd2aXJ0dWFsLWRvbS9wYXRjaCcpLFxuICBjcmVhdGVFbGVtZW50OiByZXF1aXJlKCd2aXJ0dWFsLWRvbS9jcmVhdGUtZWxlbWVudCcpLFxuICBzdmc6IHJlcXVpcmUoXCJ2aXJ0dWFsLWRvbS92aXJ0dWFsLWh5cGVyc2NyaXB0L3N2Z1wiKSxcbn07XG5cbmdsb2JhbC5WaXJ0dWFsRG9tID0gdmRvbTtcbm1vZHVsZS5leHBvcnRzID0gdmRvbTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcInZpcnR1YWwtZG9tL2NyZWF0ZS1lbGVtZW50XCI6MSxcInZpcnR1YWwtZG9tL2RpZmZcIjoyLFwidmlydHVhbC1kb20vcGF0Y2hcIjoyMixcInZpcnR1YWwtZG9tL3ZpcnR1YWwtaHlwZXJzY3JpcHQvc3ZnXCI6MzUsXCJ2aXJ0dWFsLWRvbS92bm9kZS92bm9kZVwiOjQzLFwidmlydHVhbC1kb20vdm5vZGUvdnRleHRcIjo0NX1dfSx7fSxbNDhdKSg0OClcbn0pO1xuIiwiLy8gVXNlZCBieSB3b3JrYXJvdW5kIGZvciBpbnB1dCBlbGVtZW50IHZhbHVlIGZpZWxkXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vTWF0dC1Fc2NoL3ZpcnR1YWwtZG9tL2Jsb2IvOTQ3ZWNmOTJiNjdkMjViYjY5M2EwZjYyNWZhOGU5MGMwOTk4ODdkNS92aXJ0dWFsLWh5cGVyc2NyaXB0L2hvb2tzL3NvZnQtc2V0LWhvb2suanNcblxuam9vX2dsb2JhbF9vYmplY3QuU29mdFNldEhvb2sgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2Z0U2V0SG9vaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb2Z0U2V0SG9vayh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufTtcblxuam9vX2dsb2JhbF9vYmplY3QuU29mdFNldEhvb2sucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgaWYgKG5vZGVbcHJvcGVydHlOYW1lXSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB0aGlzLnZhbHVlO1xuICAgIH1cbn07XG5cblxudmFyIEdlbmVyaWNIb29rID0gZnVuY3Rpb24gKGluaXQsIHVwZGF0ZSwgZGVzdHJveSwgaWQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2VuZXJpY0hvb2spKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0hvb2soaW5pdCwgdXBkYXRlLCBkZXN0cm95LCBpZCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICB0aGlzLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIHRoaXMuaWQgPSBpZDtcbn07XG5cbkdlbmVyaWNIb29rLmNhblRyYW5zaXRpb24gPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gZnJvbSBpbnN0YW5jZW9mIHRoaXMgJiYgdG8gaW5zdGFuY2VvZiB0aGlzICYmIGZyb20uaWQgPT09IHRvLmlkICYmIHRvLnVwZGF0ZTtcbn07XG5cbkdlbmVyaWNIb29rLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5vZGUsIHByb3BOYW1lLCBwcmV2KSB7XG4gICAgaWYgKEdlbmVyaWNIb29rLmNhblRyYW5zaXRpb24ocHJldiwgdGhpcykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMudXBkYXRlKHByZXYuc3RhdGUsIG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmluaXQobm9kZSk7XG4gICAgfVxufTtcblxuR2VuZXJpY0hvb2sucHJvdG90eXBlLnVuaG9vayA9IGZ1bmN0aW9uIChub2RlLCBwcm9wTmFtZSwgbmV4dCkge1xuICAgIGlmIChHZW5lcmljSG9vay5jYW5UcmFuc2l0aW9uKHRoaXMsIG5leHQpKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcsIHRoZSBpbXBlbmRpbmcgW2hvb2tdIHdpbGwgaGFuZGxlIHRoZSBjYWxsIHRvIHVwZGF0ZS5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlc3Ryb3kodGhpcy5zdGF0ZSwgbm9kZSk7XG4gICAgfVxufTtcblxuam9vX2dsb2JhbF9vYmplY3QuR2VuZXJpY0hvb2sgPSBHZW5lcmljSG9vaztcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mZnNldFxudmFyIGNhbWxfaW50NjRfb2Zmc2V0ID0gTWF0aC5wb3coMiwgLTI0KTtcblxuLy9Qcm92aWRlczogTWxJbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIE1sSW50NjQgKGxvLG1pLGhpKSB7XG4gIHRoaXMubG8gPSBsbyAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gbWkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IGhpICYgMHhmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9qXCJcbk1sSW50NjQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvLHRoaXMubWksdGhpcy5oaSk7XG59XG5cbk1sSW50NjQucHJvdG90eXBlLnVjb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgaWYgKHRoaXMuaGkgPiB4LmhpKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMuaGkgPCB4LmhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaSA8PCAxNjtcbiAgdmFyIHhoaSA9IHguaGkgPDwgMTY7XG4gIGlmIChoaSA+IHhoaSkgcmV0dXJuIDE7XG4gIGlmIChoaSA8IHhoaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG8gPSAtIHRoaXMubG87XG4gIHZhciBtaSA9IC0gdGhpcy5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IC0gdGhpcy5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKyB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pICsgeC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgKyB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAtIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgLSB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSAtIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICogeC5sbztcbiAgdmFyIG1pID0gKChsbyAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5taSAqIHgubG8gKyB0aGlzLmxvICogeC5taTtcbiAgdmFyIGhpID0gKChtaSAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5oaSAqIHgubG8gKyB0aGlzLm1pICogeC5taSArIHRoaXMubG8gKiB4LmhpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5sb3x0aGlzLm1pfHRoaXMuaGkpID09IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmhpIDw8IDE2KSA8IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyAmIHgubG8sIHRoaXMubWkgJiB4Lm1pLCB0aGlzLmhpICYgeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvfHgubG8sIHRoaXMubWl8eC5taSwgdGhpcy5oaXx4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvXngubG8sIHRoaXMubWleeC5taSwgdGhpcy5oaV54LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X2xlZnQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNCkge1xuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5sbyA8PCBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgcykgfCAodGhpcy5sbyA+PiAoMjQgLSBzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5oaSA8PCBzKSB8ICh0aGlzLm1pID4+ICgyNCAtIHMpKSk7XG4gIH1cbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvIDw8IChzIC0gMjQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgKHMgLSAyNCkpIHwgKHRoaXMubG8gPj4gKDQ4IC0gcykpKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KDAsIDAsIHRoaXMubG8gPDwgKHMgLSA0OCkpXG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodF91bnNpZ25lZCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKHRoaXMuaGkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gcykpO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiAocyAtIDI0KSksXG4gICAgICAwKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmhpID4+IChzIC0gNDgpLCAwLCAwKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIHZhciBoID0gKHRoaXMuaGkgPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKGggPDwgKDI0IC0gcykpLFxuICAgICAgKCh0aGlzLmhpIDw8IDE2KSA+PiBzKSA+Pj4gMTYpO1xuICB2YXIgc2lnbiA9ICh0aGlzLmhpIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMjQpID4+IDE2LFxuICAgICAgc2lnbiAmIDB4ZmZmZik7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMzIpLCBzaWduLCBzaWduKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzbDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGkgPSAodGhpcy5oaSA8PCAxKSB8ICh0aGlzLm1pID4+IDIzKTtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA8PCAxKSB8ICh0aGlzLmxvID4+IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5sbyA9ICh0aGlzLmxvIDw8IDEpICYgMHhmZmZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc3IxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxKSB8ICh0aGlzLm1pIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA+Pj4gMSkgfCAodGhpcy5oaSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSB0aGlzLmhpID4+PiAxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudWRpdm1vZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgbW9kdWx1cyA9IHRoaXMuY29weSgpO1xuICB2YXIgZGl2aXNvciA9IHguY29weSgpO1xuICB2YXIgcXVvdGllbnQgPSBuZXcgTWxJbnQ2NCgwLDAsMCk7XG4gIHdoaWxlIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID4gMCkge1xuICAgIG9mZnNldCsrO1xuICAgIGRpdmlzb3IubHNsMSgpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldCAtLTtcbiAgICBxdW90aWVudC5sc2wxKCk7XG4gICAgaWYgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPj0gMCkge1xuICAgICAgcXVvdGllbnQubG8gKys7XG4gICAgICBtb2R1bHVzID0gbW9kdWx1cy5zdWIoZGl2aXNvcik7XG4gICAgfVxuICAgIGRpdmlzb3IubHNyMSgpO1xuICB9XG4gIHJldHVybiB7IHF1b3RpZW50IDogcXVvdGllbnQsIG1vZHVsdXMgOiBtb2R1bHVzIH07XG59XG5NbEludDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpIF4geS5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciBxID0geC51ZGl2bW9kKHkpLnF1b3RpZW50O1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgcSA9IHEubmVnKCk7XG4gIHJldHVybiBxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciByID0geC51ZGl2bW9kKHkpLm1vZHVsdXM7XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gci5uZWcoKTtcbiAgcmV0dXJuIHI7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAodGhpcy5taSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0Zsb2F0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLmhpIDw8IDE2KSAqIE1hdGgucG93KDIsIDMyKSArIHRoaXMubWkgKiBNYXRoLnBvdygyLCAyNCkpICsgdGhpcy5sbztcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbdGhpcy5oaSA+PiA4LFxuICAgICAgICAgIHRoaXMuaGkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgPj4gMTYsXG4gICAgICAgICAgKHRoaXMubWkgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gPj4gMTYsXG4gICAgICAgICAgKHRoaXMubG8gPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gJiAweGZmXTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxvMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKCh0aGlzLm1pICYgMHhmZikgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaGkzMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5taSA+Pj4gOCkgJiAweGZmZmYpIHwgKHRoaXMuaGkgPDwgMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCx5KSB7IHJldHVybiB4LnVjb21wYXJlKHkpIDwgMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY29tcGFyZSh4LHksIHRvdGFsKSB7IHJldHVybiB4LmNvbXBhcmUoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X25lZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9uZWcgKHgpIHsgcmV0dXJuIHgubmVnKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FkZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hZGQgKHgsIHkpIHsgcmV0dXJuIHguYWRkKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViICh4LCB5KSB7IHJldHVybiB4LnN1Yih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tdWwoeCx5KSB7IHJldHVybiB4Lm11bCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfemVybyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc196ZXJvKHgpIHsgcmV0dXJuICt4LmlzWmVybygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkgeyByZXR1cm4gK3guaXNOZWcoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FuZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hbmQgKHgsIHkpIHsgcmV0dXJuIHguYW5kKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IgKHgsIHkpIHsgcmV0dXJuIHgub3IoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF94b3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfeG9yICh4LCB5KSB7IHJldHVybiB4Lnhvcih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X2xlZnQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZGl2IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2RpdiAoeCwgeSkgeyByZXR1cm4geC5kaXYoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QgKHgsIHkpIHsgcmV0dXJuIHgubW9kKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9pbnQzMiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2ludDMyICh4KSB7IHJldHVybiB4LnRvSW50KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2Zsb2F0ICh4KSB7IHJldHVybiB4LnRvRmxvYXQgKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoeCkge1xuICBpZiAoeCA8IDApIHggPSBNYXRoLmNlaWwoeCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICB4ICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQgKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQgKGZtdCwgeCkge1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSkge1xuICAgIGYuc2lnbiA9IC0xOyB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIHZhciB3YmFzZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZi5iYXNlKTtcbiAgdmFyIGN2dGJsID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIGRvIHtcbiAgICB2YXIgcCA9IHgudWRpdm1vZCh3YmFzZSk7XG4gICAgeCA9IHAucXVvdGllbnQ7XG4gICAgYnVmZmVyID0gY3Z0YmwuY2hhckF0KGNhbWxfaW50NjRfdG9faW50MzIocC5tb2R1bHVzKSkgKyBidWZmZXI7XG4gIH0gd2hpbGUgKCEgY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBidWZmZXIubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgYnVmZmVyID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9XG4gICAgICBuZXcgTWxJbnQ2NCgweGZmZmZmZiwgMHhmZmZmZmZmLCAweGZmZmYpLnVkaXZtb2QoYmFzZTY0KS5xdW90aWVudDtcbiAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIG11bHRpcGxpY2F0aW9uIGJhc2UgKiByZXMgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQodGhyZXNob2xkLCByZXMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X2FkZChjYW1sX2ludDY0X211bChiYXNlNjQsIHJlcyksIGQpO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBhZGRpdGlvbiAoYmFzZSAqIHJlcykgKyBkICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChiYXNlID09IDEwICYmIGNhbWxfaW50NjRfdWx0KG5ldyBNbEludDY0KDAsIDAsIDB4ODAwMCksIHJlcykpXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduIDwgMCkgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGxvLCBtaSwgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsbywgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgIGxvICYgMHhmZmZmZmYsXG4gICAgKChsbyA+Pj4gMjQpICYgMHhmZikgfCAoKGhpICYgMHhmZmZmKSA8PCA4KSxcbiAgICAoaGkgPj4+IDE2KSAmIDB4ZmZmZik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xvMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbG8zMih2KXsgcmV0dXJuIHYubG8zMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oaTMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hpMzIodil7IHJldHVybiB2LmhpMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoYVs3XSA8PCAwIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzRdIDw8IDAgfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbMV0gPDwgMCB8IChhWzBdIDw8IDgpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkgeyByZXR1cm4geC50b0FycmF5KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hhc2ggY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGFzaCh2KXtcbiAgcmV0dXJuICh2LmxvMzIoKSkgXiAodi5oaTMyKCkpXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIGlmKG4gPT0gMCkgcmV0dXJuIFwiXCI7XG4gIGlmIChzLnJlcGVhdCkge3JldHVybiBzLnJlcGVhdChuKTt9IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09IDAgJiYgbGVuIDw9IDQwOTYgJiYgbGVuID09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseSAobnVsbCwgYSk7XG4gIHZhciBzID0gXCJcIjtcbiAgZm9yICg7IDAgPCBsZW47IGkgKz0gMTAyNCxsZW4tPTEwMjQpXG4gICAgcyArPSBmLmFwcGx5IChudWxsLCBhLnNsaWNlKGksaSArIE1hdGgubWluKGxlbiwgMTAyNCkpKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmOF9vZl91dGYxNlxuZnVuY3Rpb24gY2FtbF91dGY4X29mX3V0ZjE2KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBiLCBjLCBkLCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYyA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IChjID4+IDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGRiZmYgfHwgaSArIDEgPT0gbCB8fFxuICAgICAgICAgICAgICAgKGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBkID4gMHhkZmZmKSB7XG4gICAgICAvLyBVbm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIsIHJlcGxhY2VkIGJ5IFxcdWZmZmQgKHJlcGxhY2VtZW50IGNoYXJhY3RlcilcbiAgICAgIHQgKz0gXCJcXHhlZlxceGJmXFx4YmRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IChjIDw8IDEwKSArIGQgLSAweDM1ZmRjMDA7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3V0ZjE2X29mX3V0Zjgocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IFwiXCIsIGMsIGMxLCBjMiwgdiwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMxID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjMSA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgdiA9IDE7XG4gICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgIGMgPSBjMiArIChjMSA8PCA2KTtcbiAgICAgIGlmIChjMSA8IDB4ZTApIHtcbiAgICAgICAgdiA9IGMgLSAweDMwODA7XG4gICAgICAgIGlmICh2IDwgMHg4MCkgdiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gMjtcbiAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgICAgICBjID0gYzIgKyAoYyA8PCA2KTtcbiAgICAgICAgICBpZiAoYzEgPCAweGYwKSB7XG4gICAgICAgICAgICB2ID0gYyAtIDB4ZTIwODA7XG4gICAgICAgICAgICBpZiAoKHYgPCAweDgwMCkgfHwgKCh2ID49IDB4ZDdmZikgJiYgKHYgPCAweGUwMDApKSkgdiA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYzEgPCAweGY1KSkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkgeyAvLyBJbnZhbGlkIHNlcXVlbmNlXG4gICAgICBpIC09IHY7XG4gICAgICB0ICs9IFwiXFx1ZmZmZFwiO1xuICAgIH0gZWxzZSBpZiAodiA+IDB4ZmZmZilcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ3YzAgKyAodiA+PiAxMCksIDB4ZGMwMCArICh2ICYgMHgzRkYpKVxuICAgIGVsc2VcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTtcbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29faXNfYXNjaWlcbmZ1bmN0aW9uIGpzb29faXNfYXNjaWkgKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgLy8gVGhlIE9DYW1sIGNvbXBpbGVyIHVzZXMgQ2hhci51bnNhZmVfY2hyIG9uIGludGVnZXJzIGxhcmdlciB0aGFuIDI1NSFcbiAgYyAmPSAweGZmO1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICBpZiAoaSArIDEgPT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MTZcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDY0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyAocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWpzb29faXNfYXNjaWkocykpXG4gICAgdGFnID0gOCAvKiBCWVRFUyB8IE5PVF9BU0NJSSAqLywgcyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRhZywgcywgcy5sZW5ndGgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gTWxCeXRlcyAodGFnLCBjb250ZW50cywgbGVuZ3RoKSB7XG4gIHRoaXMudD10YWc7IHRoaXMuYz1jb250ZW50czsgdGhpcy5sPWxlbmd0aDtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgc3dpdGNoICh0aGlzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyh0aGlzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoanNvb19pc19hc2NpaSh0aGlzLmMpKSB7XG4gICAgICB0aGlzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHRoaXMuYztcbiAgICB9XG4gICAgdGhpcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgfVxufTtcbk1sQnl0ZXMucHJvdG90eXBlLnRvVXRmMTYgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIGlmKHRoaXMudCA9PSA5KSByZXR1cm4gclxuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHIpO1xufVxuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT0gNCA/IHRoaXMuYy5zbGljZSgpIDogdGhpcy5jO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LGNvbnRlbnQsdGhpcy5sKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQllURVMgKi9cbiAgaWYgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8pXG4gICAgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCAnXFwwJylcbiAgZWxzZVxuICAgIHMuYyA9IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHMubCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkocy5sKTtcbiAgfVxuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciBsID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLDAsYS5sZW5ndGgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9maWxsX2J5dGVzXG52YXIgY2FtbF9maWxsX3N0cmluZyA9IGNhbWxfZmlsbF9ieXRlc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKGEsYixjLGQsZSkge1xuICAgIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhhKSxiLGMsZCxlKTtcbiAgICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ191bnNhZmVfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubGVuZ3RoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8tMTooczEgPiBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPD0gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gICAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMuYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNhbWxfanNieXRlc19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIHM7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICBpZiAoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKVxuICBlbHNlIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocyxpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19jb21wYXJlXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19jb21wYXJlKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB7IHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIGlmICgocy50ICYgNikgIT0gMCAvKiBCWVRFUyAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyl7XG4gIHJldHVybiBzLnRvVXRmMTYoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gKHMgaW5zdGFuY2VvZiBNbEJ5dGVzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWlcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3QocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgaWYoZi5mdW4pXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5mdW4sIGFyZ3MpO1xuICAvL0ZJWE1FLCBjYW4gaGFwcGVuIHdpdGggdG9vIG1hbnkgYXJndW1lbnRzXG4gIGlmKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmO1xuICB2YXIgbiA9IGYubGVuZ3RoIHwgMDtcbiAgaWYobiA9PT0gMCkgcmV0dXJuIGYuYXBwbHkobnVsbCxhcmdzKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aCB8IDA7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW4gfCAwO1xuICBpZiAoZCA9PSAwKVxuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBlbHNlIGlmIChkIDwgMCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKXtcbiAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoK2V4dHJhX2FyZ3MpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYobmFtZV9vcHQgJiYgam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYyhuYW1lX29wdCk7XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3ByaW50YWJsZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2lzX3ByaW50YWJsZShjKSB7IHJldHVybiArKGMgPiAzMSAmJiBjIDwgMTI3KTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBGb3JtYXRcblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9mb3JtYXQgKGZtdCkge1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIHZhciBsZW4gPSBmbXQubGVuZ3RoO1xuICBpZiAobGVuID4gMzEpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImZvcm1hdF9pbnQ6IGZvcm1hdCB0b28gbG9uZ1wiKTtcbiAgdmFyIGYgPVxuICAgICAgeyBqdXN0aWZ5OicrJywgc2lnbnN0eWxlOictJywgZmlsbGVyOicgJywgYWx0ZXJuYXRlOmZhbHNlLFxuICAgICAgICBiYXNlOjAsIHNpZ25lZGNvbnY6ZmFsc2UsIHdpZHRoOjAsIHVwcGVyY2FzZTpmYWxzZSxcbiAgICAgICAgc2lnbjoxLCBwcmVjOi0xLCBjb252OidmJyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgIGNhc2UgJy0nOlxuICAgICAgZi5qdXN0aWZ5ID0gJy0nOyBicmVhaztcbiAgICBjYXNlICcrJzogY2FzZSAnICc6XG4gICAgICBmLnNpZ25zdHlsZSA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJzAnOlxuICAgICAgZi5maWxsZXIgPSAnMCc7IGJyZWFrO1xuICAgIGNhc2UgJyMnOlxuICAgICAgZi5hbHRlcm5hdGUgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzogY2FzZSAnNSc6XG4gICAgY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICBmLndpZHRoID0gMDtcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi53aWR0aCA9IGYud2lkdGggKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLic6XG4gICAgICBmLnByZWMgPSAwO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLnByZWMgPSBmLnByZWMgKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgIGNhc2UgJ2QnOiBjYXNlICdpJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAndSc6XG4gICAgICBmLmJhc2UgPSAxMDsgYnJlYWs7XG4gICAgY2FzZSAneCc6XG4gICAgICBmLmJhc2UgPSAxNjsgYnJlYWs7XG4gICAgY2FzZSAnWCc6XG4gICAgICBmLmJhc2UgPSAxNjsgZi51cHBlcmNhc2UgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICdvJzpcbiAgICAgIGYuYmFzZSA9IDg7IGJyZWFrO1xuICAgIGNhc2UgJ2UnOiBjYXNlICdmJzogY2FzZSAnZyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLmNvbnYgPSBjOyBicmVhaztcbiAgICBjYXNlICdFJzogY2FzZSAnRic6IGNhc2UgJ0cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi51cHBlcmNhc2UgPSB0cnVlO1xuICAgICAgZi5jb252ID0gYy50b0xvd2VyQ2FzZSAoKTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHJhd2J1ZmZlcikge1xuICBpZiAoZi51cHBlcmNhc2UpIHJhd2J1ZmZlciA9IHJhd2J1ZmZlci50b1VwcGVyQ2FzZSgpO1xuICB2YXIgbGVuID0gcmF3YnVmZmVyLmxlbmd0aDtcbiAgLyogQWRqdXN0IGxlbiB0byByZWZsZWN0IGFkZGl0aW9uYWwgY2hhcnMgKHNpZ24sIGV0YykgKi9cbiAgaWYgKGYuc2lnbmVkY29udiAmJiAoZi5zaWduIDwgMCB8fCBmLnNpZ25zdHlsZSAhPSAnLScpKSBsZW4rKztcbiAgaWYgKGYuYWx0ZXJuYXRlKSB7XG4gICAgaWYgKGYuYmFzZSA9PSA4KSBsZW4gKz0gMTtcbiAgICBpZiAoZi5iYXNlID09IDE2KSBsZW4gKz0gMjtcbiAgfVxuICAvKiBEbyB0aGUgZm9ybWF0dGluZyAqL1xuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJyAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIGlmIChmLnNpZ25lZGNvbnYpIHtcbiAgICBpZiAoZi5zaWduIDwgMCkgYnVmZmVyICs9ICctJztcbiAgICBlbHNlIGlmIChmLnNpZ25zdHlsZSAhPSAnLScpIGJ1ZmZlciArPSBmLnNpZ25zdHlsZTtcbiAgfVxuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDgpIGJ1ZmZlciArPSAnMCc7XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gMTYpIGJ1ZmZlciArPSBcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcwJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJzAnO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09ICctJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhidWZmZXIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGpzb29fZmxvb3JfbG9nMlxudmFyIGxvZzJfb2sgPSBNYXRoLmxvZzIgJiYgTWF0aC5sb2cyKDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3KSA9PSAxMDIwXG5mdW5jdGlvbiBqc29vX2Zsb29yX2xvZzIoeCkge1xuICBpZihsb2cyX29rKSByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZzIoeCkpXG4gIHZhciBpID0gMDtcbiAgaWYgKHggPT0gMCkgcmV0dXJuIC1JbmZpbml0eTtcbiAgaWYoeD49MSkge3doaWxlICh4Pj0yKSB7eC89MjsgaSsrfSB9XG4gIGVsc2Uge3doaWxlICh4IDwgMSkge3gqPTI7IGktLX0gfTtcbiAgcmV0dXJuIGk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMSwgMCwgMHg3ZmYwKTtcbiAgICBpZiAoeCA+IDApXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHg3ZmYwKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweGZmZjApXG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8weDgwMDA6KHg+PTApPzA6MHg4MDAwO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICAvLyBJbnQ2NC5iaXRzX29mX2Zsb2F0IDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3ID0gMHg3ZmIwMDAwMDAwMDAwMDAwTFxuICAvLyB1c2luZyBNYXRoLkxPRzJFKk1hdGgubG9nKHgpIGluIHBsYWNlIG9mIE1hdGgubG9nMiByZXN1bHQgaW4gcHJlY2lzaW9uIGxvc3RcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDEwMjM7XG4gIGlmIChleHAgPD0gMCkge1xuICAgIGV4cCA9IDA7XG4gICAgeCAvPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgfSBlbHNlIHtcbiAgICB4IC89IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICAgIGlmICh4IDwgMTYpIHtcbiAgICAgIHggKj0gMjsgZXhwIC09MTsgfVxuICAgIGlmIChleHAgPT0gMCkge1xuICAgICAgeCAvPSAyOyB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLDI0KTtcbiAgdmFyIHIzID0geHwwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4fDA7XG4gIHggPSAoeCAtIHIyKSAqIGs7XG4gIHZhciByMSA9IHh8MDtcbiAgcjMgPSAocjMgJjB4ZikgfCBzaWduIHwgZXhwIDw8IDQ7XG4gIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShyMSwgcjIsIHIzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCAoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgdmFyIGNzdCA9IE1hdGgucG93KDIscHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZihwcmVjID49IDApe1xuICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGxvID0geC5sbztcbiAgdmFyIG1pID0geC5taTtcbiAgdmFyIGhpID0geC5oaTtcbiAgdmFyIGV4cCA9IChoaSAmIDB4N2ZmZikgPj4gNDtcbiAgaWYgKGV4cCA9PSAyMDQ3KSB7XG4gICAgaWYgKChsb3xtaXwoaGkmMHhmKSkgPT0gMClcbiAgICAgIHJldHVybiAoaGkgJiAweDgwMDApPygtSW5maW5pdHkpOkluZmluaXR5O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAobG8qayttaSkqaysoaGkmMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmIChoaSAmIDB4ODAwMCkgcmVzID0gLSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0ICh4LHkpIHtcbiAgaWYoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiBOYU47XG4gIGlmKHg9PXkpIHJldHVybiB5O1xuICBpZih4PT0wKXtcbiAgICBpZih5IDwgMClcbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgLTEwNzQpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMDc0KVxuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKCh4PHkpID09ICh4PjApKVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X2FkZChiaXRzLCBvbmUpXG4gIGVsc2VcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKVxuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGJpdHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RydW5jX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3RydW5jX2Zsb2F0KHgpe1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KDEpO1xuICBpbnQzMmFbMF0gPSB4O1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KGludDMyYS5idWZmZXIpO1xuICByZXR1cm4gZmxvYXQzMmFbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2xhc3NpZnlfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2xhc3NpZnlfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT0gMCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKHgpPzQ6Mztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICB2YXIgbmVnID0gKDEveCkgPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IgKHgpO1xuICAgIHZhciBmID0geCAtIGk7XG4gICAgaWYgKG5lZykgeyBpID0gLWk7IGYgPSAtZjsgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKGlzTmFOICh4KSkgcmV0dXJuIFswLCBOYU4sIE5hTl07XG4gIHJldHVybiBbMCwgMS94LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQgKHgsZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHsgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9mcmV4cF9mbG9hdCAoeCkge1xuICBpZiAoKHggPT0gMCkgfHwgIWlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHZhciBleHAgPSBNYXRoLm1heCgtMTAyMywganNvb19mbG9vcl9sb2cyKHgpICsgMSk7XG4gIHggKj0gTWF0aC5wb3coMiwtZXhwKTtcbiAgd2hpbGUgKHggPCAwLjUpIHtcbiAgICB4ICo9IDI7XG4gICAgZXhwLS07XG4gIH1cbiAgd2hpbGUgKHggPj0gMSkge1xuICAgIHggKj0gMC41O1xuICAgIGV4cCsrO1xuICB9XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHJldHVybiBbMCwgeCwgZXhwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0X2NvbXBhcmUgKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHJldHVybiAwO1xuICBpZiAoeCA8IHkpIHJldHVybiAtMTtcbiAgaWYgKHggPiB5KSByZXR1cm4gMTtcbiAgaWYgKHggPT09IHgpIHJldHVybiAxO1xuICBpZiAoeSA9PT0geSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb3B5c2lnbl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3B5c2lnbl9mbG9hdCAoeCwgeSkge1xuICBpZiAoeSA9PSAwKSB5ID0gMSAvIHk7XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgcmV0dXJuICh5IDwgMCk/KC14KTp4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NpZ25iaXRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2lnbmJpdF9mbG9hdCh4KSB7XG4gIGlmICh4ID09IDApIHggPSAxIC8geDtcbiAgcmV0dXJuICh4IDwgMCk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4cG0xX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cG0xX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gTWF0aC5leHAoeCksIHogPSB5IC0gMTtcbiAgcmV0dXJuIChNYXRoLmFicyh4KT4xP3o6KHo9PTA/eDp4KnovTWF0aC5sb2coeSkpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sb2cxcF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxcF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IDEgKyB4LCB6ID0geSAtIDE7XG4gIHJldHVybiAoej09MD94OngqTWF0aC5sb2coeSkveik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaHlwb3RfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaHlwb3RfZmxvYXQgKHgsIHkpIHtcbiAgdmFyIHggPSBNYXRoLmFicyh4KSwgeSA9IE1hdGguYWJzKHkpO1xuICB2YXIgYSA9IE1hdGgubWF4KHgsIHkpLCBiID0gTWF0aC5taW4oeCx5KSAvIChhP2E6MSk7XG4gIHJldHVybiAoYSAqIE1hdGguc3FydCgxICsgYipiKSk7XG59XG5cbi8vIEZJWDogdGhlc2UgZml2ZSBmdW5jdGlvbnMgb25seSBnaXZlIGFwcHJveGltYXRlIHJlc3VsdHMuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzEwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzEwX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLkxPRzEwRSAqIE1hdGgubG9nKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Nvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaW5oX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF90YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3RhbmhfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IE1hdGguZXhwKC14KTtcbiAgcmV0dXJuICh5IC0geikgLyAoeSArIHopO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JvdW5kX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3JvdW5kX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZmxvYXQgKGZtdCwgeCkge1xuICBmdW5jdGlvbiB0b0ZpeGVkKHgsZHApIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPCAxLjApIHtcbiAgICAgIHJldHVybiB4LnRvRml4ZWQoZHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZSA9IHBhcnNlSW50KHgudG9TdHJpbmcoKS5zcGxpdCgnKycpWzFdKTtcbiAgICAgIGlmIChlID4gMjApIHtcbiAgICAgICAgZSAtPSAyMDtcbiAgICAgICAgeCAvPSBNYXRoLnBvdygxMCxlKTtcbiAgICAgICAgeCArPSAobmV3IEFycmF5KGUrMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgaWYoZHAgPiAwKSB7XG4gICAgICAgICAgeCA9IHggKyAnLicgKyAobmV3IEFycmF5KGRwKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBlbHNlIHJldHVybiB4LnRvRml4ZWQoZHApXG4gICAgfVxuICB9XG4gIHZhciBzLCBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgdmFyIHByZWMgPSAoZi5wcmVjIDwgMCk/NjpmLnByZWM7XG4gIGlmICh4IDwgMCB8fCAoeCA9PSAwICYmIDEveCA9PSAtSW5maW5pdHkpKSB7IGYuc2lnbiA9IC0xOyB4ID0gLXg7IH1cbiAgaWYgKGlzTmFOKHgpKSB7IHMgPSBcIm5hblwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlIGlmICghaXNGaW5pdGUoeCkpIHsgcyA9IFwiaW5mXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2VcbiAgICBzd2l0Y2ggKGYuY29udikge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgdmFyIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyk7XG4gICAgICAvLyBleHBvbmVudCBzaG91bGQgYmUgYXQgbGVhc3QgdHdvIGRpZ2l0c1xuICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZic6XG4gICAgICBzID0gdG9GaXhlZCh4LCBwcmVjKTsgYnJlYWs7XG4gICAgY2FzZSAnZyc6XG4gICAgICBwcmVjID0gcHJlYz9wcmVjOjE7XG4gICAgICBzID0geC50b0V4cG9uZW50aWFsKHByZWMgLSAxKTtcbiAgICAgIHZhciBqID0gcy5pbmRleE9mKCdlJyk7XG4gICAgICB2YXIgZXhwID0gK3Muc2xpY2UoaiArIDEpO1xuICAgICAgaWYgKGV4cCA8IC00IHx8IHggPj0gMWUyMSB8fCB4LnRvRml4ZWQoMCkubGVuZ3RoID4gcHJlYykge1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgIHZhciBpID0gaiAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSkgKyBzLnNsaWNlKGopO1xuICAgICAgICBpID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAgPSBwcmVjO1xuICAgICAgICBpZiAoZXhwIDwgMCkgeyBwIC09IGV4cCArIDE7IHMgPSB4LnRvRml4ZWQocCk7IH1cbiAgICAgICAgZWxzZSB3aGlsZSAocyA9IHgudG9GaXhlZChwKSwgcy5sZW5ndGggPiBwcmVjICsgMSkgcC0tO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHJlcztcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocylcbiAgcmVzID0gK3M7XG4gIGlmICgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csXCJcIik7XG4gIHJlcyA9ICtzO1xuICBpZiAoKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHx8IC9eWystXT9uYW4kL2kudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKilwKFsrLV0/WzAtOV0rKS9pLmV4ZWMocyk7XG4gIC8vICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNFxuICBpZihtKXtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sJycpO1xuICAgIHZhciBtYW50aXNzYSA9IHBhcnNlSW50KG1bMV0gKyBtWzJdICsgbTMsIDE2KTtcbiAgICB2YXIgZXhwb25lbnQgPSAobVs0XXwwKSAtIDQqbTMubGVuZ3RoO1xuICAgIHJlcyA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIEluZmluaXR5O1xuICBpZigvXi1pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gLUluZmluaXR5O1xuICBjYW1sX2ZhaWx3aXRoKFwiZmxvYXRfb2Zfc3RyaW5nXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbmlmKGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5pZihjYW1sX2N1cnJlbnRfZGlyLnNsaWNlKC0xKSAhPT0gXCIvXCIpIGNhbWxfY3VycmVudF9kaXIgKz0gXCIvXCJcblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG52YXIgY2FtbF9yb290ID0gY2FtbF9jdXJyZW50X2Rpci5tYXRjaCgvW15cXC9dKlxcLy8pWzBdO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYobmFtZS5jaGFyQ29kZUF0KDApICE9IDQ3KVxuICAgIG5hbWUgPSBjYW1sX2N1cnJlbnRfZGlyICsgbmFtZTtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgY2FzZSBcIlwiOiBpZihuY29tcC5sZW5ndGggPT0gMCkgbmNvbXAucHVzaChcIlwiKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCtcInN0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290K1wic3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiByZXNvbHZlX2ZzX2RldmljZShuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpO1xuICB2YXIgbmFtZV9zbGFzaCA9IG5hbWUgKyBcIi9cIjtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpuYW1lLGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKG5hbWUsZil9KVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bm1vdW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX21ha2VfcGF0aFxuZnVuY3Rpb24gY2FtbF91bm1vdW50KG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aCArIHJvb3QucmVzdCArIFwiL1wiO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShkaXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIG5hbWUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBuYW1lID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UucmVhZGRpcihyb290LnJlc3QpO1xuICB2YXIgbCA9IG5ldyBBcnJheShhLmxlbmd0aCArIDEpO1xuICBsWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspXG4gICAgbFtpKzFdID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKVxuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wKSBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9am9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNhbWxfY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlID0gY2FtbF9jcmVhdGVfZmlsZTtcbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciBjb250ZW50ID0gKHR5cGVvZiBjb250ZW50ID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY29udGVudCk6Y29udGVudDtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiAgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3N0YXRpY19lbnZcbmZ1bmN0aW9uIGNhbWxfc2V0X3N0YXRpY19lbnYoayx2KXtcbiAgaWYoIWpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudilcbiAgICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZba10gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG4gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltuXSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuYXJndlxuICAgICAmJiBnLnByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBnLnByb2Nlc3MuYXJndlxuICAgIC8vbm9kZWpzXG4gICAgbWFpbiA9IGFyZ3ZbMV07XG4gICAgYXJncyA9IGFyZ3Yuc2xpY2UoMik7XG4gIH1cblxuICB2YXIgcCA9IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKG1haW4pO1xuICB2YXIgYXJnczIgPSBbMCwgcF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxuICAgIGFyZ3MyLnB1c2goY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoYXJnc1tpXSkpO1xuICByZXR1cm4gYXJnczI7XG59KSgpKVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG52YXIgY2FtbF9leGVjdXRhYmxlX25hbWUgPSBjYW1sX2FyZ3ZbMV1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2FyZ3YgKGEpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2FyZ3ZbMV0sIGNhbWxfYXJndl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfYXJndiAoYSkge1xuICByZXR1cm4gY2FtbF9hcmd2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19tb2RpZnlfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19tb2RpZnlfYXJndihhcmcpe1xuICBjYW1sX2FyZ3YgPSBhcmc7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG5mdW5jdGlvbiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUoYSl7XG4gIHJldHVybiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHZhciBjbWQgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT0gXCJ1bmRlZmluZWRcIlxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMpIHtcbiAgICB0cnkge3JlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYyhjbWQse3N0ZGlvOiAnaW5oZXJpdCd9KTsgcmV0dXJuIDB9XG4gICAgY2F0Y2ggKGUpIHtyZXR1cm4gMX1cbiAgfVxuICBlbHNlIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmFuZG9tX3NlZWQgbXV0YWJsZVxuLy9UaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIGFuIGFycmF5IHNpbmNlIE9DYW1sIDQuMC4uLlxuZnVuY3Rpb24gY2FtbF9zeXNfcmFuZG9tX3NlZWQgKCkge1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiAxOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9jb25maWcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9jb25maWcgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJVbml4XCIpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUoX2NoYW5uZWwpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcIlNwYWNldGltZSBwcm9maWxpbmcgb25seSB3b3JrcyBmb3IgbmF0aXZlIGNvZGVcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2FycmF5LCBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuZnVuY3Rpb24gTWxGYWtlRGV2aWNlIChyb290LCBmKSB7XG4gIHRoaXMuY29udGVudD17fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24obmFtZSkge1xuICBpZighdGhpcy5jb250ZW50W25hbWVdICYmIHRoaXMubG9va3VwRnVuKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMubG9va3VwRnVuKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5yb290KSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKSk7XG4gICAgaWYocmVzICE9PSAwKSB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcocmVzWzFdKSk7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCk7XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZiAobi5tYXRjaChyKSkgcmV0dXJuIDFcbiAgfVxuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0pIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIHZhciBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjYW1sX2lzX21sX2J5dGVzKGNvbnRlbnQpKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBpZihjYW1sX2lzX21sX3N0cmluZyhjb250ZW50KSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBieXRlcyA9IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNvbnRlbnQudG9TdHJpbmcoKSkpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGJ5dGVzKTtcbiAgfVxuICBlbHNlIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IHJlZ2lzdGVyaW5nIGZpbGUgd2l0aCBpbnZhbGlkIGNvbnRlbnQgdHlwZVwiKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfc3RyaW5nKGJ1ZiwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX2dldCh0aGlzLmRhdGEsIG9mZnNldCk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MucGxhdGZvcm0gIT09IFwiYnJvd3NlclwiKVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmlsZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0RpcmVjdG9yeSgpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gICAgdGhpcy5mcy51bmxpbmtTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgZmQgPSB0aGlzLmZzLm9wZW5TeW5jKHRoaXMubm0obmFtZSksIHJlcyk7XG4gICAgcmV0dXJuIG5ldyBNbE5vZGVGaWxlKGZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obyxuKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGUsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzLCBjYW1sX2J5dGVzX3NldCwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZUZpbGUoZmQpe1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5mZCA9IGZkO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9zdHJpbmcoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpKVxuICAgIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhKTtcbiAgdmFyIGJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9ieXRlcyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgY2FtbF9ieXRlc19zZXQoYnVmLGJ1Zl9vZmZzZXQgKyBpLGJ1ZmZlcltidWZfb2Zmc2V0K2ldKTtcbiAgfVxuICByZXR1cm4gMFxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KDEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIDAsIDEsIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyWzBdO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVGaWxlO1xuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheSh4KTtcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC4gVGhlICsyIHRvIGFycmF5IGxlbmd0aCBzZWVtcyB0byB3b3JrLlxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2dldCgpIHtcbiAgaWYoY2FtbF9ncl9zdGF0ZSkge1xuICAgIHJldHVybiBjYW1sX2dyX3N0YXRlO1xuICB9XG4gIHRocm93IFswLGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIildXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZSxjYW1sX2dyX3N0YXRlX2luaXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCkge1xuICBjYW1sX2dyX3N0YXRlPWN0eDtcbiAgY2FtbF9ncl9zdGF0ZV9pbml0KClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX2dyYXBoKGluZm8pe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgaW5mbyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGluZm8pO1xuICBmdW5jdGlvbiBnZXQobmFtZSl7XG4gICAgdmFyIHJlcyA9IGluZm8ubWF0Y2goXCIoXnwsKSAqXCIrbmFtZStcIiAqPSAqKFthLXpBLVowLTlfXSspICooLHwkKVwiKTtcbiAgICBpZihyZXMpIHJldHVybiByZXNbMl07XG4gIH1cbiAgdmFyIHNwZWNzID0gW107XG4gIGlmKCEoaW5mbz09XCJcIikpIHNwZWNzLnB1c2goaW5mbyk7XG4gIHZhciB0YXJnZXQgPSBnZXQoXCJ0YXJnZXRcIik7XG4gIGlmKCF0YXJnZXQpIHRhcmdldD1cIlwiO1xuICB2YXIgc3RhdHVzID0gZ2V0KFwic3RhdHVzXCIpO1xuICBpZighc3RhdHVzKSBzcGVjcy5wdXNoKFwic3RhdHVzPTFcIilcblxuICB2YXIgdyA9IGdldChcIndpZHRoXCIpO1xuICB3ID0gdz9wYXJzZUludCh3KToyMDA7XG4gIHNwZWNzLnB1c2goXCJ3aWR0aD1cIit3KTtcblxuICB2YXIgaCA9IGdldChcImhlaWdodFwiKTtcbiAgaCA9IGg/cGFyc2VJbnQoaCk6MjAwO1xuICBzcGVjcy5wdXNoKFwiaGVpZ2h0PVwiK2gpO1xuXG4gIHZhciB3aW4gPSBnLm9wZW4oXCJhYm91dDpibGFua1wiLHRhcmdldCxzcGVjcy5qb2luKFwiLFwiKSk7XG4gIGlmKCF3aW4pIHtjYW1sX2ZhaWx3aXRoKFwiR3JhcGhpY3Mub3Blbl9ncmFwaDogY2Fubm90IG9wZW4gdGhlIHdpbmRvd1wiKX1cbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgdmFyIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSB3O1xuICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgdmFyIGN0eCA9IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpO1xuICBjdHguc2V0X3RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgZG9jLnRpdGxlID0gdGl0bGU7XG4gIH07XG4gIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCk7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIGJvZHkuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9jb2xvcixjYW1sX2dyX21vdmV0byxjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgsY2FtbF9ncl9zZXRfdGV4dF9zaXplLGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9pbml0KCl7XG4gIGNhbWxfZ3JfbW92ZXRvKGNhbWxfZ3Jfc3RhdGUueCxjYW1sX2dyX3N0YXRlLnkpO1xuICBjYW1sX2dyX3Jlc2l6ZV93aW5kb3coY2FtbF9ncl9zdGF0ZS53aWR0aCxjYW1sX2dyX3N0YXRlLmhlaWdodCk7XG4gIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgoY2FtbF9ncl9zdGF0ZS5saW5lX3dpZHRoKTtcbiAgY2FtbF9ncl9zZXRfdGV4dF9zaXplKGNhbWxfZ3Jfc3RhdGUudGV4dF9zaXplKTtcbiAgY2FtbF9ncl9zZXRfZm9udChjYW1sX2dyX3N0YXRlLmZvbnQpO1xuICBjYW1sX2dyX3NldF9jb2xvcihjYW1sX2dyX3N0YXRlLmNvbG9yKTtcbiAgY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKGNhbWxfZ3Jfc3RhdGUudGl0bGUpO1xuICAvL2NhbWxfZ3JfcmVzaXplX3dpbmRvdyBtaWdodCByZXNldCBzb21lIGNhbnZhcycgcHJvcGVydGllc1xuICBjYW1sX2dyX3N0YXRlLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKXtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgY2FudmFzIDogY2FudmFzLFxuICAgIHggOiAwLFxuICAgIHkgOiAwLFxuICAgIHdpZHRoIDogdyxcbiAgICBoZWlnaHQgOiBoLFxuICAgIGxpbmVfd2lkdGggOiAxLFxuICAgIGZvbnQgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiZml4ZWRcIiksXG4gICAgdGV4dF9zaXplIDogMjYsXG4gICAgY29sb3IgOiAweDAwMDAwMCxcbiAgICB0aXRsZSA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIilcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kb2Nfb2Zfc3RhdGVcbmZ1bmN0aW9uIGNhbWxfZ3JfZG9jX29mX3N0YXRlKHN0YXRlKSB7XG4gIGlmKHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50KVxuICAgIHJldHVybiBzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2VfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IDA7XG4gIHMuY2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKG5hbWUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGl0bGUgPSBuYW1lO1xuICB2YXIganNuYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKHMuc2V0X3RpdGxlKSBzLnNldF90aXRsZShqc25hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9yZXNpemVfd2luZG93KHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKVxuICBzLndpZHRoID0gdztcbiAgcy5oZWlnaHQgPSBoO1xuICBzLmNhbnZhcy53aWR0aCA9IHc7XG4gIHMuY2FudmFzLmhlaWdodCA9IGg7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NsZWFyX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbGVhcl9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gIC8vICBzLmNvbnRleHQuc3Ryb2tlUmVjdCAoMC4sIDAuLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMud2lkdGg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuaGVpZ2h0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfY29sb3IoY29sb3Ipe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGZ1bmN0aW9uIGNvbnZlcnQobnVtYmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDIpIHN0ciA9ICcwJyArIHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhclxuICByID0gKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gIGcgPSAoY29sb3IgPj4gOCkgICYgMHhmZixcbiAgYiA9IChjb2xvciA+PiAwKSAgJiAweGZmO1xuICBzLmNvbG9yPWNvbG9yO1xuICB2YXIgY19zdHIgPSAnIycgKyBjb252ZXJ0KHIpICsgY29udmVydChnKSArIGNvbnZlcnQoYik7XG4gIHMuY29udGV4dC5maWxsU3R5bGUgPSAgIGNfc3RyO1xuICBzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjX3N0cjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Bsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Bsb3QoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSgxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHZhciBjb2xvciA9IHMuY29sb3I7XG4gIGRbMF0gPSAoY29sb3IgPj4gMTYpICYgMHhmZjsgLy9yXG4gIGRbMV0gPSAoY29sb3IgPj4gOCkgICYgMHhmZiwgLy9nXG4gIGRbMl0gPSAoY29sb3IgPj4gMCkgICYgMHhmZjsgLy9iXG4gIGRbM10gPSAweEZGOyAvL2FcbiAgcy54PXg7XG4gIHMueT15O1xuICBzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltLHgscy5oZWlnaHQgLSB5KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcG9pbnRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3BvaW50X2NvbG9yKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIHksMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICByZXR1cm4gKGRbMF0gPDwgMTYpICsgKGRbMV0gPDwgOCkgKyBkWzJdO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9tb3ZldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21vdmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy54XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9saW5ldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2xpbmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLmNvbnRleHQubGluZVRvKHgscy5oZWlnaHQgLSB5KTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuc3Ryb2tlUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9hcmNfYXV4KGN0eCxjeCxjeSxyeSxyeCxhMSxhMil7XG4gIHdoaWxlKGExPmEyKSBhMis9MzYwO1xuICBhMSAvPSAxODA7XG4gIGEyIC89IDE4MDtcbiAgdmFyIHJvdCA9IDAseFBvcyx5UG9zLHhQb3NfcHJldix5UG9zX3ByZXY7XG4gIHZhciBzcGFjZSA9IDI7XG4gIHZhciBudW0gPSAoKChhMiAtIGExKSAqIE1hdGguUEkgKiAoKHJ4K3J5KS8yKSkgLyBzcGFjZSkgfCAwO1xuICB2YXIgZGVsdGEgPSAoYTIgLSBhMSkgKiBNYXRoLlBJIC8gbnVtO1xuICB2YXIgaSA9IGExICogTWF0aC5QSTtcbiAgZm9yICh2YXIgaj0wO2o8PW51bTtqKyspe1xuICAgIHhQb3MgPSBjeCAtIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeFBvcyA9IHhQb3MudG9GaXhlZCgyKTtcbiAgICB5UG9zID0gY3kgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHlQb3MgPSB5UG9zLnRvRml4ZWQoMik7XG4gICAgaWYgKGo9PTApIHtcbiAgICAgIGN0eC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgfSBlbHNlIGlmICh4UG9zX3ByZXYhPXhQb3MgfHwgeVBvc19wcmV2IT15UG9zKXtcbiAgICAgIGN0eC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgfVxuICAgIHhQb3NfcHJldj14UG9zO1xuICAgIHlQb3NfcHJldj15UG9zO1xuICAgIGktPSBkZWx0YTsvL2Njd1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfbGluZV93aWR0aCh3KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmxpbmVfd2lkdGggPSB3O1xuICBzLmNvbnRleHQubGluZVdpZHRoID0gd1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuZmlsbFJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3BvbHlcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcG9seShhcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgYXIubGVuZ3RoOyBpKyspXG4gICAgcy5jb250ZXh0LmxpbmVUbyhhcltpXVsxXSxzLmhlaWdodCAtIGFyW2ldWzJdKTtcbiAgcy5jb250ZXh0LmxpbmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHIoc3RyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgbSA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChzdHIpO1xuICB2YXIgZHggPSBtLndpZHRoO1xuICBzLmNvbnRleHQuZmlsbFRleHQoc3RyLHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMueCArPSBkeCB8IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfY2hhclxuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2NoYXIoYyl7XG4gIGNhbWxfZ3JfZHJhd19zdHIoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cmluZyhzdHIpe1xuICBjYW1sX2dyX2RyYXdfc3RyKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN0cikpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF9mb250KGYpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuZm9udCA9IGY7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF90ZXh0X3NpemUoc2l6ZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50ZXh0X3NpemUgPSBzaXplO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3RleHRfc2l6ZSh0eHQpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciB3ID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHR4dCkpLndpZHRoO1xuICByZXR1cm4gWzAsdyxzLnRleHRfc2l6ZV07XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9tYWtlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tYWtlX2ltYWdlKGFycil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGggPSBhcnIubGVuZ3RoIC0gMSA7XG4gIHZhciB3ID0gYXJyWzFdLmxlbmd0aCAtIDE7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodyxoKTtcbiAgZm9yKHZhciBpPTA7aTxoO2krKyl7XG4gICAgZm9yKHZhciBqPTA7ajx3O2orKyl7XG4gICAgICB2YXIgYyA9IGFycltpKzFdW2orMV07XG4gICAgICB2YXIgbyA9IGkqKHcqNCkgKyAoaiAqIDQpO1xuICAgICAgaWYoYyA9PSAtMSkge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IGMgPj4gMTYgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IGMgPj4gIDggJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IGMgPj4gIDAgJiAwWGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDB4ZmY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kdW1wX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kdW1wX2ltYWdlKGltKXtcbiAgdmFyIGRhdGEgPSBbMF1cbiAgZm9yKHZhciBpPTA7IGk8aW0uaGVpZ2h0O2krKyl7XG4gICAgZGF0YVtpKzFdID0gWzBdXG4gICAgZm9yKHZhciBqPTA7IGo8aW0ud2lkdGg7aisrKXtcbiAgICAgIHZhciBvID0gaSooaW0ud2lkdGgqNCkgKyAoaiAqIDQpLFxuICAgICAgICAgIHIgPSBpbS5kYXRhW28rMF0sXG4gICAgICAgICAgZyA9IGltLmRhdGFbbysxXSxcbiAgICAgICAgICBiID0gaW0uZGF0YVtvKzJdO1xuICAgICAgZGF0YVtpKzFdW2orMV0gPSAociA8PCAxNikgKyAoZyA8PCA4KSArIGJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGlmKCFpbS5pbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltLDAsMCk7XG4gICAgdmFyIGltYWdlID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9IGVsc2Uge1xuICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW0uaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgseSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxpbS53aWR0aCxpbS5oZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSsxXSA9IGltMi5kYXRhW2krMV07XG4gICAgaW0uZGF0YVtpKzJdID0gaW0yLmRhdGFbaSsyXTtcbiAgICBpbS5kYXRhW2krM10gPSBpbTIuZGF0YVtpKzNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX3NpZ25hbCgpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dhaXRfZXZlbnQgbm90IEltcGxlbWVudGVkOiB1c2UgR3JhcGhpY3NfanMgaW5zdGVhZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zeW5jaHJvbml6ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9zeW5jaHJvbml6ZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSxiLGMsZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjICgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAoKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgZnVuY3Rpb24gZ2V0MzIocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSA8PCA4KSB8XG4gICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICB9XG4gIGlmIChnZXQzMihzLCBvZnMpICE9ICgweDg0OTVBNkJFfDApKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgcmV0dXJuIChnZXQzMihzLCBvZnMgKyA0KSk7XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuV2Vha01hcCgpO1xuICB9O1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5sb29rdXAuc2V0KHYsIHRoaXMub2Jqcy5sZW5ndGgpO1xuICB0aGlzLm9ianMucHVzaCh2KTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUucmVjYWxsID0gZnVuY3Rpb24odikge1xuICB2YXIgaSA9IHRoaXMubG9va3VwLmdldCh2KTtcbiAgcmV0dXJuIChpID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWQgOiB0aGlzLm9ianMubGVuZ3RoIC0gaTsgICAvKiBpbmRleCBpcyByZWxhdGl2ZSAqL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZVxuLy9WZXJzaW9uOiA+PSA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSBmYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZVxuLy9WZXJzaW9uOiA8IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IHRydWVcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbnZhciBjYW1sX291dHB1dF92YWwgPSBmdW5jdGlvbiAoKXtcbiAgZnVuY3Rpb24gV3JpdGVyICgpIHsgdGhpcy5jaHVuayA9IFtdOyB9XG4gIFdyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtfaWR4OjIwLCBibG9ja19sZW46MCwgb2JqX2NvdW50ZXI6MCwgc2l6ZV8zMjowLCBzaXplXzY0OjAsXG4gICAgd3JpdGU6ZnVuY3Rpb24gKHNpemUsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9hdDpmdW5jdGlvbiAocG9zLCBzaXplLCB2YWx1ZSkge1xuICAgICAgdmFyIHBvcyA9IHBvcztcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3BvcysrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9jb2RlOmZ1bmN0aW9uIChzaXplLCBjb2RlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9IGNvZGU7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9zaGFyZWQ6ZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA8ICgxIDw8IDgpKSB0aGlzLndyaXRlX2NvZGUoOCwgMHgwNCAvKmNzdC5DT0RFX1NIQVJFRDgqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgaWYgKG9mZnNldCA8ICgxIDw8IDE2KSkgdGhpcy53cml0ZV9jb2RlKDE2LCAweDA1IC8qY3N0LkNPREVfU0hBUkVEMTYqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgdGhpcy53cml0ZV9jb2RlKDMyLCAweDA2IC8qY3N0LkNPREVfU0hBUkVEMzIqLywgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHBvczpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNodW5rX2lkeCB9LFxuICAgIGZpbmFsaXplOmZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCAweDg0OTVBNkJFKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLmJsb2NrX2xlbik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfNjQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2h1bms7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodiwgZmxhZ3MpIHtcbiAgICBmbGFncyA9IGNhbWxfbGlzdF90b19qc19hcnJheShmbGFncyk7XG5cbiAgICB2YXIgbm9fc2hhcmluZyA9IChmbGFncy5pbmRleE9mKDAgLypNYXJzaGFsLk5vX3NoYXJpbmcqLykgIT09IC0xKSxcbiAgICAgICAgY2xvc3VyZXMgPSAgKGZsYWdzLmluZGV4T2YoMSAvKk1hcnNoYWwuQ2xvc3VyZXMqLykgIT09IC0xKTtcbiAgICAgICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYoY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICB9IGVsc2UgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLiBJdCBzZWVtcyBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiK3R5cGVfb2ZfditcIilcIik7XG4gICAgICAgICAgLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgLy8gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBCIC8qY3N0LkNPREVfRE9VQkxFX0JJRyovKTtcbiAgICAgICAgICAvLyAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFtpXSl9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9zeXNfY2xvc2UoZmQpIHtcbiAgZGVsZXRlIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX3N0ZF9vdXRwdXQoY2hhbmlkLHMpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHN0ciA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocyk7XG4gIHZhciBzbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgc3RyLCAwLCBzbGVuKTtcbiAgY2hhbi5vZmZzZXQgKz0gc2xlbjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcyxNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnIsIGpzX3ByaW50X3N0ZG91dFxuLy9SZXF1aXJlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChpZHgsb3V0cHV0LGZpbGUsZmxhZ3MpIHtcbiAgaWYoY2FtbF9nbG9iYWxfZGF0YS5mZHMgPT09IHVuZGVmaW5lZCkgY2FtbF9nbG9iYWxfZGF0YS5mZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmxhZ3M9ZmxhZ3M/ZmxhZ3M6e307XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8uZmlsZSA9IGZpbGU7XG4gIGluZm8ub2Zmc2V0ID0gZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MDtcbiAgaW5mby5mbGFncyA9IGZsYWdzO1xuICBpbmZvLm91dHB1dCA9IG91dHB1dDtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbaWR4XSA9IGluZm87XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4IHx8IGlkeCA+IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHgpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCA9IGlkeDtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHZhciBpZHggPSBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4P2NhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg6MDtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGlkeCsxLGNhbWxfc3RkX291dHB1dCxmaWxlLGYpO1xufVxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgwLGNhbWxfc3RkX291dHB1dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRpblxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgxLGpzX3ByaW50X3N0ZG91dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRvdXRcbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMixqc19wcmludF9zdGRlcnIsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkZXJyXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoKSB7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyOlwiXCJcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zeXNfb3BlbixjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuXG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIHJlZmlsbDpudWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlKGNoYW5pZCxtb2RlKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF07XG4gIGRhdGEuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGRhdGEuZmxhZ3MuYmluYXJ5ID0gbW9kZVxuICByZXR1cm4gMDtcbn1cblxuLy9JbnB1dCBmcm9tIGluX2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9jbG9zZV9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19jbG9zZVxuZnVuY3Rpb24gY2FtbF9tbF9jbG9zZV9jaGFubmVsIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgY2hhbi5maWxlLmNsb3NlKCk7XG4gIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5maWxlLmxlbmd0aCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCxjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNoYW4uZmlsZS5sZW5ndGggKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQoY2hhbmlkLGYpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbikge1xuICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgdmFyIHN0cl9sZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgaWYgKHN0cl9sZW4gPT0gMCkgY2hhbi5yZWZpbGwgPSBudWxsO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5maWxlLmxlbmd0aCgpLCBzdHIsIDAsIHN0cl9sZW4pO1xuICByZXR1cm4gc3RyX2xlbjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCA9PSBudWxsKSByZXR1cm47XG4gIGlmIChjaGFuLmZpbGUubGVuZ3RoKCkgIT0gY2hhbi5vZmZzZXQpIHJldHVybjtcbiAgY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dCAoY2hhbmlkLCBzLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgbDIgPSBjaGFuLmZpbGUubGVuZ3RoKCkgLSBjaGFuLm9mZnNldDtcbiAgaWYgKGwyID09IDAgJiYgY2hhbi5yZWZpbGwgIT0gbnVsbCkgbDIgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgaWYgKGwyIDwgbCkgbCA9IGwyO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCwgcywgaSwgbCk7XG4gIGNoYW4ub2Zmc2V0ICs9IGw7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKDgpO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCw4KTtcblxuICAvLyBIZWFkZXIgaXMgMjAgYnl0ZXNcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKGJ1ZiwgMCkgKyAyMDtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcblxuICB2YXIgb2Zmc2V0ID0gWzBdO1xuICB2YXIgcmVzID0gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKGJ1Ziwgb2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQgPSBjaGFuLm9mZnNldCArIG9mZnNldFswXTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfY2hhciAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgaWYgKGNoYW4ub2Zmc2V0ID49IGNoYW4uZmlsZS5sZW5ndGgoKSlcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmZpbGUucmVhZF9vbmUoY2hhbi5vZmZzZXQpO1xuICBjaGFuLm9mZnNldCsrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfaW50IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBmaWxlID0gY2hhbi5maWxlO1xuICB3aGlsZSAoKGNoYW4ub2Zmc2V0ICsgMykgPj0gZmlsZS5sZW5ndGgoKSkge1xuICAgIHZhciBsID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gICAgaWYgKGwgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB9XG4gIHZhciBvID0gY2hhbi5vZmZzZXQ7XG4gIHZhciByID0oZmlsZS5yZWFkX29uZShvICApIDw8IDI0KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysxKSA8PCAxNilcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMikgPDwgOClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMykpO1xuICBjaGFuLm9mZnNldCs9NDtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge3JldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7cmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCl9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLm9mZnNldDtcbiAgdmFyIGxlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYocCA+PSBsZW4pIHsgcmV0dXJuIDA7fVxuICB3aGlsZSh0cnVlKSB7XG4gICAgaWYocCA+PSBsZW4pIHJldHVybiAtIChwIC0gY2hhbi5vZmZzZXQpO1xuICAgIGlmKGNoYW4uZmlsZS5yZWFkX29uZShwKSA9PSAxMCkgcmV0dXJuIHAgLSBjaGFuLm9mZnNldCArIDE7XG4gICAgcCsrO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2ZsdXNoIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmKCFjaGFuLmJ1ZmZlciB8fCBjaGFuLmJ1ZmZlciA9PSBcIlwiKSByZXR1cm4gMDtcbiAgaWYoY2hhbi5mZFxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXVxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0O1xuICAgIHN3aXRjaChvdXRwdXQubGVuZ3RoKXtcbiAgICBjYXNlIDI6IG91dHB1dChjaGFuaWQsY2hhbi5idWZmZXIpO2JyZWFrO1xuICAgIGRlZmF1bHQ6IG91dHB1dChjaGFuLmJ1ZmZlcilcbiAgICB9O1xuICB9XG4gIGNoYW4uYnVmZmVyID0gXCJcIjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vb3V0cHV0IHRvIG91dF9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3Qgb3V0cHV0IHRvIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIHZhciBieXRlcztcbiAgaWYob2Zmc2V0ID09IDAgJiYgY2FtbF9tbF9ieXRlc19sZW5ndGgoYnVmZmVyKSA9PSBsZW4pXG4gICAgYnl0ZXMgPSBidWZmZXI7XG4gIGVsc2Uge1xuICAgIGJ5dGVzID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXMoYnVmZmVyLG9mZnNldCxieXRlcywwLGxlbik7XG4gIH1cbiAgdmFyIHN0cmluZyA9IGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ5dGVzKTtcbiAgdmFyIGpzc3RyaW5nID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzdHJpbmcpO1xuICB2YXIgaWQgPSBqc3N0cmluZy5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgaWYoaWQgPCAwKVxuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZztcbiAgZWxzZSB7XG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nLnN1YnN0cigwLGlkKzEpO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgY2hhbi5idWZmZXIgKz0ganNzdHJpbmcuc3Vic3RyKGlkKzEpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dChjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pe1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGJ1ZmZlciksb2Zmc2V0LGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9jaGFyIChjaGFuaWQsYykge1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nLCBjYW1sX21sX291dHB1dCxjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlIChjaGFuaWQsdixmbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2LCBmbGFncyk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dF82NChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXRcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXRfNjQoY2hhbmlkKSB7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50IChjaGFuaWQsaSkge1xuICB2YXIgYXJyID0gWyhpPj4yNCkgJiAweEZGLChpPj4xNikgJiAweEZGLChpPj44KSAmIDB4RkYsaSAmIDB4RkYgXTtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDQpO1xuICByZXR1cm4gMFxufVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19mdWxsX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX2Z1bGxfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3NldFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVsZWFzZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWxlYXNlICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RhcnQocmF0ZSxzdGFja19zaXplLHRyYWNrZXIpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0b3BcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdG9wKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICBpZiAoZGltc1tpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBzaXplID0gc2l6ZSAqIGRpbXNbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCl7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSA3OiBjYXNlIDEwOiBjYXNlIDExOiByZXR1cm4gMjtcbiAgZGVmYXVsdDogcmV0dXJuIDE7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAyOiAgdmlldyA9IGcuSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBnLkludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDU6ICB2aWV3ID0gZy5VaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA4OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDExOiB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246IDwgNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnJheVwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiXG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkgKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG5cbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBjYW1sX2JhX2N1c3RvbV9uYW1lO1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgb2ZzID0gMDtcbiAgaWYodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gIGlmICghIChhcmcgaW5zdGFuY2VvZiBBcnJheSkpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYXJnLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIGlmKHRoaXMubGF5b3V0ID09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSlcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyBhcmdbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRpbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcmdbaV0gPCAxIHx8IGFyZ1tpXSA+IHRoaXMuZGltc1tpXSl7XG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCxoKTtcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciByID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0aGlzLmRhdGFbb2ZzXVxuICB9XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSB2WzJdO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMFxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBhID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGlmKGEgPT0gYil7XG4gICAgICB0aGlzLmRhdGEuZmlsbChhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBhIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgaW0gPSB2WzFdO1xuICAgIHZhciByZSA9IHZbMl07XG4gICAgaWYoaW0gPT0gcmUpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGltIDogcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YS5maWxsKHYpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYiwgdG90YWwpIHtcbiAgaWYgKHRoaXMubGF5b3V0ICE9IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPSBiLmtpbmQpIHtcbiAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgdmFyIGsyID0gICAgYi5raW5kIHwgKGIubGF5b3V0IDw8IDgpO1xuICAgIHJldHVybiBrMiAtIGsxO1xuICB9XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGIuZGltcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYi5kaW1zLmxlbmd0aCAtIHRoaXMuZGltcy5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHRoaXMuZGltc1tpXSAhPSBiLmRpbXNbaV0pXG4gICAgICByZXR1cm4gKHRoaXMuZGltc1tpXSA8IGIuZGltc1tpXSkgPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICBjYXNlIDEwOlxuICBjYXNlIDExOlxuICAgIC8vIEZsb2F0c1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gdGhpcy5kYXRhW2ldO1xuICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPiB5KVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHggPT0geCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh5ID09IHkpIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSs9Mikge1xuICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPCBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdID4gYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApIDwgKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA+IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgY2FzZSAzOlxuICBjYXNlIDQ6XG4gIGNhc2UgNTpcbiAgY2FzZSA2OlxuICBjYXNlIDg6XG4gIGNhc2UgOTpcbiAgY2FzZSAxMjpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheV9jXzFfMVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhICAgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZSA9IG5ldyBNbF9CaWdhcnJheSgpXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICBpZih0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKXtcbiAgICBpZigoYXJnIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZy5sZW5ndGggPT0gMSlcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIk1sX0JpZ2FycmF5X2NfMV8xLm9mZnNldFwiKTtcbiAgfVxuICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKVxuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFyZztcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgcmV0dXJuIDBcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSxiLHRvdGFsKXtcbiAgcmV0dXJuIGEuY29tcGFyZShiLHRvdGFsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBNbF9CaWdhcnJheV9jXzFfMSwgY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKXtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZihjYW1sX2JhX2dldF9zaXplKGRpbXMpICogc2l6ZV9wZXJfZWxlbWVudCAhPSBkYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImxlbmd0aCBkb2Vzbid0IG1hdGNoIGRpbXNcIik7XG4gIH1cbiAgaWYobGF5b3V0ID09IDAgJiYgLy8gY19sYXlvdXRcbiAgICAgZGltcy5sZW5ndGggPT0gMSAmJiAvLyBBcnJheTFcbiAgICAgc2l6ZV9wZXJfZWxlbWVudCA9PSAxKSAvLyAxLXRvLTEgbWFwcGluZ1xuICAgIHJldHVybiBuZXcgTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfY2hhbmdlX2xheW91dChiYSwgbGF5b3V0KSB7XG4gIGlmKGJhLmxheW91dCA9PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW11cbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIG5ld19kaW1zW2ldID0gYmEuZGltc1tiYS5kaW1zLmxlbmd0aCAtIGkgLSAxXTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBsYXlvdXQsIG5ld19kaW1zLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhKSB7XG4gIHJldHVybiBiYS5kaW1zLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICByZXR1cm4gYmEuZGltc1tpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzIoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzMoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKTtcbiAgcmV0dXJuIGJhLmdldChvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gKGIxIHwgKGIyIDw8IDgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQzMihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgcmV0dXJuICggKGIxIDw8IDApICB8XG4gICAgICAgICAgIChiMiA8PCA4KSAgfFxuICAgICAgICAgICAoYjMgPDwgMTYpIHxcbiAgICAgICAgICAgKGI0IDw8IDI0KSApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQob2ZzKzQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzKzUpO1xuICB2YXIgYjcgPSBiYS5nZXQob2ZzKzYpO1xuICB2YXIgYjggPSBiYS5nZXQob2ZzKzcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsYjcsYjYsYjUsYjQsYjMsYjIsYjFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoaTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMV0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgdiA9IGNhbWxfaW50NjRfdG9fYnl0ZXModik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMraSwgdls3LWldKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChpMCksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTFdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxLGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPSBzcmMuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdC5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkc3QuZGltc1tpXSAhPSBzcmMuZGltc1tpXSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZHN0LmRhdGEuc2V0KHNyYy5kYXRhKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHZhciBjaGFuZ2VkX2RpbTtcbiAgdmFyIG11bCA9IDE7XG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGJhLmRpbXMubGVuZ3RoIC0gMSk7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSBiYS5kaW1zLmxlbmd0aCAtIDE7XG4gICAgb2ZzID0gb2ZzIC0gMTtcbiAgfVxuICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcbiAgfVxuICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIG5ld19kaW1zW2ldID0gYmEuZGltc1tpXTtcbiAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuICBtdWwgKj0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG51bV9pbmRzID0gdmluZC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IFtdO1xuICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgdmFyIG9mcztcblxuICBpZiAobnVtX2luZHMgPiBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICBmb3IgKDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDA7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogc2l6ZV9wZXJfZWxlbWVudCwgKG9mcyArIHNpemUpICogc2l6ZV9wZXJfZWxlbWVudCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBzdWJfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbmV3X2RpbSA9IFtdO1xuICB2YXIgbnVtX2RpbXMgPSB2aW5kLmxlbmd0aDtcblxuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgbnVtX2VsdHMgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICBuZXdfZGltW2ldID0gdmluZFtpXTtcbiAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIChiYS5raW5kIHwgKGJhLmxheW91dCA8PCA4KSkpO1xuICBpZihiYS5jYW1sX2N1c3RvbSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihiYS5kaW1zW2ldIDwgMHhmZmZmKVxuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRpbXNbaV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgMHhmZmZmKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCAwKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgd3JpdGVyLndyaXRlKDMyLGJhLmRpbXNbaV0pXG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3osIG5hbWUpe1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgaWYobmFtZSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgdmFyIHNpemVfZGltID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIGlmKHNpemVfZGltID09IDB4ZmZmZil7XG4gICAgICAgIHZhciBzaXplX2RpbV9oaSA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIHZhciBzaXplX2RpbV9sbyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIGlmKHNpemVfZGltX2hpICE9IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykgZGltcy5wdXNoKHJlYWRlci5yZWFkMzJ1KCkpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpO1xuICB2YXIgYmEgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB2YXIgc2l4dHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYoc2l4dHkpIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY2Fubm90IHJlYWQgYmlnYXJyYXkgd2l0aCA2NC1iaXQgT0NhbWwgaW50c1wiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGludDY0ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KTtcbiAgICAgIGJhLnNldChpLGludDY0KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBzelswXSA9ICg0ICsgbnVtX2RpbXMpICogNDtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL0RlcHJlY2F0ZWRcbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGExLCBkYXRhMiwganN0eXAsIGtpbmQsIGxheW91dCwgZGltcyl7XG4gIGlmKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT0gMil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGExKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9oYXNoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKXtcbiAgdmFyIG51bV9lbHRzID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgdmFyIGggPSAwO1xuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDI1NikgbnVtX2VsdHMgPSAyNTY7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDQgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgOCkgfCAoYmEuZGF0YVtpKzJdIDw8IDE2KSB8IChiYS5kYXRhW2krM10gPDwgMjQpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIHcgPSAwO1xuICAgIHN3aXRjaCAobnVtX2VsdHMgJiAzKSB7XG4gICAgY2FzZSAzOiB3ICA9IGJhLmRhdGFbaSsyXSA8PCAxNjsgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDI6IHcgfD0gYmEuZGF0YVtpKzFdIDw8IDg7ICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMTogdyB8PSBiYS5kYXRhW2krMF07XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyAyIDw9IGJhLmRhdGEubGVuZ3RoOyBpKz0yKXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDE2KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICBpZiAoKG51bV9lbHRzICYgMSkgIT0gMClcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBudW1fZWx0cyAqPSAyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV90b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJhKXtcbiAgcmV0dXJuIGJhLmRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBraW5kO1xuICBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0MzJBcnJheSkga2luZCA9IDA7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5GbG9hdDY0QXJyYXkpIGtpbmQgPSAxO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50OEFycmF5KSBraW5kID0gMjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQ4QXJyYXkpIGtpbmQgPSAzO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50MTZBcnJheSkga2luZCA9IDQ7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50MTZBcnJheSkga2luZCA9IDU7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQzMkFycmF5KSBraW5kID0gNjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQzMkFycmF5KSBraW5kID0gNjtcbiAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXk6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHJldHVybiBraW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBraW5kID0gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuIiwiLy8vLy8vLy8vIEJJR1NUUklOR1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nKGgsIGJzKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLGJzLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGEuYnVmZmVyXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGFcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIoYWIpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoYmEpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYmEuYnVmZmVyLCBiYS5ieXRlT2Zmc2V0LCBiYS5sZW5ndGggKiBiYS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX21lbWNtcFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfbWVtY21wKHMxLCBwb3MxLCBzMiwgcG9zMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMShzMSxwb3MxICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHMyLHBvczIgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoYmExLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc3ViYXJyYXkob2ZzMSxvZnMxK2xlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxwb3MyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoYmExLCBwb3MxLCBieXRlczIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKHBvczIgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChieXRlczIpKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc2xpY2Uob2ZzMSwgb2ZzMStsZW4pO1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShzbGljZSksIDAsIGJ5dGVzMiwgcG9zMiwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2FsbG9jXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZVxuZnVuY3Rpb24gYmlnc3RyaW5nX2FsbG9jKF8sc2l6ZSl7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZSgxMiwgMCwgWzAsc2l6ZV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfaXNfbW1hcHBlZF9zdHViXG5mdW5jdGlvbiBiaWdzdHJpbmdfaXNfbW1hcHBlZF9zdHViKHgpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfc3R1YihzMSwgaTEsIHMyLCBpMiwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoczEsaTEsczIsaTIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViKHNyYywgc3JjX3BvcywgZHN0LCBkc3RfcG9zLCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzcmMsc3JjX3Bvcyxkc3QsZHN0X3BvcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIoc3JjLCBzcmNfcG9zLCBkc3QsIGRzdF9wb3MsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKHNyYyxzcmNfcG9zLGRzdCxkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YihzcmMsIHNyY19wb3MsIGRzdCwgZHN0X3BvcywgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHNyYyxzcmNfcG9zLGRzdCxkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19tZW1zZXRfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX21lbXNldF9zdHViKGJpZ3N0cmluZywgdl9wb3MsIHZfbGVuLCB2X2NoYXIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgY2FtbF9iYV9zZXRfMShiaWdzdHJpbmcsIHZfcG9zICsgaSwgdl9jaGFyKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWVtY21wX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19tZW1jbXBfc3R1Yih2X3MxLCB2X3MxX3Bvcywgdl9zMiwgdl9zMl9wb3MsIHZfbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHZfczEsdl9zMV9wb3MgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEodl9zMix2X3MyX3BvcyArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGludGVybmFsaGFzaF9mb2xkX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbnZhciBpbnRlcm5hbGhhc2hfZm9sZF9iaWdzdHJpbmcgPSBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZmluZFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX2ZpbmQoYnMsIGNociwgcG9zLCBsZW4pe1xuICB3aGlsZShsZW4gPiAwKXtcbiAgICBpZihjYW1sX2JhX2dldF8xKGJzLHBvcykgPT0gY2hyKSByZXR1cm4gcG9zO1xuICAgIHBvcysrO1xuICAgIGxlbi0tO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIgKGYpIHsgcmV0dXJuIGYoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19zZXQobyxmLHYpIHsgb1tmXT12O3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19nZXQobyxmKSB7IHJldHVybiBvW2ZdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2RlbGV0ZSAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2RlbGV0ZShvLGYpIHsgZGVsZXRlIG9bZl07IHJldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2luc3RhbmNlb2YgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfaW5zdGFuY2VvZihvLGMpIHsgcmV0dXJuIG8gaW5zdGFuY2VvZiBjOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb25faWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfb25faWUgKCkge1xuICB2YXIgdWEgPVxuICAgICAgam9vX2dsb2JhbF9vYmplY3QubmF2aWdhdG9yP2pvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vIERlYnVnZ2luZyBjb25zb2xlXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldF9jb25zb2xlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX2dldF9jb25zb2xlICgpIHtcbiAgdmFyIGMgPSBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlP2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGU6e307XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVcbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZShyZXMpIHtcbiAgdmFyIGMgPSAxO1xuICB3aGlsZShyZXMgJiYgcmVzLmpvb190cmFtcCl7XG4gICAgcmVzID0gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpO1xuICAgIGMrKztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKSB7XG4gIHJldHVybiB7am9vX3RyYW1wOmYsam9vX2FyZ3M6YXJnc307XG59XG5cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZG91dCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZG91dChzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgICYmIHYubG9nICYmIHYubG9nKHMpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRlcnIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRlcnIocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3RkZXJyLndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICYmIHYuZXJyb3IgJiYgdi5lcnJvcihzKTtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF93cmFwX2V4Y2VwdGlvbiBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudFxuZnVuY3Rpb24gY2FtbF93cmFwX2V4Y2VwdGlvbihlKSB7XG4gIGlmKGUgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGU7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGNocm9tZSwgc2FmYXJpXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlJhbmdlRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlJhbmdlRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvbWF4aW11bSBjYWxsIHN0YWNrL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGZpcmVmb3hcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICBpZihlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuRXJyb3IgJiYgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIikpXG4gICAgcmV0dXJuIFswLGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpLGVdO1xuICAvL2ZhbGxiYWNrOiB3cmFwcGVkIGluIEZhaWx1cmVcbiAgcmV0dXJuIFswLGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoU3RyaW5nKGUpKV07XG59XG5cbi8vIEV4cGVyaW1lbnRhbFxuLy9Qcm92aWRlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgLy9uZXZlciByZXJhaXNlIGZvciBjb25zdGFudCBleG5cbiAgaWYoIWV4bi5qc19lcnJvciB8fCBmb3JjZSB8fCBleG5bMF0gPT0gMjQ4KSBleG4uanNfZXJyb3IgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRXJyb3IoXCJKcyBleGNlcHRpb24gY29udGFpbmluZyBiYWNrdHJhY2VcIik7XG4gIHJldHVybiBleG47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9pbnQgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nLCBjYW1sX3N0cl9yZXBlYXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2ludChmbXQsIGkpIHtcbiAgaWYgKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KSA9PSBcIiVkXCIpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIraSk7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGkgPCAwKSB7IGlmIChmLnNpZ25lZGNvbnYpIHsgZi5zaWduID0gLTE7IGkgPSAtaTsgfSBlbHNlIGkgPj4+PSAwOyB9XG4gIHZhciBzID0gaS50b1N0cmluZyhmLmJhc2UpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIHMubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgcyA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIHM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpIHtcbiAgdmFyIGkgPSAwLCBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyksIGJhc2UgPSAxMCwgc2lnbiA9IDE7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSkpIHtcbiAgICBjYXNlIDQ1OiBpKys7IHNpZ24gPSAtMTsgYnJlYWs7XG4gICAgY2FzZSA0MzogaSsrOyBzaWduID0gMTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpICsgMSA8IGxlbiAmJiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpID09IDQ4KVxuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpICsgMSkpIHtcbiAgICBjYXNlIDEyMDogY2FzZSA4ODogYmFzZSA9IDE2OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTExOiBjYXNlIDc5OiBiYXNlID0gIDg7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAgOTg6IGNhc2UgNjY6IGJhc2UgPSAgMjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExNzogY2FzZSA4NTogaSArPSAyOyBicmVhaztcbiAgICB9XG4gIHJldHVybiBbaSwgc2lnbiwgYmFzZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZGlnaXRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZGlnaXQoYykge1xuICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSAgcmV0dXJuIGMgLSA0ODtcbiAgaWYgKGMgPj0gNjUgJiYgYyA8PSA5MCkgIHJldHVybiBjIC0gNTU7XG4gIGlmIChjID49IDk3ICYmIGMgPD0gMTIyKSByZXR1cm4gYyAtIDg3O1xuICByZXR1cm4gLTE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9wYXJzZV9kaWdpdCwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9pbnRfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciB0aHJlc2hvbGQgPSAtMSA+Pj4gMDtcbiAgdmFyIGMgPSAoaSA8IGxlbik/Y2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTowO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gZDtcbiAgZm9yIChpKys7aTxsZW47aSsrKSB7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIHJlcyA9IGJhc2UgKiByZXMgKyBkO1xuICAgIGlmIChyZXMgPiB0aHJlc2hvbGQpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGxlbikgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIC8vIEZvciBiYXNlIGRpZmZlcmVudCBmcm9tIDEwLCB3ZSBleHBlY3QgYW4gdW5zaWduZWQgcmVwcmVzZW50YXRpb24sXG4gIC8vIGhlbmNlIGFueSB2YWx1ZSBvZiAncmVzJyAobGVzcyB0aGFuICd0aHJlc2hvbGQnKSBpcyBhY2NlcHRhYmxlLlxuICAvLyBCdXQgd2UgaGF2ZSB0byBjb252ZXJ0IHRoZSByZXN1bHQgYmFjayB0byBhIHNpZ25lZCBpbnRlZ2VyLlxuICByZXMgPSBzaWduICogcmVzO1xuICBpZiAoKGJhc2UgPT0gMTApICYmICgocmVzIHwgMCkgIT0gcmVzKSlcbiAgICAvKiBTaWduZWQgcmVwcmVzZW50YXRpb24gZXhwZWN0ZWQsIGFsbG93IC0yXihuYml0cy0xKSB0byAyXihuYml0cy0xKSAtIDEgKi9cbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgcmV0dXJuIHJlcyB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbXVsIGNvbnN0XG5mdW5jdGlvbiBjYW1sX211bChhLGIpe1xuICByZXR1cm4gTWF0aC5pbXVsKGEsYik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGl2XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX2Rpdih4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuICh4L3kpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX21vZCh4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuIHgleTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ic3dhcDE2XG5mdW5jdGlvbiBjYW1sX2Jzd2FwMTYoeCkge1xuICByZXR1cm4gKCgoKHggJiAweDAwRkYpIDw8IDgpIHxcbiAgICAgICAgICAgKCh4ICYgMHhGRjAwKSA+PiA4KSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9ic3dhcCh4KSB7XG4gIHJldHVybiAoKCh4ICYgMHgwMDAwMDBGRikgPDwgMjQpIHxcbiAgICAgICAgICAoKHggJiAweDAwMDBGRjAwKSA8PCA4KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMEZGMDAwMCkgPj4+IDgpIHxcbiAgICAgICAgICAoKHggJiAweEZGMDAwMDAwKSA+Pj4gMjQpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYnN3YXBcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYnN3YXAoeCkge1xuICB2YXIgeSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoeCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFt5WzddLCB5WzZdLCB5WzVdLCB5WzRdLCB5WzNdLCB5WzJdLCB5WzFdLCB5WzBdXSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEhhc2h0YmxcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKG9iaikpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgc3dpdGNoIChvYmoudCAmIDYpIHtcbiAgICAgIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICAgICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhvYmopO1xuICAgICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgICBmb3IgKHZhciBiID0gb2JqLmMsIGwgPSBjYW1sX21sX2J5dGVzX2xlbmd0aChvYmopLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBvYmouYywgbCA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKG9iaiksIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKG9iaikpIHtcbiAgICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICAgIGZvciAodmFyIGIgPSBqc2J5dGVzLCBsID0ganNieXRlcy5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IChvYmp8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGNvdW50IC0tO1xuICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICtvYmopIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBjb3VudC0tO1xuICAgICAgdmFyIHAgPSBjYW1sX2ludDY0X3RvX2J5dGVzIChjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKG9iaikpO1xuICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgaS0tKSBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBwW2ldKSB8IDA7XG4gICAgfSBlbHNlIGlmKG9iaiAmJiBvYmouY2FtbF9jdXN0b20pIHtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGggPSBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKG9iaikgfCAwO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBoKSB8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc2hfYXV4IChvYmopO1xuICByZXR1cm4gaGFzaF9hY2N1ICYgMHgzRkZGRkZGRjtcbn1cblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCxkKSB7XG4gIGQgPSBjYW1sX211bChkLCAweGNjOWUyZDUxfDApO1xuICBkID0gKChkIDw8IDE1KSB8IChkID4+PiAoMzItMTUpKSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKChoIDw8IDEzKSB8IChoID4+PiAoMzItMTMpKSk7ICAgLy9ST1RMMzIoaCwgMTMpO1xuICByZXR1cm4gKCgoaCArIChoIDw8IDIpKXwwKSArICgweGU2NTQ2YjY0fDApKXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9maW5hbChoKSB7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIGggPSBjYW1sX211bCAoaCwgMHg4NWViY2E2YnwwKTtcbiAgaCBePSBoID4+PiAxMztcbiAgaCA9IGNhbWxfbXVsIChoLCAweGMyYjJhZTM1fDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludDY0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0IChoLCB2MCkge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9pbnQ2NChoLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHYwKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9sbzMyLCBjYW1sX2ludDY0X2hpMzJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpIHtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfbG8zMih2KSk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2hpMzIodikpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzLmNoYXJDb2RlQXQoaSlcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDgpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNilcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzMpIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gcy5jaGFyQ29kZUF0KGkrMikgPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzLmNoYXJDb2RlQXQoaSsxKSA8PCA4O1xuICBjYXNlIDE6XG4gICAgdyB8PSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gc1tpXVxuICAgICAgfCAoc1tpKzFdIDw8IDgpXG4gICAgICB8IChzW2krMl0gPDwgMTYpXG4gICAgICB8IChzW2krM10gPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzW2krMl0gPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzW2krMV0gPDwgODtcbiAgY2FzZSAxOiB3IHw9IHNbaV07XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHN3aXRjaCAodi50ICYgNikge1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHYpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCB2LmMpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHYuYyk7XG4gIH1cbiAgcmV0dXJuIGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmcoaCwgdikge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmcodikpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nLCBjYW1sX2hhc2hfbWl4X2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG4iLCIvL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NCA9IGNhbWxfaGFzaF9taXhfaW50NjQ7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludCA9IGNhbWxfaGFzaF9taXhfaW50O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdFxudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXQgPSBjYW1sX2hhc2hfbWl4X2Zsb2F0O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmcgPSBjYW1sX2hhc2hfbWl4X3N0cmluZztcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG5mdW5jdGlvbiBCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZShzZWVkKSB7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChzZWVkKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNzovL3Rlc3RzaGlmdDpcbiAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBjbWQgPSBzaGlmdDsgYnJlYWs7XG4gICAgICB9XG4gICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIGNtZCA9IHJlZHVjZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgIHJlcyA9IENBTExfRVJST1JfRlVOQ1RJT047XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAzOi8vU1RBQ0tTX0dST1dOXzI6XG4gICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgY2FzZSA0Oi8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBhcmc7XG4gICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgaWYgKHNwID4gYXNwKSB7XG4gICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgfVxuICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkge1xuICByZXR1cm4gYS5zbGljZSgxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYlswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8bGVuO2krKykgYltpKzFdID0gYVtpXTtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF9vZl9qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF90b19qc19hcnJheShsKXtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKDsgbCAhPT0gMDsgbCA9IGxbMl0pIHtcbiAgICBhLnB1c2gobFsxXSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdmFyIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmKCF4Lm1hdGNoKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKFxcLlthLXpBLVpfJF1bYS16QS1aXyQwLTldKikqJC8pKXtcbiAgICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFthcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSAmJiBmLmxlbmd0aCA9PSBhcml0eSkgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsYXJncyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cG9ydF92YXJcbmZ1bmN0aW9uIGNhbWxfanNfZXhwb3J0X3ZhciAoKXtcbiAgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0c1xuICBlbHNlXG4gICAgcmV0dXJuIGpvb19nbG9iYWxfb2JqZWN0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlKHVuaXQpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZih0eXBlb2YgZy5YTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuWE1MSHR0cFJlcXVlc3QgfSBjYXRjaCAoZSkgeyB9O1xuICB9XG4gIGlmKHR5cGVvZiBnLmFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwzLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gIH1cbiAgY2FtbF9mYWlsd2l0aChcIkNhbm5vdCBjcmVhdGUgYSBYTUxIdHRwUmVxdWVzdFwiKTtcbn1cbiIsIi8vUHJvdmlkZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF90aW1lXG4vL1JlcXVpcmVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRVVENTZWNvbmRzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ0hvdXJzKCksXG4gICAgICAgICAgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldFVUQ0RheSgpLCBkb3ksXG4gICAgICAgICAgZmFsc2UgfCAwIC8qIGZvciBVVEMgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGlzIGZhbHNlICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9sb2NhbHRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgZC5nZXREYXkoKSwgZG95LFxuICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X21rdGltZVxuLy9SZXF1aXJlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IHVuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gQkxPQ0soMCx0LHRtMik7XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9zdGFydHVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9jbGVhbnVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9oYW5kbGVfZmQgY29uc3RcbmZ1bmN0aW9uIHdpbl9oYW5kbGVfZmQoeCkge3JldHVybiB4O31cblxuLy9Qcm92aWRlczogdW5peF9pc2F0dHkgXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShmaWxlRGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgdmFyIHRhZ19hID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSk7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYSA9PSAyNTApIHsgYSA9IGFbMV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYiA9PSAyNTApIHsgYiA9IGJbMV07IGNvbnRpbnVlIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZih0YWdfYSAhPT0gdGFnX2IpIHtcbiAgICAgICAgaWYodGFnX2EgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19iID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnX2IgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19hID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFnX2EgPCB0YWdfYik/LTE6MTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCh0YWdfYSl7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgIGNhc2UgMjQ3OiAvLyBDbG9zdXJlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI0ODogLy8gT2JqZWN0XG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUxOiAvL0Fic3RyYWN0XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MjogLy8gT0NhbWwgYnl0ZXNcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEN1c3RvbV90YWdcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICB2YXIgYiA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYik7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjA6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gKGEubGVuZ3RoIDwgYi5sZW5ndGgpPy0xOjE7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kKGxvYyxzaGFwZSkge1xuICBmdW5jdGlvbiB1bmRlZl9tb2R1bGUgKF94KSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZyhjYW1sX2dsb2JhbF9kYXRhLlVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlLCBsb2MpO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AgKHNoYXBlLHN0cnVjdCxpZHgpe1xuICAgIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHN3aXRjaChzaGFwZSl7XG4gICAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgICAgICBzdHJ1Y3RbaWR4XT11bmRlZl9tb2R1bGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOi8vbGF6eVxuICAgICAgICBzdHJ1Y3RbaWR4XT1bMjQ2LCB1bmRlZl9tb2R1bGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDI6Ly9jbGFzc1xuICAgICAgICBzdHJ1Y3RbaWR4XT1bXTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gWzBdO1xuICAgICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgICAgbG9vcChzaGFwZVsxXVtpXSxzdHJ1Y3RbaWR4XSxpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAxOi8vVmFsdWVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBzaGFwZVsxXTtcbiAgICAgIH1cbiAgfVxuICB2YXIgcmVzID0gW107XG4gIGxvb3Aoc2hhcGUscmVzLDApO1xuICByZXR1cm4gcmVzWzBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZSxyZWFsLHgpIHtcbiAgZnVuY3Rpb24gbG9vcCAoc2hhcGUscmVhbCx4LHBhcmVudCxpKSB7XG4gICAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgICAgc3dpdGNoKHNoYXBlKXtcbiAgICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgICAgIHBhcmVudFtpXT14O1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxOi8vbGF6eVxuICAgICAgY2FzZSAyOi8vY2xhc3NcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhbWxfdXBkYXRlX2R1bW15KHJlYWwseCk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3dpdGNoKHNoYXBlWzBdKXtcbiAgICAgIGNhc2UgMDovL21vZHVsZVxuICAgICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgICAgbG9vcChzaGFwZVsxXVtpXSxyZWFsW2ldLHhbaV0scmVhbCxpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vY2FzZSAxOi8vVmFsdWVcbiAgICAgIGRlZmF1bHQ6XG4gICAgICB9O1xuICB9XG4gIGxvb3Aoc2hhcGUscmVhbCx4LHVuZGVmaW5lZCx1bmRlZmluZWQpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vUHJvdmlkZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXRcbnZhciBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0IFxuLy9Qcm92aWRlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyclxudmFyIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnJcblxuLy9Qcm92aWRlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2JlZm9yZV90ZXN0XG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyLCBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0XG5mdW5jdGlvbiBleHBlY3RfdGVzdF9jb2xsZWN0b3JfYmVmb3JlX3Rlc3QgKHZvdXRwdXQsIHZzdGRvdXQsIHZzdGRlcnIpe1xuICBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyID0gY2FtbF9tbF9jaGFubmVsc1t2c3RkZXJyXTtcbiAgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dCA9IGNhbWxfbWxfY2hhbm5lbHNbdnN0ZG91dF07XG4gIHZhciBvdXRwdXQgPSBjYW1sX21sX2NoYW5uZWxzW3ZvdXRwdXRdO1xuICBjYW1sX21sX2NoYW5uZWxzW3ZzdGRvdXRdID0gb3V0cHV0O1xuICBjYW1sX21sX2NoYW5uZWxzW3ZzdGRlcnJdID0gb3V0cHV0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2FmdGVyX3Rlc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnIsIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXRcbmZ1bmN0aW9uIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9hZnRlcl90ZXN0ICh2c3Rkb3V0LCB2c3RkZXJyKXtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3Rkb3V0XSA9IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXQ7XG4gIGNhbWxfbWxfY2hhbm5lbHNbdnN0ZGVycl0gPSBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczpjYW1sX291dF9jaGFubmVsX3Bvc19mZFxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9vdXRfY2hhbm5lbF9wb3NfZmQoY2hhbil7XG4gIHZhciBpbmZvID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuXTtcbiAgcmV0dXJuIGluZm8ub2Zmc2V0XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkgKHgsIHkpIHtcbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgdmFyIGkgPSB5Lmxlbmd0aDsgd2hpbGUgKGktLSkgeFtpXSA9IHlbaV07IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9pc19ibG9jayAoeCkgeyByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9vYmpfdGFnICh4KSB7XG4gIGlmICgoeCBpbnN0YW5jZW9mIEFycmF5KSAmJiB4WzBdID09ICh4WzBdID4+PiAwKSlcbiAgICByZXR1cm4geFswXVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmICgoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCB0eXBlb2YgeCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIDI0N1xuICBlbHNlIGlmICh4ICYmIHguY2FtbF9jdXN0b20pXG4gICAgcmV0dXJuIDI1NVxuICBlbHNlXG4gICAgcmV0dXJuIDEwMDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3RhZyAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfdGFnICh4LCB0YWcpIHsgeFswXSA9IHRhZzsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2Jsb2NrIGNvbnN0IChjb25zdCxjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2Jsb2NrICh0YWcsIHNpemUpIHtcbiAgdmFyIG8gPSBuZXcgQXJyYXkoc2l6ZSsxKTtcbiAgb1swXT10YWc7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHNpemU7IGkrKykgb1tpXSA9IDA7XG4gIHJldHVybiBvO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial93aXRoX3RhZ1xuZnVuY3Rpb24gY2FtbF9vYmpfd2l0aF90YWcodGFnLHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSB0YWc7XG4gIGZvcih2YXIgaSA9IDE7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2R1cCBtdXRhYmxlIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdHJ1bmNhdGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX29ial90cnVuY2F0ZSAoeCwgcykge1xuICBpZiAoczw9MCB8fCBzICsgMSA+IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJPYmoudHJ1bmNhdGVcIik7XG4gIGlmICh4Lmxlbmd0aCAhPSBzICsgMSkgeC5sZW5ndGggPSBzICsgMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX21ha2VfZm9yd2FyZFxuZnVuY3Rpb24gY2FtbF9vYmpfbWFrZV9mb3J3YXJkIChiLHYpIHtcbiAgYlswXT0yNTA7XG4gIGJbMV09djtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X21ha2VfZm9yd2FyZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSBudWxsKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJheSBpcyBub3Qgc3BhcnNlXG4gICAgZm9yICh2YXIgaSA9IGNhbWxfbWV0aG9kX2NhY2hlLmxlbmd0aDsgaSA8IGNhY2hlaWQ7IGkrKylcbiAgICAgIGNhbWxfbWV0aG9kX2NhY2hlW2ldID0gMDtcbiAgfSBlbHNlIGlmIChtZXRoc1tvZnNdID09PSB0YWcpIHtcbiAgICByZXR1cm4gbWV0aHNbb2ZzIC0gMV07XG4gIH1cbiAgdmFyIGxpID0gMywgaGkgPSBtZXRoc1sxXSAqIDIgKyAxLCBtaTtcbiAgd2hpbGUgKGxpIDwgaGkpIHtcbiAgICBtaSA9ICgobGkraGkpID4+IDEpIHwgMTtcbiAgICBpZiAodGFnIDwgbWV0aHNbbWkrMV0pIGhpID0gbWktMjtcbiAgICBlbHNlIGxpID0gbWk7XG4gIH1cbiAgY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF0gPSBsaSArIDE7XG4gIC8qIHJldHVybiAwIGlmIHRhZyBpcyBub3QgdGhlcmUgKi9cbiAgcmV0dXJuICh0YWcgPT0gbWV0aHNbbGkrMV0gPyBtZXRoc1tsaV0gOiAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vb19sYXN0X2lkXG52YXIgY2FtbF9vb19sYXN0X2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9zZXRfb29faWQgKGIpIHtcbiAgYlsyXT1jYW1sX29vX2xhc3RfaWQrKztcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnJlc2hfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9mcmVzaF9vb19pZCgpIHtcbiAgcmV0dXJuIGNhbWxfb29fbGFzdF9pZCsrO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X2dldCAoYXJyYXksIGluZGV4KSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5W2luZGV4KzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpe1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGFycmF5W29mcytpKzFdID0gdjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4iLCIvLy8vLy8vLy8gQklOX1BST1RcblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKGJpZ3N0cmluZywgaSl7XG4gIGlmIChpID4+PiAwID49IGJpZ3N0cmluZy5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J1Zl9mbG9hdF9hcnJheV9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2NoZWNrX2JvdW5kLCBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZ1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfZmxvYXRfYXJyYXlfc3R1YihzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICBjYW1sX2NoZWNrX2JvdW5kKGRzdCxkc3RfcG9zKTsgLy8gZmlyc3QgcG9zXG4gIGNhbWxfY2hlY2tfYm91bmQoZHN0LGRzdF9wb3MrbGVuLTEpOyAvLyBsYXN0IHBvc1xuICBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZyhzcmMsIHNyY19wb3MpOyAgLyogZmlyc3QgcG9zICovXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKHNyYywgc3JjX3BvcyArIGxlbiAqIDggLSAxKTsgLyogbGFzdCBwb3MgKi9cbiAgdmFyIHZpZXcgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQ2NEFycmF5KGxlbik7XG4gIHZhciBidWZmZXIgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSh2aWV3LmJ1ZmZlcik7XG4gIGJ1ZmZlci5zZXQoc3JjLmRhdGEuc3ViYXJyYXkoc3JjX3Bvcywgc3JjX3BvcyArIChsZW4gKiA4KSkpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIC8vIFsrIDFdIGJlY2F1c2UgdGhlIHRhZyBpcyBhdCBwb3MgMCBcbiAgICBkc3RbZHN0X3BvcytpKzFdID0gdmlld1tpXTtcbiAgfVxuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9idWZfYnl0ZXNfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfYnl0ZXNfc3R1YihzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoc3JjLCBzcmNfcG9zLCBkc3QsIGRzdF9wb3MsIGxlbik7XG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2Zsb2F0X2FycmF5X2J1Zl9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2NoZWNrX2JvdW5kLCBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZ1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9mbG9hdF9hcnJheV9idWZfc3R1YihzcmNfcG9zLHNyYywgZHN0X3BvcywgZHN0LCBsZW4pe1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDAgXG4gIGNhbWxfY2hlY2tfYm91bmQgKHNyYywgc3JjX3Bvcyk7IC8vIGZpcnN0IHBvcyBcbiAgY2FtbF9jaGVja19ib3VuZCAoc3JjLCBzcmNfcG9zICsgbGVuIC0gMSk7IC8vIGxhc3QgcG9zXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKGRzdCwgZHN0X3Bvcyk7IC8qIGZpcnN0IHBvcyAqL1xuICBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZyhkc3QsIGRzdF9wb3MgKyBsZW4gKiA4IC0gMSk7IC8qIGxhc3QgcG9zICovXG4gIC8vIFsrIDFdIGJlY2F1c2UgdGhlIHRhZyBpcyBhdCBwb3MgMFxuICBzcmNfcG9zID0gc3JjX3BvcyArIDFcbiAgdmFyIGZsb2F0NjQgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQ2NEFycmF5KHNyYy5zbGljZShzcmNfcG9zLHNyY19wb3MgKyBsZW4pKTtcbiAgdmFyIGZsb2F0NjRfdWludDggPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShmbG9hdDY0LmJ1ZmZlcik7XG4gIHZhciB2aWV3ID0gZHN0LmRhdGEuc3ViYXJyYXkoZHN0X3BvcywgZHN0X3BvcyArIChsZW4gKiA4KSk7XG4gIHZpZXcuc2V0KGZsb2F0NjRfdWludDgpO1xuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9zdHJpbmdfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X3N0cmluZ19idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzcmMsc3JjX3BvcywgZHN0LCBkc3RfcG9zLGxlbik7XG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J5dGVzX2J1Zl9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9ieXRlc19idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzcmMsc3JjX3BvcywgZHN0LCBkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEsIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheVxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIC8vIFtiaW5fcHJvdF9ibGl0X2J1Zl9zdHViXSBpcyB1c2VkIHdpdGggbWl4ZWQgYmlnYXJyYXkga2luZHMuXG4gIC8vIENvbnZlcnRlciBldmVyeXRoaW5nIHRvIGJpZ2FycmF5IG9mIGNoYXIgYmVmb3JlIHRoZSBibGl0LlxuICBpZihzcmMua2luZCAhPSAxMikgLy8gMTIgaXMgdGhlIGNoYXIga2luZFxuICAgIHNyYyA9IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShzcmMuZGF0YSk7XG4gIGlmKGRzdC5raW5kICE9IDEyKSAvLyAxMiBpcyB0aGUgY2hhciBraW5kXG4gICAgZHN0ID0gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGRzdC5kYXRhKTtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoc3JjLHNyY19wb3MsZHN0LGRzdF9wb3MsbGVuKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFja3RyYWNlX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2ID4+IDE2O1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheSwgY2FtbF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UtMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl9tZW0ocywgaSwgbWVtLCBjdXJyX3Bvcykge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gY3Vycl9wb3M7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX3RhZyhzLCBpLCBtZW0pIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybiA7XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSAtMTtcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX25ld19sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfbWVtID0gMTA7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcbiAgdmFyIGxleF9iYXNlX2NvZGUgPSA2O1xuICB2YXIgbGV4X2JhY2t0cmtfY29kZSA9IDc7XG4gIHZhciBsZXhfZGVmYXVsdF9jb2RlID0gODtcbiAgdmFyIGxleF90cmFuc19jb2RlID0gOTtcbiAgdmFyIGxleF9jaGVja19jb2RlID0gMTA7XG4gIHZhciBsZXhfY29kZSA9IDExO1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG4gIGlmICghdGJsLmxleF9kZWZhdWx0X2NvZGUpIHtcbiAgICB0YmwubGV4X2Jhc2VfY29kZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VfY29kZV0pO1xuICAgIHRibC5sZXhfYmFja3Rya19jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya19jb2RlXSk7XG4gICAgdGJsLmxleF9jaGVja19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja19jb2RlXSk7XG4gICAgdGJsLmxleF90cmFuc19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc19jb2RlXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0X2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0X2NvZGVdKTtcbiAgfVxuICBpZiAodGJsLmxleF9jb2RlID09IG51bGwpIHRibC5sZXhfY29kZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodGJsW2xleF9jb2RlXSk7XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2Jhc2VfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgcmV0dXJuIC1iYXNlLTE7XG4gICAgfVxuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2JhY2t0cmtfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICB2YXIgcHN0YXRlID0gc3RhdGUgO1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogSWYgc29tZSB0cmFuc2l0aW9uLCBnZXQgYW5kIHBlcmZvcm0gbWVtb3J5IG1vdmVzICovXG4gICAgICB2YXIgYmFzZV9jb2RlID0gdGJsLmxleF9iYXNlX2NvZGVbcHN0YXRlXSwgcGNfb2ZmO1xuICAgICAgaWYgKHRibC5sZXhfY2hlY2tfY29kZVtiYXNlX2NvZGUgKyBjXSA9PSBwc3RhdGUpXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfdHJhbnNfY29kZVtiYXNlX2NvZGUgKyBjXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF9kZWZhdWx0X2NvZGVbcHN0YXRlXTtcbiAgICAgIGlmIChwY19vZmYgPiAwKVxuICAgICAgICBjYW1sX2xleF9ydW5fbWVtXG4gICAgICAodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG4iLCIvL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnQodikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3Bvcyh4KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2NseiBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCkge1xuICB2YXIgbiA9IDMyO1xuICB2YXIgeTtcbiAgeSA9IHggPj4xNjsgaWYgKHkgIT0gMCkgeyBuID0gbiAtMTY7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDg7IGlmICh5ICE9IDApIHsgbiA9IG4gLSA4OyB4ID0geTsgfVxuICB5ID0geCA+PiA0OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gNDsgeCA9IHk7IH1cbiAgeSA9IHggPj4gMjsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDI7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDE7IGlmICh5ICE9IDApIHJldHVybiBuIC0gMjtcbiAgcmV0dXJuIG4gLSB4O1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY2x6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9jbHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6IGNvbnN0XG4vL1JlcXVpcmVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2NselxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6KHgpIHsgcmV0dXJuIEJhc2VfaW50X21hdGhfaW50MzJfY2x6KHgpOyB9XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50NjRfY2x6IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkLCBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfaW50NjRfdG9faW50MzJcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50NjRfY2x6KHgpIHtcbiAgdmFyIG4gPSA2NDtcbiAgdmFyIHk7XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDMyKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLTMyOyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxNik7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0xNjsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgOCk7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0gODsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgNCk7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0gNDsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMik7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0gMjsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMSk7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSByZXR1cm4gbiAtIDI7XG4gIHJldHVybiBuIC0gY2FtbF9pbnQ2NF90b19pbnQzMih4KTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHogY29uc3RcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50MzJfY3R6KHgpIHtcbiAgaWYgKHggPT09IDApIHsgcmV0dXJuIDMyOyB9XG4gIHZhciBuID0gMTtcbiAgaWYgKCAoeCAmIDB4MDAwMEZGRkYpID09PSAwKSB7IG4gPSBuICsgMTY7IHggPSB4ID4+IDE2OyB9XG4gIGlmICggKHggJiAweDAwMDAwMEZGKSA9PT0gMCkgeyBuID0gbiArICA4OyB4ID0geCA+PiAgODsgfVxuICBpZiAoICh4ICYgMHgwMDAwMDAwRikgPT09IDApIHsgbiA9IG4gKyAgNDsgeCA9IHggPj4gIDQ7IH1cbiAgaWYgKCAoeCAmIDB4MDAwMDAwMDMpID09PSAwKSB7IG4gPSBuICsgIDI7IHggPSB4ID4+ICAyOyB9XG4gIHJldHVybiBuIC0gKHggJiAxKTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnRfY3R6IGNvbnN0XG4vL1JlcXVpcmVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2N0elxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfY3R6KHgpIHsgcmV0dXJuIEJhc2VfaW50X21hdGhfaW50MzJfY3R6KHgpOyB9XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0eiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0eih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDY0X2N0eiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCwgY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FuZCwgY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50NjRfY3R6KHgpIHtcbiAgaWYgKGNhbWxfaW50NjRfaXNfemVybyh4KSkgeyByZXR1cm4gNjQ7IH1cbiAgdmFyIG4gPSAxO1xuICBmdW5jdGlvbiBpc196ZXJvICh4KSAgICB7IHJldHVybiBjYW1sX2ludDY0X2lzX3plcm8oeCk7IH1cbiAgZnVuY3Rpb24gbGFuZCAoeCx5KSAgICAgeyByZXR1cm4gY2FtbF9pbnQ2NF9hbmQoeCwgeSk7IH1cbiAgZnVuY3Rpb24gc21hbGxfaW50NjQoeCkgeyByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoeCwwLDApOyB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMHhGRkZGRkYsIDB4MDAwMEZGLCAweDAwMDApKSkpIHtcbiAgICBuID0gbiArIDMyOyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAzMik7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwRkZGRikpKSkge1xuICAgIG4gPSBuICsgMTY7IHggPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDE2KTtcbiAgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMEZGKSkpKSB7XG4gICAgbiA9IG4gKyAgODsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgOCk7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDAwRikpKSkge1xuICAgIG4gPSBuICsgIDQ7IHggPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDQpO1xuICB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgc21hbGxfaW50NjQoMHgwMDAwMDMpKSkpIHtcbiAgICBuID0gbiArICAyOyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAyKTtcbiAgfVxuICByZXR1cm4gbiAtIChjYW1sX2ludDY0X3RvX2ludDMyKGNhbWxfaW50NjRfYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMDAxKSkpKTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWIgY29uc3RcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViKGJhc2UsIGV4cG9uZW50KSB7XG4gIHZhciBvbmUgPSAxO1xuICB2YXIgbXVsID0gW29uZSwgYmFzZSwgb25lLCBvbmVdO1xuICB2YXIgcmVzID0gb25lO1xuICB3aGlsZSAoIWV4cG9uZW50PT0wKSB7XG4gICAgbXVsWzFdID0gKG11bFsxXSAqIG11bFszXSkgfCAwO1xuICAgIG11bFsyXSA9IChtdWxbMV0gKiBtdWxbMV0pIHwgMDtcbiAgICBtdWxbM10gPSAobXVsWzJdICogbXVsWzFdKSB8IDA7XG4gICAgcmVzID0gKHJlcyAqIG11bFtleHBvbmVudCAmIDNdKSB8IDA7XG4gICAgZXhwb25lbnQgPSBleHBvbmVudCA+PiAyO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWIgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWIoYmFzZSwgZXhwb25lbnQpIHtcbiAgdmFyIG9uZSA9IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKDEsMCk7XG4gIHZhciBtdWwgPSBbb25lLCBiYXNlLCBvbmUsIG9uZV07XG4gIHZhciByZXMgPSBvbmU7XG4gIHdoaWxlICghY2FtbF9pbnQ2NF9pc196ZXJvKGV4cG9uZW50KSkge1xuICAgIG11bFsxXSA9IGNhbWxfaW50NjRfbXVsKG11bFsxXSwgbXVsWzNdKTtcbiAgICBtdWxbMl0gPSBjYW1sX2ludDY0X211bChtdWxbMV0sIG11bFsxXSk7XG4gICAgbXVsWzNdID0gY2FtbF9pbnQ2NF9tdWwobXVsWzJdLCBtdWxbMV0pO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfbXVsKHJlcywgbXVsW2NhbWxfaW50NjRfbG8zMihleHBvbmVudCkgJiAzXSk7XG4gICAgZXhwb25lbnQgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKGV4cG9uZW50LCAyKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2hhc2hfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaFxuZnVuY3Rpb24gQmFzZV9oYXNoX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2hhc2goMSwxLDAscylcbn1cbi8vUHJvdmlkZXM6IEJhc2VfaGFzaF9kb3VibGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaFxuZnVuY3Rpb24gQmFzZV9oYXNoX2RvdWJsZShkKSB7XG4gIHJldHVybiBjYW1sX2hhc2goMSwxLDAsZCk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfYW1fdGVzdGluZyBjb25zdFxuLy9XZWFrZGVmXG5mdW5jdGlvbiBCYXNlX2FtX3Rlc3RpbmcoeCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBXZWFrIEFQSSwgYnV0IHdpdGhvdXQgdGhlIHdlYWsgc2VtYW50aWNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246IDwgNC4wM1xudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXQoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2tleVwiKTtcbiAgcmV0dXJuICh4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSBdPT09dW5kZWZpbmVkKT8wOnhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldCxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXRfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX3dlYWtfZ2V0KHgsIGkpO1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIHk7XG4gIHZhciB6ID0geVsxXTtcbiAgaWYgKHogaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4geTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NoZWNrIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY2hlY2soeCwgaSkge1xuICBpZih4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0hPT11bmRlZmluZWQgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldICE9PTApXG4gICAgcmV0dXJuIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxudmFyIGNhbWxfZXBoZV9jcmVhdGUgPSBjYW1sX3dlYWtfY3JlYXRlXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2JsaXRcbnZhciBjYW1sX2VwaGVfYmxpdF9rZXkgPSBjYW1sX3dlYWtfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldFxudmFyIGNhbWxfZXBoZV9nZXRfa2V5ID0gY2FtbF93ZWFrX2dldFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbnZhciBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5ID0gY2FtbF93ZWFrX2dldF9jb3B5XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jaGVja1xudmFyIGNhbWxfZXBoZV9jaGVja19rZXkgPSBjYW1sX3dlYWtfY2hlY2tcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgWzAsIHZdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgMClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICBkc3RbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuIiwiLy8vLy8vLy8vIENPUkVfS0VSTkVMXG5cbi8vUHJvdmlkZXM6IGNvcmVfYXJyYXlfdW5zYWZlX2ludF9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbnZhciBjb3JlX2FycmF5X3Vuc2FmZV9pbnRfYmxpdCA9IGNhbWxfYXJyYXlfYmxpdFxuLy9Qcm92aWRlczogY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG52YXIgY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdCA9IGNhbWxfYXJyYXlfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF90aW1lX25zX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfdGltZV9uc19mb3JtYXQodGltZSxmb3JtYXQpe1xuICB2YXIgZCA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcbiAgdmFyIGZvcm1hdGpzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmb3JtYXQpO1xuICB2YXIganN0cmluZyA9IGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lKGZvcm1hdGpzLCBkKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoanN0cmluZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX2NvbXBhY3Rpb25zXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19jb21wYWN0aW9ucyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX2hlYXBfY2h1bmtzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19oZWFwX2NodW5rcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX2hlYXBfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX2hlYXBfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19tYWpvcl9jb2xsZWN0aW9uc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfZ2NfbWFqb3JfY29sbGVjdGlvbnMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWFqb3Jfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX21ham9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWlub3JfY29sbGVjdGlvbnNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX21pbm9yX2NvbGxlY3Rpb25zICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWlub3Jfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX21pbm9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfcHJvbW90ZWRfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX3Byb21vdGVkX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfdG9wX2hlYXBfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX3RvcF9oZWFwX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuXG4vL1Byb3ZpZGVzOiBDb3JlX2tlcm5lbF9oZWFwX2Jsb2NrX2lzX2hlYXBfYmxvY2tcbmZ1bmN0aW9uIENvcmVfa2VybmVsX2hlYXBfYmxvY2tfaXNfaGVhcF9ibG9jayh4KXtcbiAgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTtcbn1cblxuLy9Qcm92aWRlczogY29yZV9tZDVfZmRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luLCBjYW1sX21kNV9jaGFuLCBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbmZ1bmN0aW9uIGNvcmVfbWQ1X2ZkKGZkKXtcbiAgICB2YXIgaWMgPSBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbWxfbWQ1X2NoYW4oaWMsIC0xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBjYW1sX21sX2Nsb3NlX2NoYW5uZWwoaWMpO1xuICAgIH1cbn1cblxuLy9Qcm92aWRlczogY29yZV9tZDVfZGlnZXN0X3N1YmJpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX2JsaXRfc3RyaW5nLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjb3JlX21kNV9kaWdlc3Rfc3ViYmlnc3RyaW5nKGJ1Ziwgb2ZzLCBsZW4sIHJlcyl7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YihidWYsIG9mcywgYnl0ZXMsIDAsIGxlbik7XG4gICAgdmFyIHJlczIgPSBjYW1sX21kNV9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnl0ZXMpLCAwLCBsZW4pO1xuICAgIGNhbWxfYmxpdF9zdHJpbmcocmVzMiwgMCwgcmVzLCAwLCAxNik7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vQmlnc3RyaW5nXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19kZXN0cm95X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1Yih2X2JzdHIpIHtcbiAgaWYgKHZfYnN0ci5oYXNPd25Qcm9wZXJ0eSgnX19pc19kZWFsbG9jYXRlZCcpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnc3RyaW5nX2Rlc3Ryb3k6IGJpZ3N0cmluZyBpcyBhbHJlYWR5IGRlYWxsb2NhdGVkXCIpO1xuICB9XG4gIC8vIE11dGF0ZSB0aGUgb3JpZ2luYWwgYmlnc3RyaW5nIGluLXBsYWNlLCB0byBzaW11bGF0ZSB3aGF0IHRoZSBDIHZlcnNpb24gZG9lc1xuICB2X2JzdHIuX19pc19kZWFsbG9jYXRlZCA9IHRydWU7XG4gIHZfYnN0ci5kYXRhID0gbmV3IHZfYnN0ci5kYXRhLl9fcHJvdG9fXy5jb25zdHJ1Y3RvcigwKTtcbiAgdl9ic3RyLmRpbXMgPSBbIDAgXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19yZWFsbG9jXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1YlxuZnVuY3Rpb24gYmlnc3RyaW5nX3JlYWxsb2MoYmlnc3RyaW5nLCBzaXplKSB7XG4gICAgaWYgKGJpZ3N0cmluZy5oYXNPd25Qcm9wZXJ0eSgnX19pc19kZWFsbG9jYXRlZCcpKSB7XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ3N0cmluZ19yZWFsbG9jOiBiaWdzdHJpbmcgaXMgYWxyZWFkeSBkZWFsbG9jYXRlZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3X2RhdGEgPSBuZXcgYmlnc3RyaW5nLmRhdGEuX19wcm90b19fLmNvbnN0cnVjdG9yKHNpemUpO1xuICAgIG5ld19kYXRhLnNldChiaWdzdHJpbmcuZGF0YS5zbGljZSgwLCBzaXplKSk7XG4gICAgdmFyIG5ld19iaWdzdHJpbmcgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmlnc3RyaW5nLmtpbmQsIGJpZ3N0cmluZy5sYXlvdXQsIFtzaXplXSwgbmV3X2RhdGEpO1xuICAgIGJpZ3N0cmluZ19kZXN0cm95X3N0dWIoYmlnc3RyaW5nKTtcblxuICAgIHJldHVybiBuZXdfYmlnc3RyaW5nO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLGxlbil7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgY2hhbl9sZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKGxlbjwwKSBsZW4gPSBjaGFuX2xlbiAtIGNoYW4ub2Zmc2V0O1xuICBpZihjaGFuLm9mZnNldCArIGxlbiA+IGNoYW5fbGVuKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuICByZXR1cm4gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZiksMCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG52YXIgY2FtbF9tZDVfYnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICBmdW5jdGlvbiBtZDUoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICB2YXIgaSA9IGxlbmd0aDtcbiAgICBidWZmZXJbaSA+PiAyXSB8PSAweDgwIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgZm9yIChpID0gKGkgJiB+MHgzKSArIDg7KGkgJiAweDNGKSA8IDYwIDtpICs9IDQpXG4gICAgICBidWZmZXJbKGkgPj4gMikgLSAxXSA9IDA7XG4gICAgYnVmZmVyWyhpID4+IDIpIC0xXSA9IGxlbmd0aCA8PCAzO1xuICAgIGJ1ZmZlcltpID4+IDJdID0gKGxlbmd0aCA+PiAyOSkgJiAweDFGRkZGRkZGO1xuXG4gICAgdmFyIHcgPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3Nl07XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDcsIDB4RDc2QUE0NzgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAzXSwgMjIsIDB4QzFCRENFRUUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNywgMHhBODMwNDYxMyk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgOV0sIDEyLCAweDhCNDRGN0FGKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDcsIDB4NkI5MDExMjIpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE1XSwgMjIsIDB4NDlCNDA4MjEpO1xuXG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTQsIDB4MjY1RTVBNTEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDUsIDB4MjFFMUNERTYpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDhdLCAyMCwgMHg0NTVBMTRFRCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTQsIDB4Njc2RjAyRDkpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgOF0sIDExLCAweDg3NzFGNjgxKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDQsIDB4QTRCRUVBNDQpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEwXSwgMjMsIDB4QkVCRkJDNzApO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNiwgMHhENEVGMzA4NSk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsxMl0sIDExLCAweEU2REI5OUU1KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNiwgMHhGNDI5MjI0NCk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDVdLCAyMSwgMHhGQzkzQTAzOSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE1LCAweEZGRUZGNDdEKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE1XSwgMTAsIDB4RkUyQ0U2RTApO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNiwgMHhGNzUzN0U4Mik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDldLCAyMSwgMHhFQjg2RDM5MSk7XG5cbiAgICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgICAgd1syXSA9IGFkZChjLCB3WzJdKTtcbiAgICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgIHRbaSAqIDQgKyBqXSA9ICh3W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocywgb2ZzLCBsZW4pIHtcbiAgICAvLyBGSVg6IG1heWJlIHdlIHNob3VsZCBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBieSBjaHVuayBvZiA2NCBieXRlc1xuICAgIC8vIGFzIGluIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LmpzXG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIHN3aXRjaCAocy50ICYgNikge1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgIHZhciBiID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgICB2YXIgYSA9IHMuYztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gSHVnbyBIZXV6YXJkXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBTaGFjaGFyIEl0emhha3lcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9ibG9iLzQuMDcvb3RoZXJsaWJzL3N0ci9zdHJzdHVicy5jXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNjb3EvanNjb3EvYmxvYi92OC4xMS9jb3EtanMvanNfc3R1Yi9zdHIuanNcblxuLy9Qcm92aWRlczogcmVfbWF0Y2hcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldFxuXG52YXIgcmVfbWF0Y2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcmVfd29yZF9sZXR0ZXJzID0gW1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4MDAtMHgxRjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4RkYsIDB4MDMsICAgICAgIC8qIDB4MjAtMHgzRjogZGlnaXRzIDAtOSAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4ODcsICAgICAgIC8qIDB4NDAtMHg1RjogQSB0byBaLCBfICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHgwNywgICAgICAgLyogMHg2MC0weDdGOiBhIHRvIHogKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDgwLTB4OUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweEEwLTB4QkY6IG5vbmUgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGLCAgICAgICAvKiAweEMwLTB4REY6IExhdGluLTEgYWNjZW50ZWQgdXBwZXJjYXNlICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiAgICAgICAgLyogMHhFMC0weEZGOiBMYXRpbi0xIGFjY2VudGVkIGxvd2VyY2FzZSAqL1xuICBdO1xuXG4gIHZhciBvcGNvZGVzID0ge1xuICAgIENIQVI6IDAsIENIQVJOT1JNOiAxLCBTVFJJTkc6IDIsIFNUUklOR05PUk06IDMsIENIQVJDTEFTUzogNCxcbiAgICBCT0w6IDUsIEVPTDogNiwgV09SREJPVU5EQVJZOiA3LFxuICAgIEJFR0dST1VQOiA4LCBFTkRHUk9VUDogOSwgUkVGR1JPVVA6IDEwLFxuICAgIEFDQ0VQVDogMTEsXG4gICAgU0lNUExFT1BUOiAxMiwgU0lNUExFU1RBUjogMTMsIFNJTVBMRVBMVVM6IDE0LFxuICAgIEdPVE86IDE1LCBQVVNIQkFDSzogMTYsIFNFVE1BUks6IDE3LFxuICAgIENIRUNLUFJPR1JFU1M6IDE4XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfd29yZF9sZXR0ZXIoYykge1xuICAgIHJldHVybiAocmVfd29yZF9sZXR0ZXJzWyAgKGMgPj4gMyldID4+IChjICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2JpdHNldChzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfc3RyaW5nX2dldChzLChpID4+IDMpKSA+PiAoaSAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiByZV9tYXRjaF9pbXBsKHJlLCBzLCBwb3MsIHBhcnRpYWwpIHtcblxuICAgIHZhciBwcm9nICAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzFdKSxcbiAgICAgICAgY3Bvb2wgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsyXSksXG4gICAgICAgIG5vcm10YWJsZSAgICAgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlWzNdKSxcbiAgICAgICAgbnVtZ3JvdXBzICAgICA9IHJlWzRdIHwgMCxcbiAgICAgICAgbnVtcmVnaXN0ZXJzICA9IHJlWzVdIHwgMCxcbiAgICAgICAgc3RhcnRjaGFycyAgICA9IHJlWzZdIHwgMDtcblxuICAgIHZhciBzID0gY2FtbF9hcnJheV9vZl9zdHJpbmcocyk7XG5cbiAgICB2YXIgcGMgPSAwLFxuICAgICAgICBxdWl0ID0gZmFsc2UsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGdyb3VwcyA9IG5ldyBBcnJheShudW1ncm91cHMpLFxuICAgICAgICByZV9yZWdpc3RlciA9IG5ldyBBcnJheShudW1yZWdpc3RlcnMpO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICBncm91cHNbaV0gPSB7c3RhcnQ6IC0xLCBlbmQ6LTF9XG4gICAgfVxuICAgIGdyb3Vwc1swXS5zdGFydCA9IHBvcztcblxuICAgIHZhciBiYWNrdHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChpdGVtLnVuZG8pIHtcbiAgICAgICAgICBpdGVtLnVuZG8ub2JqW2l0ZW0udW5kby5wcm9wXSA9IGl0ZW0udW5kby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGl0ZW0ucG9zKSB7XG4gICAgICAgICAgcGMgPSBpdGVtLnBvcy5wYztcbiAgICAgICAgICBwb3MgPSBpdGVtLnBvcy50eHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbihpdGVtKSB7IHN0YWNrLnB1c2goaXRlbSk7IH07XG5cbiAgICB2YXIgYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXBzWzBdLmVuZCA9IHBvcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMSArIGdyb3Vwcy5sZW5ndGgqMik7XG4gICAgICByZXN1bHRbMF0gPSAwOyAvLyB0YWdcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZyA9IGdyb3Vwc1tpXTtcbiAgICAgICAgaWYoZy5zdGFydCA8IDAgfHwgZy5lbmQgPCAwKSB7XG4gICAgICAgICAgZy5zdGFydCA9IGcuZW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WzIqaSArIDEgXSA9IGcuc3RhcnQ7XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxICsgMSBdID0gZy5lbmQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICB2YXIgcHJlZml4X21hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYocGFydGlhbCkgcmV0dXJuIGFjY2VwdCAoKTtcbiAgICAgIGVsc2UgYmFja3RyYWNrICgpO1xuICAgIH1cblxuICAgIC8qIE1haW4gREZBIGludGVycHJldGVyIGxvb3AgKi9cbiAgICB3aGlsZSAoIXF1aXQpIHtcbiAgICAgIHZhciBvcCA9IHByb2dbcGNdICYgMHhmZixcbiAgICAgICAgICBzYXJnID0gcHJvZ1twY10gPj4gOCxcbiAgICAgICAgICB1YXJnID0gc2FyZyAmIDB4ZmYsXG4gICAgICAgICAgYyA9IHNbcG9zXSxcbiAgICAgICAgICBncm91cDtcblxuICAgICAgcGMrKztcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVI6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGMgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSTk9STTpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkc6XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAoYyA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklOR05PUk06XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSQ0xBU1M6XG4gICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICBpZihwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgaWYocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5XT1JEQk9VTkRBUlk6XG4gICAgICAgIGlmKHBvcyA9PSAwKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbMF0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQkVHR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLnN0YXJ0fX0pO1xuICAgICAgICBncm91cC5zdGFydCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuZW5kfX0pO1xuICAgICAgICBncm91cC5lbmQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgaWYoZ3JvdXAuc3RhcnQgPCAwIHx8IGdyb3VwLmVuZCA8IDApIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKyl7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKHNbaV0gIT0gc1twb3NdKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpXG4gICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVQTFVTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgcHVzaCh7cG9zOiB7cGM6IHBjICsgc2FyZywgdHh0OiBwb3N9fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNFVE1BUks6XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6cmVfcmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOiB1YXJnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddfX0pO1xuICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hFQ0tQUk9HUkVTUzpcbiAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KCk7XG5cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2ZvcndhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIilcbiAgd2hpbGUgKHBvcyA8PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpXG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcy0tO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcGFydGlhbF9tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9wYXJ0aWFsX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCxncm91cHMsb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZShuIDwgbGVuKXtcbiAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgIGlmKGN1ciAhPSAnXFxcXCcpe1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihuID09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2goY3VyKXtcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgIGlmIChjKjIgPj0gZ3JvdXBzLmxlbmd0aCAtIDEgKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiICk7XG4gICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLGMqMik7XG4gICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyoyICsxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IC0xKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgcmVzKz1vcmlnLnNsaWNlKHN0YXJ0LGVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzICs9ICgnXFxcXCcgICsgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTsgfVxuIiwiLy9UaGUgZm9sbG93aW5nIGFyZSBkZWZpbmVkIGluIENzdHJ1Y3Rcbi8vVGhlcmUgYXJlIGp1c3QgcHJvdmlkZWQgaGVyZSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuIiwiLy8vLy8vLy8vIFRJTUVfTk9XXG5cbi8vUHJvdmlkZXM6IHRpbWVfbm93X25hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2hfb3JfemVyb1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbnZhciBtc190b19uYW5vID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxMDAwKjEwMDApO1xuZnVuY3Rpb24gdGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvKCl7XG4gICAgdmFyIG1zID0gRGF0ZS5ub3coKTtcbiAgICAvLyBtdWx0aXBsZSBieSB0d28gLSBpbnQ2MyBpbnRlZ2VycyBhcmUgc2hpZnRlZCB0byB0aGUgbGVmdFxuICAgIHZhciBtc19pNjMgPSBjYW1sX2ludDY0X29mX2Zsb2F0KG1zKjIpO1xuICAgIHJldHVybiBjYW1sX2ludDY0X211bChtc19pNjMsbXNfdG9fbmFubyk7XG59XG4iXX0=
